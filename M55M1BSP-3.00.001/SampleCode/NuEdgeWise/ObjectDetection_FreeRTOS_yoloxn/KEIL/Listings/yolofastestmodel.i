# 1 "../Model/YoloFastestModel.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 404 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "../Model/YoloFastestModel.cpp" 2
# 17 "../Model/YoloFastestModel.cpp"
# 1 "../Model/include\\YoloFastestModel.hpp" 1
# 20 "../Model/include\\YoloFastestModel.hpp"
# 1 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include\\Model.hpp" 1
# 20 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include\\Model.hpp"
# 1 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 1
# 29 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"

# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 1
# 18 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdio" 1 3
# 98 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdio" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 1 3
# 27 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
# 813 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
namespace std { inline namespace __2 { } }
# 99 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdio" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdio.h" 1 3
# 105 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdio.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 1 3
# 41 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
      namespace std {

        extern "C" {
# 53 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
    typedef unsigned int size_t;
# 68 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
    typedef __builtin_va_list __va_list;
# 87 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
typedef struct __fpos_t_struct {
    unsigned long long int __pos;





    struct {
        unsigned int __state1, __state2;
    } __mbstate;
} fpos_t;
# 108 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
typedef struct __FILE FILE;
# 119 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
struct __FILE {
    union {
        long __FILE_alignment;



        char __FILE_size[84];

    } __FILE_opaque;
};
# 138 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern FILE __stdin, __stdout, __stderr;
extern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
# 224 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int remove(const char * ) __attribute__((__nonnull__(1)));







extern __attribute__((__nothrow__)) int rename(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 243 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) FILE *tmpfile(void);






extern __attribute__((__nothrow__)) char *tmpnam(char * );
# 265 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fclose(FILE * ) __attribute__((__nonnull__(1)));
# 275 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fflush(FILE * );
# 285 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) FILE *fopen(const char * __restrict ,
                           const char * __restrict ) __attribute__((__nonnull__(1,2)));
# 329 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) FILE *freopen(const char * __restrict ,
                    const char * __restrict ,
                    FILE * __restrict ) __attribute__((__nonnull__(2,3)));
# 342 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) void setbuf(FILE * __restrict ,
                    char * __restrict ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) int setvbuf(FILE * __restrict ,
                   char * __restrict ,
                   int , size_t ) __attribute__((__nonnull__(1)));
# 370 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __printf_args
extern __attribute__((__nothrow__)) int fprintf(FILE * __restrict ,
                    const char * __restrict , ...) __attribute__((__nonnull__(1,2)));
# 393 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __printf_args
extern __attribute__((__nothrow__)) int _fprintf(FILE * __restrict ,
                     const char * __restrict , ...) __attribute__((__nonnull__(1,2)));





#pragma __printf_args
extern __attribute__((__nothrow__)) int printf(const char * __restrict , ...) __attribute__((__nonnull__(1)));






#pragma __printf_args
extern __attribute__((__nothrow__)) int _printf(const char * __restrict , ...) __attribute__((__nonnull__(1)));





#pragma __printf_args
extern __attribute__((__nothrow__)) int sprintf(char * __restrict , const char * __restrict , ...) __attribute__((__nonnull__(1,2)));








#pragma __printf_args
extern __attribute__((__nothrow__)) int _sprintf(char * __restrict , const char * __restrict , ...) __attribute__((__nonnull__(1,2)));






#pragma __printf_args
extern __attribute__((__nothrow__)) int __ARM_snprintf(char * __restrict , size_t ,
                     const char * __restrict , ...) __attribute__((__nonnull__(3)));


#pragma __printf_args
extern __attribute__((__nothrow__)) int snprintf(char * __restrict , size_t ,
                     const char * __restrict , ...) __attribute__((__nonnull__(3)));
# 460 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __printf_args
extern __attribute__((__nothrow__)) int _snprintf(char * __restrict , size_t ,
                      const char * __restrict , ...) __attribute__((__nonnull__(3)));





#pragma __scanf_args
extern __attribute__((__nothrow__)) int fscanf(FILE * __restrict ,
                    const char * __restrict , ...) __attribute__((__nonnull__(1,2)));
# 503 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __scanf_args
extern __attribute__((__nothrow__)) int _fscanf(FILE * __restrict ,
                     const char * __restrict , ...) __attribute__((__nonnull__(1,2)));





#pragma __scanf_args
extern __attribute__((__nothrow__)) int scanf(const char * __restrict , ...) __attribute__((__nonnull__(1)));








#pragma __scanf_args
extern __attribute__((__nothrow__)) int _scanf(const char * __restrict , ...) __attribute__((__nonnull__(1)));





#pragma __scanf_args
extern __attribute__((__nothrow__)) int sscanf(const char * __restrict ,
                    const char * __restrict , ...) __attribute__((__nonnull__(1,2)));
# 541 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __scanf_args
extern __attribute__((__nothrow__)) int _sscanf(const char * __restrict ,
                     const char * __restrict , ...) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int vfscanf(FILE * __restrict , const char * __restrict , __va_list) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) int vscanf(const char * __restrict , __va_list) __attribute__((__nonnull__(1)));
extern __attribute__((__nothrow__)) int vsscanf(const char * __restrict , const char * __restrict , __va_list) __attribute__((__nonnull__(1,2)));

extern __attribute__((__nothrow__)) int _vfscanf(FILE * __restrict , const char * __restrict , __va_list) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) int _vscanf(const char * __restrict , __va_list) __attribute__((__nonnull__(1)));
extern __attribute__((__nothrow__)) int _vsscanf(const char * __restrict , const char * __restrict , __va_list) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) int __ARM_vsscanf(const char * __restrict , const char * __restrict , __va_list) __attribute__((__nonnull__(1,2)));

extern __attribute__((__nothrow__)) int vprintf(const char * __restrict , __va_list ) __attribute__((__nonnull__(1)));







extern __attribute__((__nothrow__)) int _vprintf(const char * __restrict , __va_list ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) int vfprintf(FILE * __restrict ,
                    const char * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));
# 584 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int vsprintf(char * __restrict ,
                     const char * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));
# 594 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int __ARM_vsnprintf(char * __restrict , size_t ,
                     const char * __restrict , __va_list ) __attribute__((__nonnull__(3)));

extern __attribute__((__nothrow__)) int vsnprintf(char * __restrict , size_t ,
                     const char * __restrict , __va_list ) __attribute__((__nonnull__(3)));
# 609 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int _vsprintf(char * __restrict ,
                      const char * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));





extern __attribute__((__nothrow__)) int _vfprintf(FILE * __restrict ,
                     const char * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));





extern __attribute__((__nothrow__)) int _vsnprintf(char * __restrict , size_t ,
                      const char * __restrict , __va_list ) __attribute__((__nonnull__(3)));
# 635 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
#pragma __printf_args
extern __attribute__((__nothrow__)) int __ARM_asprintf(char ** , const char * __restrict , ...) __attribute__((__nonnull__(2)));
extern __attribute__((__nothrow__)) int __ARM_vasprintf(char ** , const char * __restrict , __va_list ) __attribute__((__nonnull__(2)));
# 649 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fgetc(FILE * ) __attribute__((__nonnull__(1)));
# 659 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) char *fgets(char * __restrict , int ,
                    FILE * __restrict ) __attribute__((__nonnull__(1,3)));
# 673 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fputc(int , FILE * ) __attribute__((__nonnull__(2)));
# 683 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fputs(const char * __restrict , FILE * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) int getc(FILE * ) __attribute__((__nonnull__(1)));
# 701 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
    inline int getchar() { return getc((&::std:: __stdin)); }
# 713 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) char *gets(char * ) __attribute__((__nonnull__(1)));
# 725 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int putc(int , FILE * ) __attribute__((__nonnull__(2)));
# 734 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
    inline int putchar(int __c) { return putc(__c, (&::std:: __stdout)); }
# 744 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int puts(const char * ) __attribute__((__nonnull__(1)));







extern __attribute__((__nothrow__)) int ungetc(int , FILE * ) __attribute__((__nonnull__(2)));
# 778 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) size_t fread(void * __restrict ,
                    size_t , size_t , FILE * __restrict ) __attribute__((__nonnull__(1,4)));
# 794 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) size_t __fread_bytes_avail(void * __restrict ,
                    size_t , FILE * __restrict ) __attribute__((__nonnull__(1,3)));
# 810 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) size_t fwrite(const void * __restrict ,
                    size_t , size_t , FILE * __restrict ) __attribute__((__nonnull__(1,4)));
# 822 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fgetpos(FILE * __restrict , fpos_t * __restrict ) __attribute__((__nonnull__(1,2)));
# 833 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fseek(FILE * , long int , int ) __attribute__((__nonnull__(1)));
# 850 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int fsetpos(FILE * __restrict , const fpos_t * __restrict ) __attribute__((__nonnull__(1,2)));
# 863 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) long int ftell(FILE * ) __attribute__((__nonnull__(1)));
# 877 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) void rewind(FILE * ) __attribute__((__nonnull__(1)));
# 886 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) void clearerr(FILE * ) __attribute__((__nonnull__(1)));







extern __attribute__((__nothrow__)) int feof(FILE * ) __attribute__((__nonnull__(1)));




extern __attribute__((__nothrow__)) int ferror(FILE * ) __attribute__((__nonnull__(1)));




extern __attribute__((__nothrow__)) void perror(const char * );
# 917 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
extern __attribute__((__nothrow__)) int _fisatty(FILE * ) __attribute__((__nonnull__(1)));



extern __attribute__((__nothrow__)) void __use_no_semihosting_swi(void);
extern __attribute__((__nothrow__)) void __use_no_semihosting(void);
# 932 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
        }
      }
# 942 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdio.h" 3
    using ::std::size_t;
    using ::std::fpos_t;
    using ::std::FILE;
    using ::std::remove;
    using ::std::rename;
    using ::std::tmpfile;
    using ::std::tmpnam;
    using ::std::fclose;
    using ::std::fflush;
    using ::std::fopen;
    using ::std::freopen;
    using ::std::setbuf;
    using ::std::setvbuf;
    using ::std::fprintf;
    using ::std::_fprintf;
    using ::std::printf;
    using ::std::_printf;
    using ::std::sprintf;
    using ::std::_sprintf;

      using ::std::snprintf;
      using ::std::vsnprintf;
      using ::std::vfscanf;
      using ::std::vscanf;
      using ::std::vsscanf;

    using ::std::_snprintf;
    using ::std::_vsnprintf;




    using ::std::__ARM_asprintf;
    using ::std::__ARM_vasprintf;
    using ::std::__ARM_vsnprintf;
    using ::std::__ARM_snprintf;
    using ::std::__ARM_vsscanf;
    using ::std::fscanf;
    using ::std::_fscanf;
    using ::std::scanf;
    using ::std::_scanf;
    using ::std::sscanf;
    using ::std::_sscanf;
    using ::std::_vfscanf;
    using ::std::_vscanf;
    using ::std::_vsscanf;
    using ::std::vprintf;
    using ::std::_vprintf;
    using ::std::vfprintf;
    using ::std::_vfprintf;
    using ::std::vsprintf;
    using ::std::_vsprintf;
    using ::std::fgetc;
    using ::std::fgets;
    using ::std::fputc;
    using ::std::fputs;
    using ::std::getc;
    using ::std::getchar;
    using ::std::gets;
    using ::std::putc;
    using ::std::putchar;
    using ::std::puts;
    using ::std::ungetc;
    using ::std::fread;
    using ::std::__fread_bytes_avail;
    using ::std::fwrite;
    using ::std::fgetpos;
    using ::std::fseek;
    using ::std::fsetpos;
    using ::std::ftell;
    using ::std::rewind;
    using ::std::clearerr;
    using ::std::feof;
    using ::std::ferror;
    using ::std::perror;
    using ::std::_fisatty;
    using ::std::__use_no_semihosting_swi;
    using ::std::__use_no_semihosting;
# 108 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdio.h" 2 3
# 100 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdio" 2 3
# 103 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdio" 3


namespace std { inline namespace __2 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::vfprintf;
using ::vfscanf;
using ::vsscanf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;

using ::fgetpos;

using ::fseek;

using ::fsetpos;

using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;

using ::gets;

using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;


} }
# 19 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstring" 1 3
# 60 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstring" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string.h" 1 3
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 1 3
# 32 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
        namespace std {

        extern "C" {
# 44 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
    typedef unsigned int size_t;
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memcpy(void * __restrict ,
                    const void * __restrict , size_t ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) void *memmove(void * ,
                    const void * , size_t ) __attribute__((__nonnull__(1,2)));
# 77 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcpy(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncpy(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 93 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcat(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncat(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 117 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int memcmp(const void * , const void * , size_t ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strcmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) int strncmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 141 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcasecmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strncasecmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 158 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcoll(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 169 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strxfrm(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(2)));
# 188 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) const void *memchr(const void * , int , size_t ) __attribute__((__nonnull__(1)));
extern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
extern "C++" inline void *memchr(void * __s, int __c, size_t __n)
    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
# 204 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) const char *strchr(const char * , int ) __attribute__((__nonnull__(1)));
extern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
extern "C++" inline char *strchr(char * __s, int __c)
    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
# 218 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strcspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 227 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) const char *strpbrk(const char * , const char * ) __attribute__((__nonnull__(1,2)));
extern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
extern "C++" inline char *strpbrk(char * __s1, const char * __s2)
    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
# 242 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) const char *strrchr(const char * , int ) __attribute__((__nonnull__(1)));
extern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
extern "C++" inline char *strrchr(char * __s, int __c)
    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
# 257 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) const char *strstr(const char * , const char * ) __attribute__((__nonnull__(1,2)));
extern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
extern "C++" inline char *strstr(char * __s1, const char * __s2)
    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
# 280 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strtok(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(2)));
extern __attribute__((__nothrow__)) char *_strtok_r(char * , const char * , char ** ) __attribute__((__nonnull__(2,3)));
# 321 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memset(void * , int , size_t ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) char *strerror(int );







extern __attribute__((__nothrow__)) size_t strlen(const char * ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) size_t strlcpy(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 362 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strlcat(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 388 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void _membitcpybl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpybb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
# 450 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
         }
      }





      using ::std::size_t;
      using ::std::memcpy;
      using ::std::memmove;
      using ::std::strcpy;
      using ::std::strncpy;
      using ::std::strcat;
      using ::std::strncat;
      using ::std::memcmp;
      using ::std::strcmp;
      using ::std::strncmp;
      using ::std::strcasecmp;
      using ::std::strncasecmp;
      using ::std::strcoll;
      using ::std::strxfrm;
      using ::std::memchr;
      using ::std::strchr;
      using ::std::strcspn;
      using ::std::strpbrk;
      using ::std::strrchr;
      using ::std::strspn;
      using ::std::strstr;
      using ::std::strtok;



      using ::std::_strtok_r;
      using ::std::memset;
      using ::std::strerror;
      using ::std::strlen;
      using ::std::strlcpy;
      using ::std::strlcat;
      using ::std::_membitcpybl;
      using ::std::_membitcpybb;
      using ::std::_membitcpyhl;
      using ::std::_membitcpyhb;
      using ::std::_membitcpywl;
      using ::std::_membitcpywb;
      using ::std::_membitmovebl;
      using ::std::_membitmovebb;
      using ::std::_membitmovehl;
      using ::std::_membitmovehb;
      using ::std::_membitmovewl;
      using ::std::_membitmovewb;
# 61 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string.h" 2 3
# 71 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 61 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstring" 2 3
# 64 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstring" 3


namespace std { inline namespace __2 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }
# 20 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2

# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h" 1
# 39 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdbool.h" 1 3
# 26 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdbool.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdbool.h" 1 3
# 29 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdbool.h" 2 3
# 40 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 1 3
# 43 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 1 3
# 28 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
        namespace std {

        extern "C" {







  typedef signed int ptrdiff_t;







    typedef unsigned int size_t;
# 95 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
  typedef long double max_align_t;



         }
      }






      using ::std::size_t;
      using ::std::ptrdiff_t;

        using ::std::max_align_t;
# 46 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 2 3



extern "C++" {

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__nullptr" 1 3
# 17 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__nullptr" 3
# 54 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 2 3
using std::nullptr_t;
}
# 41 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 1 3
# 110 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 123 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 1 3
# 40 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
      namespace std {

          extern "C" {
# 56 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;


typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;





typedef signed char int_least8_t;
typedef signed short int int_least16_t;
typedef signed int int_least32_t;
typedef signed long long int int_least64_t;


typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long int uint_least64_t;




typedef signed int int_fast8_t;
typedef signed int int_fast16_t;
typedef signed int int_fast32_t;
typedef signed long long int int_fast64_t;


typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long int uint_fast64_t;






typedef signed int intptr_t;
typedef unsigned int uintptr_t;



typedef signed long long intmax_t;
typedef unsigned long long uintmax_t;
# 268 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
         }
      }





      using ::std::int8_t;
      using ::std::int16_t;
      using ::std::int32_t;
      using ::std::int64_t;
      using ::std::uint8_t;
      using ::std::uint16_t;
      using ::std::uint32_t;
      using ::std::uint64_t;
      using ::std::int_least8_t;
      using ::std::int_least16_t;
      using ::std::int_least32_t;
      using ::std::int_least64_t;
      using ::std::uint_least8_t;
      using ::std::uint_least16_t;
      using ::std::uint_least32_t;
      using ::std::uint_least64_t;
      using ::std::int_fast8_t;
      using ::std::int_fast16_t;
      using ::std::int_fast32_t;
      using ::std::int_fast64_t;
      using ::std::uint_fast8_t;
      using ::std::uint_fast16_t;
      using ::std::uint_fast32_t;
      using ::std::uint_fast64_t;
      using ::std::intptr_t;
      using ::std::uintptr_t;
      using ::std::intmax_t;
      using ::std::uintmax_t;
# 124 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 2 3
# 42 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h" 2

# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/c_api_types.h" 1
# 25 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/c_api_types.h"
extern "C" {
# 49 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/c_api_types.h"
typedef enum TfLiteStatus {
  kTfLiteOk = 0,


  kTfLiteError = 1,


  kTfLiteDelegateError = 2,





  kTfLiteApplicationError = 3,



  kTfLiteDelegateDataNotFound = 4,



  kTfLiteDelegateDataWriteError = 5,



  kTfLiteDelegateDataReadError = 6,




  kTfLiteUnresolvedOps = 7,
} TfLiteStatus;


typedef enum {
  kTfLiteNoType = 0,
  kTfLiteFloat32 = 1,
  kTfLiteInt32 = 2,
  kTfLiteUInt8 = 3,
  kTfLiteInt64 = 4,
  kTfLiteString = 5,
  kTfLiteBool = 6,
  kTfLiteInt16 = 7,
  kTfLiteComplex64 = 8,
  kTfLiteInt8 = 9,
  kTfLiteFloat16 = 10,
  kTfLiteFloat64 = 11,
  kTfLiteComplex128 = 12,
  kTfLiteUInt64 = 13,
  kTfLiteResource = 14,
  kTfLiteVariant = 15,
  kTfLiteUInt32 = 16,
  kTfLiteUInt16 = 17,
} TfLiteType;







typedef struct TfLiteQuantizationParams {
  float scale;
  int32_t zero_point;
} TfLiteQuantizationParams;


}
# 44 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h" 2


extern "C" {






typedef enum TfLiteExternalContextType {
  kTfLiteEigenContext = 0,
  kTfLiteGemmLowpContext = 1,
  kTfLiteEdgeTpuContext = 2,
  kTfLiteCpuBackendContext = 3,
  kTfLiteMaxExternalContexts = 4
} TfLiteExternalContextType;



struct TfLiteContext;
struct TfLiteDelegate;
struct TfLiteRegistration;






typedef struct TfLiteExternalContext {
  TfLiteExternalContextType type;
  TfLiteStatus (*Refresh)(struct TfLiteContext* context);
} TfLiteExternalContext;





typedef struct TfLiteIntArray {
  int size;
# 95 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  int data[];

} TfLiteIntArray;



size_t TfLiteIntArrayGetSizeInBytes(int size);
# 110 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
int TfLiteIntArrayEqual(const TfLiteIntArray* a, const TfLiteIntArray* b);


int TfLiteIntArrayEqualsArray(const TfLiteIntArray* a, int b_size,
                              const int b_data[]);
# 126 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteFloatArray {
  int size;
# 139 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  float data[];

} TfLiteFloatArray;



int TfLiteFloatArrayGetSizeInBytes(int size);
# 253 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteComplex64 {
  float re, im;
} TfLiteComplex64;


typedef struct TfLiteComplex128 {
  double re, im;
} TfLiteComplex128;


typedef struct TfLiteFloat16 {
  uint16_t data;
} TfLiteFloat16;


const char* TfLiteTypeGetName(TfLiteType type);


typedef enum TfLiteQuantizationType {

  kTfLiteNoQuantization = 0,


  kTfLiteAffineQuantization = 1,
} TfLiteQuantizationType;


typedef struct TfLiteQuantization {

  TfLiteQuantizationType type;



  void* params;
} TfLiteQuantization;
# 296 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteAffineQuantization {
  TfLiteFloatArray* scale;
  TfLiteIntArray* zero_point;
  int32_t quantized_dimension;
} TfLiteAffineQuantization;


typedef union TfLitePtrUnion {



  int32_t* i32;
  uint32_t* u32;
  int64_t* i64;
  uint64_t* u64;
  float* f;
  TfLiteFloat16* f16;
  double* f64;
  char* raw;
  const char* raw_const;
  uint8_t* uint8;
  bool* b;
  int16_t* i16;
  uint16_t* ui16;
  TfLiteComplex64* c64;
  TfLiteComplex128* c128;
  int8_t* int8;

  void* data;
} TfLitePtrUnion;
# 339 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef enum TfLiteAllocationType {
  kTfLiteMemNone = 0,
  kTfLiteMmapRo,
  kTfLiteArenaRw,
  kTfLiteArenaRwPersistent,
  kTfLiteDynamic,
  kTfLitePersistentRo,
  kTfLiteCustom,
} TfLiteAllocationType;



typedef int TfLiteBufferHandle;
enum {
  kTfLiteNullBufferHandle = -1,
};


typedef enum TfLiteDimensionType {
  kTfLiteDimDense = 0,
  kTfLiteDimSparseCSR,
} TfLiteDimensionType;


typedef struct TfLiteDimensionMetadata {
  TfLiteDimensionType format;
  int dense_size;
  TfLiteIntArray* array_segments;
  TfLiteIntArray* array_indices;
} TfLiteDimensionMetadata;



typedef struct TfLiteSparsity {
  TfLiteIntArray* traversal_order;
  TfLiteIntArray* block_map;
  TfLiteDimensionMetadata* dim_metadata;
  int dim_metadata_size;
} TfLiteSparsity;





typedef struct TfLiteCustomAllocation {
  void* data;
  size_t bytes;
} TfLiteCustomAllocation;



typedef enum TfLiteCustomAllocationFlags {
  kTfLiteCustomAllocationFlagsNone = 0,




  kTfLiteCustomAllocationFlagsSkipAlignCheck = 1,
} TfLiteCustomAllocationFlags;
# 523 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteTensor {


  TfLiteQuantization quantization;


  TfLiteQuantizationParams params;



  TfLitePtrUnion data;




  TfLiteIntArray* dims;





  size_t bytes;



  TfLiteType type;






  TfLiteAllocationType allocation_type;


  bool is_variable;
} TfLiteTensor;
# 568 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteNode {

  TfLiteIntArray* inputs;


  TfLiteIntArray* outputs;



  TfLiteIntArray* intermediates;


  void* user_data;



  void* builtin_data;



  const void* custom_initial_data;
  int custom_initial_data_size;
} TfLiteNode;






typedef struct TfLiteEvalTensor {


  TfLitePtrUnion data;



  TfLiteIntArray* dims;



  TfLiteType type;
} TfLiteEvalTensor;
# 653 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
typedef struct TfLiteDelegateParams {
  struct TfLiteDelegate* delegate;
  TfLiteIntArray* nodes_to_replace;
  TfLiteIntArray* input_tensors;
  TfLiteIntArray* output_tensors;
} TfLiteDelegateParams;

typedef struct TfLiteContext {

  size_t tensors_size;
# 702 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  TfLiteStatus (*GetExecutionPlan)(struct TfLiteContext* context,
                                   TfLiteIntArray** execution_plan);


  TfLiteTensor* tensors;


  void* impl_;



  TfLiteStatus (*ResizeTensor)(struct TfLiteContext*, TfLiteTensor* tensor,
                               TfLiteIntArray* new_size);

  void (*ReportError)(struct TfLiteContext*, const char* msg, ...);




  TfLiteStatus (*AddTensors)(struct TfLiteContext*, int tensors_to_add,
                             int* first_new_tensor_index);



  TfLiteStatus (*GetNodeAndRegistration)(
      struct TfLiteContext*, int node_index, TfLiteNode** node,
      struct TfLiteRegistration** registration);



  TfLiteStatus (*ReplaceNodeSubsetsWithDelegateKernels)(
      struct TfLiteContext*, struct TfLiteRegistration registration,
      const TfLiteIntArray* nodes_to_replace, struct TfLiteDelegate* delegate);



  int recommended_num_threads;



  TfLiteExternalContext* (*GetExternalContext)(struct TfLiteContext*,
                                               TfLiteExternalContextType);



  void (*SetExternalContext)(struct TfLiteContext*, TfLiteExternalContextType,
                             TfLiteExternalContext*);




  bool allow_fp32_relax_to_fp16;


  void* profiler;






  void* (*AllocatePersistentBuffer)(struct TfLiteContext* ctx, size_t bytes);







  TfLiteStatus (*AllocateBufferForEval)(struct TfLiteContext* ctx, size_t bytes,
                                        void** ptr);






  TfLiteStatus (*RequestScratchBufferInArena)(struct TfLiteContext* ctx,
                                              size_t bytes, int* buffer_idx);




  void* (*GetScratchBuffer)(struct TfLiteContext* ctx, int buffer_idx);





  TfLiteStatus (*ResizeTensorExplicit)(struct TfLiteContext* ctx,
                                       TfLiteTensor* tensor, int dims,
                                       const int* shape);
# 815 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  TfLiteStatus (*PreviewDelegatePartitioning)(
      struct TfLiteContext* context, const TfLiteIntArray* nodes_to_replace,
      TfLiteDelegateParams** partition_params_array, int* num_partitions);




  TfLiteTensor* (*GetTensor)(const struct TfLiteContext* context,
                             int tensor_idx);




  TfLiteEvalTensor* (*GetEvalTensor)(const struct TfLiteContext* context,
                                     int tensor_idx);
# 839 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  TfLiteStatus (*GetModelMetadata)(const struct TfLiteContext* context,
                                   const char* name, const char** ptr,
                                   size_t* bytes);
} TfLiteContext;

typedef struct TfLiteRegistration {
# 863 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  void* (*init)(TfLiteContext* context, const char* buffer, size_t length);


  void (*free)(TfLiteContext* context, void* buffer);







  TfLiteStatus (*prepare)(TfLiteContext* context, TfLiteNode* node);



  TfLiteStatus (*invoke)(TfLiteContext* context, TfLiteNode* node);






  const char* (*profiling_string)(const TfLiteContext* context,
                                  const TfLiteNode* node);






  int32_t builtin_code;





  const char* custom_name;




  int version;
} TfLiteRegistration;



typedef enum TfLiteDelegateFlags {
  kTfLiteDelegateFlagsNone = 0,
# 920 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  kTfLiteDelegateFlagsAllowDynamicTensors = 1,
# 939 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/common.h"
  kTfLiteDelegateFlagsRequirePropagatedShapes = 2
} TfLiteDelegateFlags;


typedef struct TfLiteDelegate {



  void* data_;






  TfLiteStatus (*Prepare)(TfLiteContext* context,
                          struct TfLiteDelegate* delegate);





  TfLiteStatus (*CopyFromBufferHandle)(TfLiteContext* context,
                                       struct TfLiteDelegate* delegate,
                                       TfLiteBufferHandle buffer_handle,
                                       TfLiteTensor* tensor);



  TfLiteStatus (*CopyToBufferHandle)(TfLiteContext* context,
                                     struct TfLiteDelegate* delegate,
                                     TfLiteBufferHandle buffer_handle,
                                     TfLiteTensor* tensor);





  void (*FreeBufferHandle)(TfLiteContext* context,
                           struct TfLiteDelegate* delegate,
                           TfLiteBufferHandle* handle);


  int64_t flags;
} TfLiteDelegate;



TfLiteDelegate TfLiteDelegateCreate(void);


}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/error_reporter.h" 1
# 18 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/error_reporter.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdarg" 1 3
# 35 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdarg" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 1 3
# 21 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
      namespace std {

          extern "C" {
# 40 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
  typedef __builtin_va_list va_list;
# 128 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
         }
      }




     typedef ::std:: va_list __gnuc_va_list;
# 143 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
      using ::std::va_list;
# 36 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdarg" 2 3
# 39 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdarg" 3


namespace std { inline namespace __2 {

using ::va_list;

} }
# 19 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/error_reporter.h" 2

namespace tflite {
# 35 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/error_reporter.h"
class ErrorReporter {
 public:
  virtual ~ErrorReporter() {}
  virtual int Report(const char* format, va_list args) = 0;
  int Report(const char* format, ...);
  int ReportError(void*, const char* format, ...);
};

}
# 23 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h" 1
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstddef" 1 3
# 37 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstddef" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\version" 1 3
# 171 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\version" 3
# 38 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstddef" 2 3
# 41 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstddef" 3






namespace std { inline namespace __2 {

using ::ptrdiff_t;
using ::size_t;


using ::max_align_t;


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };




template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };





} }
# 23 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 1 3
# 91 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__availability" 1 3
# 17 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__availability" 3
# 92 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdlib" 1 3
# 85 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdlib" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 1 3
# 92 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 1 3
# 52 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
      namespace std {

          extern "C" {
# 64 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
    typedef unsigned int size_t;
# 96 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
typedef struct div_t { int quot, rem; } div_t;

typedef struct ldiv_t { long int quot, rem; } ldiv_t;


typedef struct lldiv_t { long long quot, rem; } lldiv_t;
# 139 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int __aeabi_MB_CUR_MAX(void);
# 158 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) double atof(const char * ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) int atoi(const char * ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) long int atol(const char * ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) long long atoll(const char * ) __attribute__((__nonnull__(1)));







extern __attribute__((__nothrow__)) double strtod(const char * __restrict , char ** __restrict ) __attribute__((__nonnull__(1)));
# 206 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) float strtof(const char * __restrict , char ** __restrict ) __attribute__((__nonnull__(1)));
extern __attribute__((__nothrow__)) long double strtold(const char * __restrict , char ** __restrict ) __attribute__((__nonnull__(1)));




extern __attribute__((__nothrow__)) long int strtol(const char * __restrict ,
                        char ** __restrict , int ) __attribute__((__nonnull__(1)));
# 243 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) unsigned long int strtoul(const char * __restrict ,
                                       char ** __restrict , int ) __attribute__((__nonnull__(1)));
# 275 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) long long strtoll(const char * __restrict ,
                                  char ** __restrict , int )
                          __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) unsigned long long strtoull(const char * __restrict ,
                                            char ** __restrict , int )
                                   __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) int rand(void);
# 303 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) void srand(unsigned int );
# 313 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
struct _rand_state { int __x[57]; };
extern __attribute__((__nothrow__)) int _rand_r(struct _rand_state *);
extern __attribute__((__nothrow__)) void _srand_r(struct _rand_state *, unsigned int);
struct _ANSI_rand_state { int __x[1]; };
extern __attribute__((__nothrow__)) int _ANSI_rand_r(struct _ANSI_rand_state *);
extern __attribute__((__nothrow__)) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);





extern __attribute__((__nothrow__)) void *calloc(size_t , size_t );





extern __attribute__((__nothrow__)) void free(void * );







extern __attribute__((__nothrow__)) void *malloc(size_t );





extern __attribute__((__nothrow__)) void *realloc(void * , size_t );
# 374 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
typedef int (*__heapprt)(void *, char const *, ...);
extern __attribute__((__nothrow__)) void __heapstats(int (* )(void * ,
                                           char const * , ...),
                        void * ) __attribute__((__nonnull__(1)));
# 390 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int __heapvalid(int (* )(void * ,
                                           char const * , ...),
                       void * , int ) __attribute__((__nonnull__(1)));
# 411 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) __attribute__((__noreturn__)) void abort(void);
# 422 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int atexit(void (* )(void)) __attribute__((__nonnull__(1)));
# 444 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) __attribute__((__noreturn__)) void exit(int );
# 460 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) __attribute__((__noreturn__)) void _Exit(int );
# 471 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) char *getenv(const char * ) __attribute__((__nonnull__(1)));
# 484 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int system(const char * );
# 497 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern void *bsearch(const void * , const void * ,
              size_t , size_t ,
              int (* )(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
# 532 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern void qsort(void * , size_t , size_t ,
           int (* )(const void *, const void *)) __attribute__((__nonnull__(1,4)));
# 560 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) __attribute__((__const__)) int abs(int );






extern __attribute__((__nothrow__)) __attribute__((__const__)) div_t div(int , int );
# 579 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) __attribute__((__const__)) long int labs(long int );






   extern "C++" inline __attribute__((__nothrow__)) __attribute__((__const__)) long abs(long int x) { return labs(x); }


extern __attribute__((__nothrow__)) __attribute__((__const__)) ldiv_t ldiv(long int , long int );
# 604 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
   extern "C++" inline __attribute__((__nothrow__)) __attribute__((__const__)) ldiv_t div(long int __numer, long int __denom) {
       return ldiv(__numer, __denom);
   }



extern __attribute__((__nothrow__)) __attribute__((__const__)) long long llabs(long long );






   extern "C++" inline __attribute__((__nothrow__)) __attribute__((__const__)) long long abs(long long x) { return llabs(x); }


extern __attribute__((__nothrow__)) __attribute__((__const__)) lldiv_t lldiv(long long , long long );
# 635 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
   extern "C++" inline __attribute__((__nothrow__)) __attribute__((__const__)) lldiv_t div(long long __numer, long long __denom) {
       return lldiv(__numer, __denom);
   }






typedef struct __sdiv32by16 { long quot, rem; } __sdiv32by16;
typedef struct __udiv32by16 { unsigned long quot, rem; } __udiv32by16;

typedef struct __sdiv64by32 { long rem, quot; } __sdiv64by32;

__attribute__((__value_in_regs__)) extern __attribute__((__nothrow__)) __attribute__((__const__)) __sdiv32by16 __rt_sdiv32by16(
     int ,
     short int );



__attribute__((__value_in_regs__)) extern __attribute__((__nothrow__)) __attribute__((__const__)) __udiv32by16 __rt_udiv32by16(
     unsigned int ,
     unsigned short );



__attribute__((__value_in_regs__)) extern __attribute__((__nothrow__)) __attribute__((__const__)) __sdiv64by32 __rt_sdiv64by32(
     int , unsigned int ,
     int );







extern __attribute__((__nothrow__)) unsigned int __fp_status(unsigned int , unsigned int );
# 705 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int mblen(const char * , size_t );
# 720 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int mbtowc(wchar_t * __restrict ,
                   const char * __restrict , size_t );
# 739 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) int wctomb(char * , wchar_t );
# 761 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict ,
                      const char * __restrict , size_t ) __attribute__((__nonnull__(2)));
# 779 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) size_t wcstombs(char * __restrict ,
                      const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(2)));
# 798 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
extern __attribute__((__nothrow__)) void __use_realtime_heap(void);
extern __attribute__((__nothrow__)) void __use_realtime_division(void);
extern __attribute__((__nothrow__)) void __use_two_region_memory(void);
extern __attribute__((__nothrow__)) void __use_no_heap(void);
extern __attribute__((__nothrow__)) void __use_no_heap_region(void);

extern __attribute__((__nothrow__)) char const *__C_library_version_string(void);
extern __attribute__((__nothrow__)) int __C_library_version_number(void);


         }
      }
# 820 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdlib.h" 3
        using ::std::atoll;
        using ::std::lldiv_t;

      using ::std::div_t;
      using ::std::ldiv_t;
      using ::std::atof;
      using ::std::atoi;
      using ::std::atol;
      using ::std::strtod;

      using ::std::strtof;
      using ::std::strtold;

      using ::std::strtol;
      using ::std::strtoul;
      using ::std::strtoll;
      using ::std::strtoull;
      using ::std::rand;
      using ::std::srand;
      using ::std::_rand_state;
      using ::std::_rand_r;
      using ::std::_srand_r;
      using ::std::_ANSI_rand_state;
      using ::std::_ANSI_rand_r;
      using ::std::_ANSI_srand_r;
      using ::std::calloc;
      using ::std::free;
      using ::std::malloc;
      using ::std::realloc;



      using ::std::__heapprt;
      using ::std::__heapstats;
      using ::std::__heapvalid;
      using ::std::abort;
      using ::std::atexit;
      using ::std::exit;
      using ::std::_Exit;
      using ::std::getenv;
      using ::std::system;
      using ::std::bsearch;
      using ::std::qsort;
      using ::std::abs;
      using ::std::div;
      using ::std::labs;
      using ::std::ldiv;

        using ::std::llabs;
        using ::std::lldiv;

      using ::std::__sdiv32by16;
      using ::std::__udiv32by16;
      using ::std::__sdiv64by32;
      using ::std::__rt_sdiv32by16;
      using ::std::__rt_udiv32by16;
      using ::std::__rt_sdiv64by32;
      using ::std::__fp_status;
      using ::std::mblen;
      using ::std::mbtowc;
      using ::std::wctomb;
      using ::std::mbstowcs;
      using ::std::wcstombs;
      using ::std::__use_realtime_heap;
      using ::std::__use_realtime_division;
      using ::std::__use_two_region_memory;
      using ::std::__use_no_heap;
      using ::std::__use_no_heap_region;
      using ::std::__C_library_version_string;
      using ::std::__C_library_version_number;
      using ::std::size_t;
      using ::std::__aeabi_MB_CUR_MAX;
# 95 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 2 3


extern "C++" {
# 119 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) long double
abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}
# 153 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 3
}
# 86 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdlib" 2 3
# 89 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdlib" 3








namespace std { inline namespace __2 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;

using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 161 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdlib" 3
} }
# 94 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 1 3
# 81 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 1 3
# 14 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 1 3
# 14 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iosfwd" 1 3
# 95 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iosfwd" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 1 3
# 109 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 1 3
# 110 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 2 3
# 113 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 3






# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 1 3
# 25 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
        namespace std {
        extern "C" {
# 36 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
        typedef unsigned int size_t;
# 59 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
      typedef int wint_t;
# 87 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
        typedef __builtin_va_list __va_list;
# 105 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
      struct __FILE;
# 134 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
      typedef struct __mbstate_t {
          unsigned int __state, __state2;
      } mbstate_t;







    struct tm;

    extern __attribute__((__nothrow__)) size_t wcsftime(wchar_t * __restrict , size_t ,
                       const wchar_t * __restrict , const struct tm * __restrict ) __attribute__((__nonnull__(1,3,4)));





#pragma __printf_args
 int swprintf(wchar_t * __restrict , size_t ,
                 const wchar_t * __restrict , ...) __attribute__((__nonnull__(3)));
#pragma __printf_args
 int vswprintf(wchar_t * __restrict , size_t ,
                  const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(3)));
#pragma __scanf_args
 int swscanf(const wchar_t * __restrict ,
                const wchar_t * __restrict , ...) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
 int vswscanf(const wchar_t * __restrict ,
                 const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));


#pragma __printf_args
 int fwprintf(struct __FILE * __restrict ,
                 const wchar_t * __restrict , ...) __attribute__((__nonnull__(1,2)));
#pragma __printf_args
 int vfwprintf(struct __FILE * __restrict ,
                  const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
 int fwscanf(struct __FILE * __restrict ,
                const wchar_t * __restrict , ...) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
 int vfwscanf(struct __FILE * __restrict ,
                 const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(1,2)));


#pragma __printf_args
 int wprintf(const wchar_t * __restrict , ...) __attribute__((__nonnull__(1)));
#pragma __printf_args
 int vwprintf(const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(1)));
#pragma __scanf_args
 int wscanf(const wchar_t * __restrict , ...) __attribute__((__nonnull__(1)));
#pragma __scanf_args
 int vwscanf(const wchar_t * __restrict , __va_list ) __attribute__((__nonnull__(1)));




    wint_t fgetwc(struct __FILE * ) __attribute__((__nonnull__(1)));
    wchar_t *fgetws(wchar_t * __restrict , int , struct __FILE * __restrict ) __attribute__((__nonnull__(1,3)));
    wint_t fputwc(wchar_t , struct __FILE * ) __attribute__((__nonnull__(2)));
    int fputws(const wchar_t * __restrict , struct __FILE * __restrict ) __attribute__((__nonnull__(1,2)));
    int fwide(struct __FILE * , int ) __attribute__((__nonnull__(1)));
    wint_t getwc(struct __FILE * ) __attribute__((__nonnull__(1)));
    wint_t getwchar(void);
    wint_t putwc(wchar_t , struct __FILE * ) __attribute__((__nonnull__(2)));
    wint_t putwchar(wchar_t );
    wint_t ungetwc(wint_t , struct __FILE * ) __attribute__((__nonnull__(2)));


    wint_t btowc(int );
    wint_t wctob(int );
    int mbsinit(const mbstate_t * );
    size_t mbrlen(const char * __restrict , size_t ,
                  mbstate_t * __restrict );
    size_t mbrtowc(wchar_t * __restrict ,
                   const char * __restrict ,
                   size_t , mbstate_t * __restrict );
    size_t wcrtomb(char * __restrict , wchar_t ,
                   mbstate_t * __restrict );
    size_t mbsrtowcs(wchar_t * __restrict ,
                     const char ** __restrict ,
                     size_t , mbstate_t * __restrict ) __attribute__((__nonnull__(2)));
    size_t wcsrtombs(char * __restrict ,
                     const wchar_t ** __restrict ,
                     size_t , mbstate_t * __restrict ) __attribute__((__nonnull__(2)));
    size_t _mbsnrtowcs(wchar_t * __restrict ,
                       const char ** __restrict ,
                       size_t ,
                       size_t , mbstate_t * __restrict ) __attribute__((__nonnull__(2)));
    size_t _wcsnrtombs(char * __restrict ,
                       const wchar_t ** __restrict ,
                       size_t ,
                       size_t , mbstate_t * __restrict ) __attribute__((__nonnull__(2)));
# 243 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
    __attribute__((__nothrow__)) double wcstod(const wchar_t * , wchar_t ** ) __attribute__((__nonnull__(1)));
    __attribute__((__nothrow__)) float wcstof(const wchar_t * , wchar_t ** ) __attribute__((__nonnull__(1)));
    __attribute__((__nothrow__)) long double wcstold(const wchar_t * , wchar_t ** ) __attribute__((__nonnull__(1)));
    long int wcstol(const wchar_t * , wchar_t ** ,
                    int ) __attribute__((__nonnull__(1)));
    unsigned long int wcstoul(const wchar_t * ,
                              wchar_t ** , int ) __attribute__((__nonnull__(1)));

    long long int wcstoll(const wchar_t * __restrict ,
                          wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));
    unsigned long long int wcstoull(const wchar_t * __restrict ,
                                    wchar_t ** __restrict ,
                                    int ) __attribute__((__nonnull__(1)));





    wchar_t *wcscpy(wchar_t * __restrict ,
                    const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcsncpy(wchar_t * __restrict ,
                     const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    wchar_t *wmemcpy(wchar_t * __restrict ,
                     const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    wchar_t *wmemmove(wchar_t * __restrict ,
                      const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcscat(wchar_t * __restrict ,
                    const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcsncat(wchar_t * __restrict ,
                     const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    int wcscmp(const wchar_t * __restrict ,
               const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    int wcsncmp(const wchar_t * __restrict ,
                const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    int wcscasecmp(const wchar_t * __restrict ,
                   const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    int wcsncasecmp(const wchar_t * __restrict ,
                    const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    int wcscoll(const wchar_t * __restrict ,
                const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    size_t wcsxfrm(wchar_t * __restrict ,
                   const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(2)));
    int wmemcmp(const wchar_t * __restrict ,
                const wchar_t * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
    size_t wcscspn(const wchar_t * __restrict ,
                   const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    size_t wcsspn(const wchar_t * __restrict ,
                  const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcstok(wchar_t * __restrict ,
                    const wchar_t * __restrict ,
                    wchar_t ** __restrict ) __attribute__((__nonnull__(2,3)));
    size_t wcslen(const wchar_t * __restrict ) __attribute__((__nonnull__(1)));
    wchar_t *wmemset(wchar_t * __restrict , wchar_t , size_t ) __attribute__((__nonnull__(1)));
# 343 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
  }
  }
  extern "C" {

    wchar_t *wcschr(const wchar_t * __restrict , wchar_t ) __attribute__((__nonnull__(1)));
    wchar_t *wcspbrk(const wchar_t * __restrict ,
                     const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcsrchr(const wchar_t * __restrict , wchar_t ) __attribute__((__nonnull__(1)));
    wchar_t *wcsstr(const wchar_t * __restrict ,
                    const wchar_t * __restrict ) __attribute__((__nonnull__(1,2)));
    wchar_t *wmemchr(const wchar_t * __restrict , wchar_t ,
                     ::std:: size_t ) __attribute__((__nonnull__(1)));

  }
  namespace std {
  extern "C" {




         }
      }
# 374 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wchar.h" 3
      using ::std::size_t;
      using ::std::wint_t;
      using ::std::mbstate_t;
      using ::std::tm;
      using ::std::wcsftime;

      using ::std::swprintf;
      using ::std::vswprintf;
      using ::std::swscanf;
      using ::std::vswscanf;
      using ::std::fwprintf;
      using ::std::vfwprintf;
      using ::std::fwscanf;
      using ::std::vfwscanf;
      using ::std::wprintf;
      using ::std::vwprintf;
      using ::std::wscanf;
      using ::std::vwscanf;
      using ::std::fgetwc;
      using ::std::fgetws;
      using ::std::fputwc;
      using ::std::fputws;
      using ::std::fwide;
      using ::std::getwc;
      using ::std::getwchar;
      using ::std::putwc;
      using ::std::putwchar;
      using ::std::ungetwc;
      using ::std::btowc;

      using ::std::wctob;
      using ::std::mbsinit;
      using ::std::mbrlen;
      using ::std::mbrtowc;
      using ::std::wcrtomb;
      using ::std::mbsrtowcs;
      using ::std::wcsrtombs;
      using ::std::_mbsnrtowcs;
      using ::std::_wcsnrtombs;




      using ::std::wcstod;
      using ::std::wcstof;
      using ::std::wcstold;
      using ::std::wcstol;
      using ::std::wcstoul;

      using ::std::wcstoll;
      using ::std::wcstoull;

      using ::std::wcscpy;
      using ::std::wcsncpy;
      using ::std::wmemcpy;
      using ::std::wmemmove;
      using ::std::wcscat;
      using ::std::wcsncat;
      using ::std::wcscmp;
      using ::std::wcsncmp;
      using ::std::wcscasecmp;
      using ::std::wcsncasecmp;
      using ::std::wcscoll;
      using ::std::wcsxfrm;
      using ::std::wmemcmp;







      using ::std::wcscspn;
      using ::std::wcsspn;
      using ::std::wcstok;
      using ::std::wcslen;
      using ::std::wmemset;
# 120 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 2 3
# 135 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
# 96 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iosfwd" 2 3
# 99 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iosfwd" 3


namespace std { inline namespace __2 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<> struct char_traits<char>;



template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(istringstream))) __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(ostringstream))) __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringstream))) __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(string))) __attribute__((__preferred_name__(wstring))) basic_string;


template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 2 3
# 18 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 3
# 47 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 3
namespace std { inline namespace __2 {

struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  __attribute__ ((__visibility__("default"))) string what() const;

  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);



extern __attribute__((__visibility__("default"))) __libcpp_debug_function_type __libcpp_debug_function;


[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);



__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 271 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__debug" 3
} }
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 1 3
# 425 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3


namespace std { inline namespace __2 {

template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr operator value_type() const noexcept {return value;}




};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
# 458 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
typedef integral_constant<bool,(true)> true_type;
typedef integral_constant<bool,(false)> false_type;

template <bool _Val>
using _BoolConstant __attribute__((nodebug)) = integral_constant<bool, _Val>;

template <bool> struct _MetaBase;
template <>
struct _MetaBase<true> {
  template <class _Tp, class _Up>
  using _SelectImpl __attribute__((nodebug)) = _Tp;
  template <template <class...> class _FirstFn, template <class...> class, class ..._Args>
  using _SelectApplyImpl __attribute__((nodebug)) = _FirstFn<_Args...>;
  template <class _First, class...>
  using _FirstImpl __attribute__((nodebug)) = _First;
  template <class, class _Second, class...>
  using _SecondImpl __attribute__((nodebug)) = _Second;
  template <class _Tp = void>
  using _EnableIfImpl __attribute__((nodebug)) = _Tp;
  template <class _Result, class _First, class ..._Rest>
  using _OrImpl __attribute__((nodebug)) = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::template _OrImpl<_First, _Rest...>;
  template <class _Result, class _First, class ..._Rest>
  using _AndImpl __attribute__((nodebug)) = typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::template _AndImpl<_First, _Rest...>;
};

template <>
struct _MetaBase<false> {
  template <class _Tp, class _Up>
  using _SelectImpl __attribute__((nodebug)) = _Up;
  template <template <class...> class, template <class...> class _SecondFn, class ..._Args>
  using _SelectApplyImpl __attribute__((nodebug)) = _SecondFn<_Args...>;
  template <class _Result, class ...>
  using _OrImpl __attribute__((nodebug)) = _Result;
  template <class _Result, class ...>
  using _AndImpl __attribute__((nodebug)) = _Result;
};
template <bool _Cond, class _Ret = void>
using _EnableIf __attribute__((nodebug)) = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((nodebug)) = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
template <class ..._Rest>
using _Or __attribute__((nodebug)) = typename _MetaBase< sizeof...(_Rest) != 0 >::template _OrImpl<false_type, _Rest...>;
template <class ..._Rest>
using _And __attribute__((nodebug)) = typename _MetaBase< sizeof...(_Rest) != 0 >::template _AndImpl<true_type, _Rest...>;
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
template <class ..._Args>
using _FirstType __attribute__((nodebug)) = typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
template <class ..._Args>
using _SecondType __attribute__((nodebug)) = typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;

template <template <class...> class _Func, class ..._Args>
struct _Lazy : _Func<_Args...> {};



template <template <class...> class _Templ, class ..._Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class ...>
false_type __sfinae_test_impl(...);

template <template <class ...> class _Templ, class ..._Args>
using _IsValidExpansion __attribute__((nodebug)) = decltype(__sfinae_test_impl<_Templ, _Args...>(0));

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};


template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};
# 552 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_same : _BoolConstant<__is_same(_Tp, _Up)> { };
# 573 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<

    __is_same(_Tp, _Up)



>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<

    !__is_same(_Tp, _Up)



>;


template <class _Tp>
using __test_for_primary_template = _EnableIf<
    _IsSame<_Tp, typename _Tp::__primary_template>::value
  >;
template <class _Tp>
using __is_primary_template = _IsValidExpansion<
    __test_for_primary_template, _Tp
  >;

struct __two {char __lx[2];};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_const : _BoolConstant<__is_const(_Tp)> { };
# 634 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_volatile : _BoolConstant<__is_volatile(_Tp)> { };
# 668 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};
# 689 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};
# 710 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
# 722 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_void : _BoolConstant<__is_void(_Tp)> { };
# 745 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 766 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_integral : _BoolConstant<__is_integral(_Tp)> { };
# 789 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
# 807 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_array : _BoolConstant<__is_array(_Tp)> { };
# 837 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_pointer : _BoolConstant<__is_pointer(_Tp)> { };
# 875 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_reference : _BoolConstant<__is_reference(_Tp)> { };
# 927 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 948 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 972 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public _BoolConstant<

    __is_function(_Tp)



    > {};
# 988 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __libcpp_is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : _BoolConstant<__is_member_function_pointer(_Tp)> { };
# 1032 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> { };
# 1057 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : _BoolConstant<__is_member_object_pointer(_Tp)> { };
# 1084 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 1117 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
# 1133 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_fundamental : _BoolConstant<__is_fundamental(_Tp)> { };
# 1161 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_scalar : _BoolConstant<__is_scalar(_Tp)> { };
# 1198 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_object : _BoolConstant<__is_object(_Tp)> { };
# 1227 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_compound : _BoolConstant<__is_compound(_Tp)> { };
# 1250 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const {
  typedef __attribute__((nodebug)) const _Tp type;
};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile {
  typedef __attribute__((nodebug)) volatile _Tp type;
};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv {
  typedef __attribute__((nodebug)) const volatile _Tp type;
};
# 1298 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef __attribute__((nodebug)) _Tp type;};
# 1310 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef __attribute__((nodebug)) _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef __attribute__((nodebug)) _Tp& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef __attribute__((nodebug)) typename __add_lvalue_reference_impl<_Tp>::type type;};





template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef __attribute__((nodebug)) _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef __attribute__((nodebug)) _Tp&& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef __attribute__((nodebug)) typename __add_rvalue_reference_impl<_Tp>::type type;};







#pragma GCC diagnostic push
# 1332 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
decltype(std::__2::__declval<_Tp>(0))
declval() noexcept;



template <class _Tp>
struct __uncvref {
    typedef __attribute__((nodebug)) typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef __attribute__((nodebug)) typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t __attribute__((nodebug)) = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};
# 1373 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef __attribute__((nodebug)) _Tp type;};







template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                _IsSame<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef __attribute__((nodebug)) _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef __attribute__((nodebug)) typename __add_pointer_impl<_Tp>::type type;};
# 1418 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_signed : _BoolConstant<__is_signed(_Tp)> { };
# 1453 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_unsigned : _BoolConstant<__is_unsigned(_Tp)> { };
# 1486 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 1503 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<class _Tp, size_t _Dim = 0>
struct __attribute__ ((__type_visibility__("default"))) extent
    : integral_constant<size_t, __array_extent(_Tp, _Dim)> { };
# 1535 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};
# 1581 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Up, bool>
struct __decay {
    typedef __attribute__((nodebug)) typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef __attribute__((nodebug)) typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type _Up;
public:
    typedef __attribute__((nodebug)) typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
# 1628 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
# 1658 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1675 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(
    static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )
)> : public true_type {};





template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
# 1795 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1832 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1858 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1892 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};
# 1903 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             __fallback_overaligned<_Align>
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};
# 2014 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};







template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};





template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,



    __nat



    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,



    __nat



    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef __attribute__((nodebug)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef __attribute__((nodebug)) typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef __attribute__((nodebug)) _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef __attribute__((nodebug)) const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};
# 2322 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};



template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
                          typename __void_t<decltype(
                                            true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
                                            )>::type>
{
  typedef __attribute__((nodebug)) typename decay<decltype(
                         true ? std::__2::declval<_Tp>() : std::__2::declval<_Up>()
                         )>::type type;
};

template <class, class = void>
struct __common_type_impl {};




template <class... Tp>
struct __common_types;
template <class... _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type;
# 2361 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp , _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp , _Rest...> > {
};



template <>
struct __attribute__ ((__type_visibility__("default"))) common_type<> {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<
        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        __common_type2_imp<_Tp, _Up>,
        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
    >::type
{};



template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __attribute__ ((__type_visibility__("default")))
    common_type<_Tp, _Up, _Vp , _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp , _Rest...> > {};
# 2416 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef __attribute__((nodebug)) _Tp type; };



template<class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> { };
# 2462 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2474 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};
# 2505 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__2::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__2::integral_constant<bool,
        __is_destructor_wellformed<typename std::__2::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__2::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__2::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__2::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__2::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__2::false_type {};

template <>
struct is_destructible<void>
    : public std::__2::false_type {};
# 2564 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "can not forward an rvalue as an lvalue");
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__2::forward<_Tp>(__t);
}

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};



template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};
# 2950 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
# 2968 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};
# 2984 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, bool = is_default_constructible<_Tp>::value>
struct __is_implicitly_default_constructible
    : false_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), true>
    : true_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), false>
    : false_type
{ };




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3018 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 3033 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3086 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};
# 3098 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};
# 3110 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 3124 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3162 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3174 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
# 3189 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 3221 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 3273 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};
# 3285 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3297 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 3311 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
# 3347 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3359 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
# 3374 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__2::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3437 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3458 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {};
# 3470 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};
# 3486 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};
# 3504 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};







template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};



template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 3594 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...)) { return (std::__2::forward<_A0>(__a0).*__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__2::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__2::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...))) -> decltype(((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...)) { return ((*std::__2::forward<_A0>(__a0)).*__f)(std::__2::forward<_Args>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__2::forward<_A0>(__a0).*__f)) -> decltype(std::__2::forward<_A0>(__a0).*__f) { return std::__2::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__2::forward<_A0>(__a0)).*__f)) -> decltype((*std::__2::forward<_A0>(__a0)).*__f) { return (*std::__2::forward<_A0>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...))) -> decltype(std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...)) { return std::__2::forward<_Fp>(__f)(std::__2::forward<_Args>(__args)...); }




template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
  template <class _XFp, class ..._XArgs>
  static auto __try_call(int) -> decltype(
    std::__2::__invoke(std::__2::declval<_XFp>(), std::__2::declval<_XArgs>()...));
  template <class _XFp, class ..._XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type =
  typename conditional<
      _IsNotSame<_Result, __nat>::value,
      typename conditional<
          is_void<_Ret>::value,
          true_type,
          is_convertible<_Result, _Ret>
      >::type,
      false_type
  >::type;
  static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__2::__invoke(std::__2::declval<_Fp>(), std::__2::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};





template <class _Callable> class result_of;



template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};
# 3926 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type




swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__2::move(__x));
    __x = std::__2::move(__y);
    __y = std::__2::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
{
    std::__2::swap_ranges(__a, __a + _Np, __b);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

               noexcept(noexcept(swap(*std::__2::declval<_ForwardIterator1>(), *std::__2::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}



namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__2::declval<_LHS>(), std::__2::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = _IsNotSame<__swap1, __nat>::value
                           && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__2::declval<_Tp>(), std::__2::declval<_Up>()))
  && noexcept(swap(std::__2::declval<_Up>(), std::__2::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
# 4100 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};





template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }

template<typename _Fp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) { return __val; }
# 4159 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__2::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__2::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
# 4239 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
# 4276 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\type_traits" 3
inline constexpr
bool __libcpp_is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }





template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

} }
# 16 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 2 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 2 3

namespace std { inline namespace __2 {




template <class _Tp>
inline
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 92 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
# 123 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/base.h" 3
} }
# 82 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 2 3
# 93 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3


namespace std
{


class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception(const exception&) noexcept = default;

    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};





typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void unexpected();


typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;

__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) int uncaught_exceptions() noexcept;

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);



class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception_ptr
make_exception_ptr(_Ep __e) noexcept
{
# 183 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3
    ((void)__e);
    std::__2::abort();

}
# 238 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3
class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;


    virtual ~nested_exception() noexcept;


    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};
# 287 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3
template <class _Tp>
[[noreturn]]
void
throw_with_nested(_Tp&& __t)
{
# 301 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\exception" 3
    ((void)__t);


}

template <class _From, class _To>
struct __can_dynamic_cast : public integral_constant<bool,(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__2::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

}
# 95 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 2 3
# 104 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
# 122 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
extern "C" __attribute__((__nothrow__)) int posix_memalign(void**, size_t, size_t);


namespace std
{


struct __attribute__ ((__visibility__("default"))) nothrow_t { explicit nothrow_t() = default; };
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;



[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc();




enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };
# 176 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
}
# 186 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;




                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;





                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;




                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;





                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator delete[](void*, void*) noexcept {}



namespace std { inline namespace __2 {

constexpr inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 8U;



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void* __libcpp_operator_new(_Args ...__args) {

  return __builtin_operator_new(__args...);



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __libcpp_operator_delete(_Args ...__args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void *__libcpp_allocate(size_t __size, size_t __align) {







  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args ...__args) {

  (void)__size;
  return __libcpp_operator_delete(__ptr, __args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {

    (void)__align;
    return __do_deallocate_handle_size(__ptr, __size);
# 294 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {

    (void)__align;
    return __libcpp_operator_delete(__ptr);
# 308 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
}
# 317 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void* __libcpp_aligned_alloc(std::size_t __alignment, std::size_t __size) {



  void* __result = nullptr;
  ::posix_memalign(&__result, __alignment, __size);

  return __result;

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __libcpp_aligned_free(void* __ptr) {



  ::free(__ptr);

}



template <class _Tp>
                              inline
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void" );

    return __builtin_launder(__p);



}
# 363 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\new" 3
} }
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h" 2




# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/schema/schema_generated.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/schema/schema_generated.h"
# 1 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h" 1
# 20 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
# 1 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 1
# 20 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\assert.h" 1 3
# 37 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\assert.h" 3
        namespace std {

            extern "C" {



    extern __attribute__((__nothrow__)) __attribute__((__noreturn__)) void abort(void);
    extern __attribute__((__nothrow__)) __attribute__((__noreturn__)) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));

            }
        }
# 21 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2







# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdint" 1 3
# 148 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cstdint" 3


namespace std { inline namespace __2 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 29 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2
# 38 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 1 3
# 200 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 1 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 3



namespace std { inline namespace __2 {

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
    typedef __attribute__((nodebug)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
    typedef __attribute__((nodebug)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
    typedef __attribute__((nodebug)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 140 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;





template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;




template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;






template <class ..._Tp> struct __tuple_types {};
# 280 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 3
template <size_t _Ip, class ..._Types>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __attribute__((nodebug)) __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t __attribute__((nodebug)) = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
# 343 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals __attribute__((nodebug)) = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((nodebug)) __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((nodebug)) __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};






template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size __attribute__((nodebug)) = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {

    static constexpr bool __enable_explicit_default() { return false; }
    static constexpr bool __enable_implicit_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};
# 549 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tuple" 3
} }
# 201 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\initializer_list" 1 3
# 50 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\initializer_list" 3


namespace std
{



template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

    size_t size() const noexcept {return __size_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 203 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 2 3
# 211 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3


namespace std { inline namespace __2 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}







template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) noexcept
{
    return std::__2::move(__x);
}






struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { explicit piecewise_construct_t() = default; };



                         constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 297 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 334 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
    template <bool _Val>
    using _EnableB __attribute__((nodebug)) = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <int&...>
      static constexpr bool __enable_explicit_default() {
          return is_default_constructible<_T1>::value
              && is_default_constructible<_T2>::value
              && !__enable_implicit_default<>();
      }

      template <int&...>
      static constexpr bool __enable_implicit_default() {
          return __is_implicitly_default_constructible<_T1>::value
              && __is_implicitly_default_constructible<_T2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep __attribute__((nodebug)) = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC __attribute__((nodebug)) = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_explicit_default()
    > = false>
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_implicit_default()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__2::forward<_U1>(__u1)), second(std::__2::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__2::forward<_U1>(__u1)), second(std::__2::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__2::forward<_U1>(__p.first)), second(std::__2::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__2::forward<_U1>(__p.first)), second(std::__2::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit pair(_Tuple&& __p)
        : first(std::__2::get<0>(std::__2::forward<_Tuple>(__p))),
          second(std::__2::get<1>(std::__2::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(_Tuple&& __p)
        : first(std::__2::get<0>(std::__2::forward<_Tuple>(__p))),
          second(std::__2::get<1>(std::__2::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))

        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__2::forward<first_type>(__p.first);
        second = std::__2::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair& operator=(_Tuple&& __p) {
        first = std::__2::get<0>(std::__2::forward<_Tuple>(__p));
        second = std::__2::get<1>(std::__2::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__2::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair(piecewise_construct_t,
         tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
         __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};






template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}

template <class _Tp>
struct __unwrap_reference { typedef __attribute__((nodebug)) _Tp type; };

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef __attribute__((nodebug)) _Tp& type; };
# 651 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _Tp>
struct __unwrap_ref_decay



    : __unwrap_reference<typename decay<_Tp>::type>

{ };



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::__2::forward<_T1>(__t1), std::__2::forward<_T2>(__t2));
}
# 683 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _T1, class _T2>
  struct __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
    typedef __attribute__((nodebug)) _T1 type;
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
    typedef __attribute__((nodebug)) _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__2::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__2::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__2::move(__p));
}
# 961 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::__2::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
        [[clang::fallthrough]];
    case 2:
        __h ^= __data[1] << 8;
        [[clang::fallthrough]];
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::__2::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __attribute__((pcs("aapcs")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __attribute__((pcs("aapcs")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};


template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};
# 1382 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};
# 1484 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};


template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0.0L)
            return 0;
# 1558 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};
# 1604 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _Key, class _Hash>
using __check_hash_requirements __attribute__((nodebug)) = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash __attribute__((nodebug)) = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;
# 1626 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\utility" 3
template <class _Type, class ...>
using __enable_hash_helper __attribute__((nodebug)) = _Type;




} }
# 39 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 1 3
# 512 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 1 3
# 179 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 1 3
# 57 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 1 3
# 653 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 1 3
# 670 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\typeinfo" 1 3
# 71 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\typeinfo" 3






namespace std
{
# 182 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return reinterpret_cast<size_t>(__v);
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs, __rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs, __rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

   private:


    typedef integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static bool __is_type_name_unique(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return !((__lhs & __rhs) & __non_unique_rtti_bit::value);
    }
  };

  typedef

    __unique_impl







     __impl;
};

class __attribute__ ((__visibility__("default"))) type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);

 protected:
    typedef __type_info_implementations::__impl __impl;

    __impl::__type_name_t __type_name;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:

    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const type_info& __arg) const noexcept
    {
      return __impl::__eq(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};


class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  bad_cast(const bad_cast&) noexcept = default;
  virtual ~bad_cast() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char* what() const noexcept;
};

}



namespace std { inline namespace __2 {
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_bad_cast()
{



    std::__2::abort();

}
} }
# 671 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3




# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits" 1 3
# 117 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 121 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits" 2 3



namespace std { inline namespace __2 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__2::is_signed<_Tp>::value;





    static constexpr const bool traps = false;

    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return 0.5L;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 676 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 1 3
# 419 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 1 3
# 22 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3


namespace std { inline namespace __2 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
# 73 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef __attribute__((nodebug)) typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};





template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(std::__2::__invoke(declval<_Tp>(), declval<_Args>()...)) type;
};
# 311 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return std::__2::__invoke(std::__2::forward<_Args>(__args)...);
    }
# 340 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        std::__2::__invoke(std::__2::forward<_Args>(__args)...);
    }
# 371 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference_wrapper(type& __f) noexcept
        : __f_(std::__2::addressof(__f)) {}

    private: reference_wrapper(type&&); public:



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    operator type&() const noexcept {return *__f_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    type& get() const noexcept {return *__f_;}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__2::__invoke(get(), std::__2::forward<_ArgTypes>(__args)...);
    }
# 512 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
};


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__2::ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__2::cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;
# 564 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { explicit allocator_arg_t() = default; };




                         constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 613 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__functional_base" 3
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef __attribute__((nodebug)) typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__2::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__2::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__2::forward<_Args>(__args)..., __a);
}



} }
# 420 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 2 3
# 430 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3


namespace std { inline namespace __2 {
template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits;

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};






template <class _Iter>
struct __iter_traits_cache {
  using type = _If<
    __is_primary_template<iterator_traits<_Iter> >::value,
    _Iter,
    iterator_traits<_Iter>
  >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = _EnableIf<
                          __is_primary_template<iterator_traits<_Iter> >::value,
                          random_access_iterator_tag
                        >;
};

template <class _Iter, class _Tester> struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or<
    __test_iter_concept<_Iter, __iter_concept_concept_test>,
    __test_iter_concept<_Iter, __iter_concept_category_test>,
    __test_iter_concept<_Iter, __iter_concept_random_fallback>
  >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;


template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename __void_t<typename _Up::iterator_category>::type* = 0,
                                            typename __void_t<typename _Up::difference_type>::type* = 0,
                                            typename __void_t<typename _Up::value_type>::type* = 0,
                                            typename __void_t<typename _Up::reference>::type* = 0,
                                            typename __void_t<typename _Up::pointer>::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};


template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = nullptr);
public:
    static const bool value = sizeof(__test<_Tp>(nullptr)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {

  using __primary_template = iterator_traits;
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;



};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};





template <class _Tp>
struct __is_cpp17_contiguous_iterator : public false_type {};



template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};
# 620 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void advance(_InputIter& __i, _Distance __orig_n)
{
    ((void)0);

    typedef decltype(std::__2::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    std::__2::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return std::__2::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __is_cpp17_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);


    std::__2::advance(__x, __n);
    return __x;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __is_cpp17_input_iterator<_InputIter>::value,
    _InputIter
>::type
prev(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);

    std::__2::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
                _Iter __t;

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator() : __t(), current() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer operator->() const {return std::__2::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 867 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}
# 884 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__2::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__2::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__2::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__2::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__2::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__2::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr istream_iterator() : __in_stream_(nullptr), __value_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(std::__2::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const _Tp* operator->() const {return std::__2::addressof((operator*()));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__2::addressof(__s)), __delim_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__2::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = nullptr;
        return __sbuf_ == nullptr;
    }
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr istreambuf_iterator() noexcept : __sbuf_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool failed() const noexcept {return __sbuf_ == nullptr;}

    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;

    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer operator->() const { return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 1323 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());







template <class _Iter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) move_backward(_B1, _B1, _B2);



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
# 1420 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter() noexcept



    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = nullptr) noexcept
            : __i(__u.base())
    {



    }
# 1474 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pointer operator->() const noexcept
    {




        return (pointer)std::__2::addressof(*__i);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;
    template <class _Tp, size_t> friend class __attribute__ ((__type_visibility__("default"))) span;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
                                 friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


    template <class _Iter1, class _Iter2>
                                 friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());







    template <class _Iter1>
                                 friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);


    template <class _Tp>
    constexpr friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
# 1626 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
{




    return __x.base() - __y.base();
}
# 1739 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool,(is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};


template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}
# 2020 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iterator" 3
} }
# 677 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 1 3
# 158 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3


namespace std { inline namespace __2 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {

      return !__reference_binds_to_temporary(_Hp, _Tp);



    }

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                      _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__2::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__2::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__2::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__2::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            __value_ = std::__2::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__2::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Hp& get() noexcept {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                    _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__2::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__2::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__2::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__2::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            _Hp::operator=(std::__2::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__2::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__2::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__2::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__2::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__2::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__2::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__2::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tuple_impl&
    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tuple_impl&
    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__2::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};



template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;




    static constexpr bool _EnableImplicitReducedArityExtension = false;


    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};

    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};

    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
        template <int&...>
        static constexpr bool __enable_implicit_default() {
           return __all<__is_implicitly_default_constructible<_Tp>::value... >::value;
        }

        template <int&...>
        static constexpr bool __enable_explicit_default() {
            return
                __all<is_default_constructible<_Tp>::value...>::value &&
                !__enable_implicit_default< >();
        }


        template <class ..._Args>
        static constexpr bool __enable_explicit() {
            return
                __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                !__tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_implicit() {
            return
               __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }
    };

    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_constructible<_Tuple, tuple>::value
                && __tuple_convertible<_Tuple, tuple>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, tuple>::value
               && !__tuple_convertible<_Tuple, tuple>::value;
        }
    };

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {



        template <class _Tuple>
        using _PreferTupleLikeConstructor = _Or<


            _IsSame<__uncvref_t<_Tuple>, tuple>,
            _Lazy<_And,
                _Not<is_constructible<_Tp..., _Tuple>>,
                _Not<is_convertible<_Tuple, _Tp...>>
            >
        >;

        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                __tuple_convertible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>
            >::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>,
                _Not<__tuple_convertible<_Tuple, tuple>>
            >::value;
        }
    };

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableImplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >;

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableExplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >;
    template <size_t _Jp, class ..._Up> friend
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:

    template <bool _Dummy = true, _EnableIf<
        _CheckArgsConstructor<_Dummy>::__enable_implicit_default()
    , void*> = nullptr>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <bool _Dummy = true, _EnableIf<
        _CheckArgsConstructor<_Dummy>::__enable_explicit_default()
    , void*> = nullptr>
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    tuple(tuple const&) = default;
    tuple(tuple&&) = default;

    template <class _AllocArgT, class _Alloc, _EnableIf<
             _CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::value >::__enable_implicit_default()
      , void*> = nullptr
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <class _AllocArgT, class _Alloc, _EnableIf<
             _CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::value>::__enable_explicit_default()
      , void*> = nullptr
    >
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      explicit
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp)
                             && !_PackIsTuple
                         >::template __enable_implicit<_Up...>() ||
                        _CheckArgsConstructor<
                            _EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackIsTuple
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 793 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__2::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) <= sizeof...(_Tp)
                             && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>() ||
                         _CheckArgsConstructor<
                            !_EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 826 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__2::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__2::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__2::forward<_Up>(__u)...) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__2::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}
    template <class _Tuple, _EnableExplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__2::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableExplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__2::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__2::forward<_Tuple>(__t)) {}

    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
        noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(__t.__base_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
        noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
        return *this;
    }

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple&
        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple>::value))
        {
            __base_.operator=(std::__2::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr tuple() noexcept = default;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(tuple&) noexcept {}
};
# 992 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3
template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}
# 1115 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3
template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
                     constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::__2::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__2::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__2::get<_Ip-1>(__x) == std::__2::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__2::get<__idx>(__x) < std::__2::get<__idx>(__y))
            return true;
        if (std::__2::get<__idx>(__y) < std::__2::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef __attribute__((nodebug)) tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef __attribute__((nodebug)) typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef __attribute__((nodebug)) tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return std::__2::forward_as_tuple(
            std::__2::forward<_Types>(std::__2::get<_I0>(__t))...,
            std::__2::get<_J0>(std::__2::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
        typedef __attribute__((nodebug)) typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
            tuple<_Types...,
                  typename __apply_cv<_Tuple0, typename tuple_element<
                                                   _J0, _T0>::type>::type&&...>,
            typename __make_tuple_indices<sizeof...(_Types) +
                                          tuple_size<_T0>::value>::type,
            typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
            std::__2::forward_as_tuple(
                std::__2::forward<_Types>(std::__2::get<_I0>(__t))...,
                std::__2::get<_J0>(std::__2::forward<_Tuple0>(__t0))...),
            std::__2::forward<_Tuple1>(__t1), std::__2::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__2::forward<_Tuple0>(__t0),
                                            std::__2::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__2::forward<_Args1>(std::__2::get<_I1>( __first_args))...),
      second(std::__2::forward<_Args2>(std::__2::get<_I2>(__second_args))...)
{
}
# 1451 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\tuple" 3
} }
# 680 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdexcept" 1 3
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdexcept" 3


namespace std { inline namespace __2 {


class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};


} }

namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{

private:
    std::__2::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{

private:
    std::__2::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}


    domain_error(const domain_error&) noexcept = default;
    virtual ~domain_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    invalid_argument(const invalid_argument&) noexcept = default;
    virtual ~invalid_argument() noexcept;

};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    length_error(const length_error&) noexcept = default;
    virtual ~length_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}


    out_of_range(const out_of_range&) noexcept = default;
    virtual ~out_of_range() noexcept;

};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}


    range_error(const range_error&) noexcept = default;
    virtual ~range_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    overflow_error(const overflow_error&) noexcept = default;
    virtual ~overflow_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    underflow_error(const underflow_error&) noexcept = default;
    virtual ~underflow_error() noexcept;

};

}

namespace std { inline namespace __2 {


[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_logic_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_domain_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_invalid_argument(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_length_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_out_of_range(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_range_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_overflow_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_underflow_error(const char*__msg)
{



    ((void)__msg);
    std::__2::abort();

}

} }
# 681 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 1 3
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/pointer_traits.h" 1 3
# 18 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/pointer_traits.h" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 22 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/pointer_traits.h" 2 3

namespace std { inline namespace __2 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef __attribute__((nodebug)) typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef __attribute__((nodebug)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef __attribute__((nodebug)) _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef __attribute__((nodebug)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef __attribute__((nodebug)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
#pragma GCC diagnostic push
# 78 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef __attribute__((nodebug)) typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef __attribute__((nodebug)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__2::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};

} }
# 16 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 2 3
# 20 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 24 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 2 3

namespace std { inline namespace __2 {






template <class _Tp, class = void> struct __has_pointer : false_type { }; template <class _Tp> struct __has_pointer<_Tp, typename __void_t<typename _Tp:: pointer >::type> : true_type { };
template <class _Tp, class _Alloc,
          class _RawAlloc = typename remove_reference<_Alloc>::type,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
    using type __attribute__((nodebug)) = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
    using type __attribute__((nodebug)) = _Tp*;
};


template <class _Tp, class = void> struct __has_const_pointer : false_type { }; template <class _Tp> struct __has_const_pointer<_Tp, typename __void_t<typename _Tp:: const_pointer >::type> : true_type { };
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
    using type __attribute__((nodebug)) = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {



    using type __attribute__((nodebug)) = typename pointer_traits<_Ptr>::template rebind<const _Tp>;

};


template <class _Tp, class = void> struct __has_void_pointer : false_type { }; template <class _Tp> struct __has_void_pointer<_Tp, typename __void_t<typename _Tp:: void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
    using type __attribute__((nodebug)) = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {



    using type __attribute__((nodebug)) = typename pointer_traits<_Ptr>::template rebind<void>;

};


template <class _Tp, class = void> struct __has_const_void_pointer : false_type { }; template <class _Tp> struct __has_const_void_pointer<_Tp, typename __void_t<typename _Tp:: const_void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
    using type __attribute__((nodebug)) = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {



    using type __attribute__((nodebug)) = typename pointer_traits<_Ptr>::template rebind<const void>;

};


template <class _Tp, class = void> struct __has_size_type : false_type { }; template <class _Tp> struct __has_size_type<_Tp, typename __void_t<typename _Tp:: size_type >::type> : true_type { };
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> { };
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
    using type __attribute__((nodebug)) = typename _Alloc::size_type;
};


template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type { }; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, typename __void_t<typename _Tp:: difference_type >::type> : true_type { };
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
    using type __attribute__((nodebug)) = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
    using type __attribute__((nodebug)) = typename _Alloc::difference_type;
};


template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_copy_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
    using type __attribute__((nodebug)) = typename _Alloc::propagate_on_container_copy_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_move_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
    using type __attribute__((nodebug)) = typename _Alloc::propagate_on_container_move_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { }; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, typename __void_t<typename _Tp:: propagate_on_container_swap >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type { };
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
    using type __attribute__((nodebug)) = typename _Alloc::propagate_on_container_swap;
};


template <class _Tp, class = void> struct __has_is_always_equal : false_type { }; template <class _Tp> struct __has_is_always_equal<_Tp, typename __void_t<typename _Tp:: is_always_equal >::type> : true_type { };
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> { };
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
    using type __attribute__((nodebug)) = typename _Alloc::is_always_equal;
};


#pragma GCC diagnostic push
# 149 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type { };
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, typename __void_t<
    typename _Tp::template rebind<_Up>::other
>::type> : true_type { };

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
    using type __attribute__((nodebug)) = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
    using type __attribute__((nodebug)) = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
    using type __attribute__((nodebug)) = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template<class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 174 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"


template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type { };

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, decltype(
    (void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>())
)> : true_type { };


template <class, class _Alloc, class ..._Args>
struct __has_construct_impl : false_type { };

template <class _Alloc, class ..._Args>
struct __has_construct_impl<decltype(
    (void)declval<_Alloc>().construct(declval<_Args>()...)
), _Alloc, _Args...> : true_type { };

template <class _Alloc, class ..._Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> { };


template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type { };

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype(
    (void)declval<_Alloc>().destroy(declval<_Pointer>())
)> : true_type { };


template <class _Alloc, class = void>
struct __has_max_size : false_type { };

template <class _Alloc>
struct __has_max_size<_Alloc, decltype(
    (void)declval<_Alloc&>().max_size()
)> : true_type { };


template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type { };

template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, decltype(
    (void)declval<_Alloc>().select_on_container_copy_construction()
)> : true_type { };

#pragma GCC diagnostic pop

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    using allocator_type = _Alloc;
    using value_type = typename allocator_type::value_type;
    using pointer = typename __pointer<value_type, allocator_type>::type;
    using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
    using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
    using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
    using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
    using size_type = typename __size_type<allocator_type, difference_type>::type;
    using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
    using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
    using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
    using is_always_equal = typename __is_always_equal<allocator_type>::type;


    template <class _Tp>
    using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
    template <class _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
# 258 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n) {
        return __a.allocate(__n);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 267 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
 }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer) {
        return __a.allocate(__n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
        __a.deallocate(__p, __n);
    }

    template <class _Tp, class... _Args, class =
        _EnableIf<__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 287 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 __a.construct(__p, std::__2::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
 }
    template <class _Tp, class... _Args, class = void, class =
        _EnableIf<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static void construct(allocator_type&, _Tp* __p, _Args&&... __args) {



        ::new ((void*)__p) _Tp(std::__2::forward<_Args>(__args)...);

    }

    template <class _Tp, class =
        _EnableIf<__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 306 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 __a.destroy(__p);
#pragma GCC diagnostic pop
 }
    template <class _Tp, class = void, class =
        _EnableIf<!__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static void destroy(allocator_type&, _Tp* __p) {



        __p->~_Tp();

    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
# 325 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 return __a.max_size();
#pragma GCC diagnostic pop
 }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static size_type max_size(const allocator_type&) noexcept {
        return numeric_limits<size_type>::max() / sizeof(value_type);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a.select_on_container_copy_construction();
    }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a;
    }
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper {

    using type __attribute__((nodebug)) = typename _Traits::template rebind_alloc<_Tp>;



};


template <class _Tp>
struct __is_default_allocator : false_type { };

template <class _Tp>
struct __is_default_allocator<std::__2::allocator<_Tp> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{ };

template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value
> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
        is_copy_constructible<typename _Alloc::value_type>::value &&
        __is_cpp17_move_insertable<_Alloc>::value
    >
{ };

template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value
> >
    : __is_cpp17_move_insertable<_Alloc>
{ };



} }
# 683 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/utilities.h" 1 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/utilities.h" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/utilities.h" 2 3


namespace std { inline namespace __2 {
# 46 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__memory/utilities.h" 3
template<class _Alloc>
struct __allocation_guard {
    using _Pointer = typename allocator_traits<_Alloc>::pointer;
    using _Size = typename allocator_traits<_Alloc>::size_type;

    template<class _AllocT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __allocation_guard(_AllocT __alloc, _Size __n)
        : __alloc_(std::__2::move(__alloc))
        , __n_(__n)
        , __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~__allocation_guard() noexcept {
        if (__ptr_ != nullptr) {
            allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Pointer __release_ptr() noexcept {
        _Pointer __tmp = __ptr_;
        __ptr_ = nullptr;
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Pointer __get() const noexcept {
        return __ptr_;
    }

private:
    _Alloc __alloc_;
    _Size __n_;
    _Pointer __ptr_;
};

} }
# 686 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3
# 693 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 697 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 2 3


namespace std { inline namespace __2 {

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {





    return *__value;

}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {





    return *__value;

}

template <bool _UsePointerTraits> struct __to_address_helper;

template <> struct __to_address_helper<true> {
    template <class _Pointer>
    using __return_type = decltype(pointer_traits<_Pointer>::to_address(std::__2::declval<const _Pointer&>()));

    template <class _Pointer>
    constexpr
    static __return_type<_Pointer>
    __do_it(const _Pointer &__p) noexcept { return pointer_traits<_Pointer>::to_address(__p); }
};

template <class _Pointer, bool _Dummy = true>
using __choose_to_address = __to_address_helper<_IsValidExpansion<__to_address_helper<_Dummy>::template __return_type, _Pointer>::value>;


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
_Tp*
__to_address(_Tp* __p) noexcept
{
    static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename __choose_to_address<_Pointer>::template __return_type<_Pointer>
__to_address(const _Pointer& __p) noexcept {
  return __choose_to_address<_Pointer>::__do_it(__p);
}

template <> struct __to_address_helper<false> {
    template <class _Pointer>
    using __return_type = typename pointer_traits<_Pointer>::element_type*;

    template <class _Pointer>
    constexpr
    static __return_type<_Pointer>
    __do_it(const _Pointer &__p) noexcept { return std::__2::__to_address(__p.operator->()); }
};
# 787 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template <class _Tp> class allocator;


template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};




template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator() noexcept { }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<_Tp*>(std::__2::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void deallocate(_Tp* __p, size_t __n) noexcept {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(__p);
        } else {
            std::__2::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
        }
    }



                                typedef _Tp* pointer;
                                typedef const _Tp* const_pointer;
                                typedef _Tp& reference;
                                typedef const _Tp& const_reference;

    template <class _Up>
    struct rebind {
        typedef allocator<_Up> other;
    };

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer address(reference __x) const noexcept {
        return std::__2::addressof(__x);
    }
                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer address(const_reference __x) const noexcept {
        return std::__2::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__2::forward<_Args>(__args)...);
    }

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator() noexcept { }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<const _Tp*>(std::__2::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void deallocate(const _Tp* __p, size_t __n) {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(const_cast<_Tp*>(__p));
        } else {
            std::__2::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));
        }
    }



                                typedef const _Tp* pointer;
                                typedef const _Tp* const_pointer;
                                typedef const _Tp& reference;
                                typedef const _Tp& const_reference;

    template <class _Up>
    struct rebind {
        typedef allocator<_Up> other;
    };

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer address(const_reference __x) const noexcept {
        return std::__2::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__2::forward<_Args>(__args)...);
    }

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_forward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2) {
        _Traits::construct(__a, std::__2::__to_address(__begin2),

            std::__2::move(*__begin1)



        );
    }
}

template <class _Alloc, class _Tp, typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_forward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__2::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Iter, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_range_forward(_Alloc& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2) {
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void) ++__begin2) {
        _Traits::construct(__a, std::__2::__to_address(__begin2), *__begin1);
    }
}

template <class _Alloc, class _Source, class _Dest,
          class _RawSource = typename remove_const<_Source>::type,
          class _RawDest = typename remove_const<_Dest>::type,
          class =
    typename enable_if<
        is_trivially_copy_constructible<_Dest>::value &&
        is_same<_RawSource, _RawDest>::value &&
        (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Dest*, _Source&>::value)
    >::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_range_forward(_Alloc&, _Source* __begin1, _Source* __end1, _Dest*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__2::memcpy(const_cast<_RawDest*>(__begin2), __begin1, _Np * sizeof(_Dest));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_backward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    while (__end1 != __begin1) {
        _Traits::construct(__a, std::__2::__to_address(__end2 - 1),

            std::__2::move(*--__end1)



        );
        --__end2;
    }
}

template <class _Alloc, class _Tp, class = typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __construct_backward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2) {
    ptrdiff_t _Np = __end1 - __begin1;
    __end2 -= _Np;
    if (_Np > 0)
        std::__2::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new ((void*)std::__2::addressof(*__x_)) _Tp(__element); return *this;}




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}



};

template <class _Tp>
                      __attribute__((__no_sanitize__("cfi")))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
# 1120 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    if (__is_overaligned_for_new(alignof(_Tp)))
        {


            return __r;
        }

        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));


        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__2::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}


template <class _Tp>
struct __attribute__ ((deprecated)) auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit auto_ptr(_Tp* __p = 0) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr(auto_ptr& __p) noexcept : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr(auto_ptr<_Up>& __p) noexcept
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr& __p) noexcept
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) noexcept
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) noexcept
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ~auto_ptr() noexcept {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp& operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp* operator->() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp* release() noexcept
    {
        _Tp* __t = __ptr_;
        __ptr_ = nullptr;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void reset(_Tp* __p = 0) noexcept
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) noexcept : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) operator auto_ptr_ref<_Up>() noexcept
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) operator auto_ptr<_Up>() noexcept
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr<void>
{
public:
    typedef void element_type;
};



struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__2::forward<_Up>(__u))
    {
    }



  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__2::forward<_Args>(std::__2::get<_Indexes>(__args))...) {}



  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference __get() noexcept { return __value_; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr __compressed_pair_elem() = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__2::forward<_Up>(__u))
  {}


  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__2::forward<_Args>(std::__2::get<_Indexes>(__args))...) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference __get() noexcept { return *this; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  const_reference __get() const noexcept { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
public:




  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

    typedef __attribute__((nodebug)) __compressed_pair_elem<_T1, 0> _Base1;
    typedef __attribute__((nodebug)) __compressed_pair_elem<_T2, 1> _Base2;

    template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::__2::forward<_U1>(__t1)), _Base2(std::__2::forward<_U2>(__t2)) {}


  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__2::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__2::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  static _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
  static _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::__2::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__((trivial_abi)) __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((nodebug)) typename __pointer<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };

  typedef __attribute__((nodebug)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((nodebug)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((nodebug)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((nodebug)) = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((nodebug)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p, __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__2::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__2::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__2::forward<_Ep>(__u.get_deleter())) {}


  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(auto_ptr<_Up>&& __p,
             typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                                    is_same<_Dp, default_delete<_Tp> >::value,
                                __nat>::type = __nat()) noexcept
      : __ptr_(__p.release(), __default_init_tag()) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__2::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__2::forward<_Ep>(__u.get_deleter());
    return *this;
  }


  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         unique_ptr&>::type
      operator=(auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }
# 1611 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class __attribute__((trivial_abi)) __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((nodebug)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((nodebug)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((nodebug)) = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((nodebug)) = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((nodebug)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((nodebug)) = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__2::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__2::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__2::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__2::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__2::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__2::forward<_Ep>(__u.get_deleter());
    return *this;
  }






public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}
# 2086 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template <class _Tp, class _Dp>



struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result_type operator()(const argument_type& __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __incr() noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef __attribute__((nodebug)) allocator_traits<_Alloc> __alloc_traits;
public:
    typedef __attribute__((nodebug)) typename __alloc_traits::pointer pointer;
    typedef __attribute__((nodebug)) typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f, (void) ++__r)
            ::new ((void*)std::__2::addressof(*__r)) value_type(*__f);
# 2183 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new ((void*)std::__2::addressof(*__r)) value_type(*__f);
# 2207 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f)
            ::new ((void*)std::__2::addressof(*__f)) value_type(__x);
# 2231 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, (void) --__n)
            ::new ((void*)std::__2::addressof(*__f)) value_type(__x);
# 2254 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    return __f;
}
# 2403 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{



    return __t += 1;

}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{



    return __t -= 1;

}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    bad_weak_ptr() noexcept = default;
    bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_bad_weak_ptr()
{



    std::__2::abort();

}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;

    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__2::move(__d)), std::__2::move(__a)) {}





private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};
# 2561 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template<class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
        : __storage_(std::__2::move(__a))
    {





        ::new ((void*)__get_elem()) _Tp(std::__2::forward<_Args>(__args)...);

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }

private:
    virtual void __on_zero_shared() noexcept {





        __get_elem()->~_Tp();

    }

    virtual void __on_zero_shared_weak() noexcept {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
            pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }
# 2634 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct alignas(_CompressedPair) _Storage {
        char __blob_[sizeof(_CompressedPair)];

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit _Storage(_Alloc&& __a) {
            ::new ((void*)__get_alloc()) _Alloc(std::__2::move(__a));
        }
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ~_Storage() {
            __get_alloc()->~_Alloc();
        }
        _Alloc* __get_alloc() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc*>(__first);
            return __alloc;
        }
        _Tp* __get_elem() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp*>(__second);
            return __elem;
        }
    };

    static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
    static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp, class _Up>
struct __compatible_with



    : is_convertible<_Tp*, _Up*> {};
# 2691 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template<class _Tp>
class __attribute__((trivial_abi)) __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:




    typedef _Tp element_type;


private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());

    template<class _Yp>
        shared_ptr(auto_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());

    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());

    ~shared_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(const shared_ptr<_Yp>& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(shared_ptr<_Yp>&& __r);

    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr
        >::type&
        operator=(auto_ptr<_Yp>&& __r);

    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(unique_ptr<_Yp, _Dp>&& __r);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    element_type* operator->() const noexcept
    {
        static_assert(!std::__2::is_array<_Tp>::value,
                      "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit operator bool() const noexcept {return get() != nullptr;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}
# 2885 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    template<class _Yp, class _CntrlBlk>
    static shared_ptr<_Tp>
    __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }

private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __enable_weak_this(...) noexcept {}

    template <class, class _Yp>
        struct __shared_ptr_default_delete
            : default_delete<_Yp> {};

    template <class _Yp, class _Un, size_t _Sz>
        struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
            : default_delete<_Yp[]> {};

    template <class _Yp, class _Un>
        struct __shared_ptr_default_delete<_Yp[], _Un>
            : default_delete<_Yp[]> {};

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};
# 2951 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        __enable_weak_this(__p, __p);
# 3005 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(nullptr)
{




        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
# 3027 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__2::addressof(*__hold2.get())) _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__2::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);
# 3055 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(nullptr)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__2::addressof(*__hold2.get())) _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__2::addressof(*__hold2.release());
# 3081 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}


template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
    __r.release();
}


template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{





    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{





    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), std::__2::ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>
>::type&
shared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)
{
    shared_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__2::swap(__ptr_, __r.__ptr_);
    std::__2::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}




template<class _Tp, class _Alloc, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void*)std::__2::addressof(*__guard.__get())) _ControlBlock(__a, std::__2::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::__2::addressof(*__control_block));
}

template<class _Tp, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
shared_ptr<_Tp> make_shared(_Args&& ...__args)
{
    return std::__2::allocate_shared<_Tp>(allocator<_Tp>(), std::__2::forward<_Args>(__args)...);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{

    typedef typename common_type<_Tp*, _Up*>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());




}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET* __p = dynamic_cast<_ET*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}
# 3579 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template<class _Tp>
class __attribute__((trivial_abi)) __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;
    ~weak_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(weak_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(weak_ptr<_Yp>&& __r) noexcept;

    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void reset() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool expired() const noexcept
        {return __cntrl_ == nullptr || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};






template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__2::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__2::swap(__ptr_, __r.__ptr_);
    std::__2::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == nullptr)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}




template <class _Tp> struct owner_less;


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};
# 3912 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}
# 3944 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 4111 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
enum class pointer_safety : unsigned char {
  relaxed,
  preferred,
  strict
};
# 4145 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\memory" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}




__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);


template <typename _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)



    noexcept(__is_nothrow_swappable<_Alloc>::value)

{
    using std::__2::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)



    noexcept(__is_nothrow_swappable<_Alloc>::value)

{
    std::__2::__swap_allocator(__a1, __a2,
      integral_constant<bool, std::__2::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value



        && is_nothrow_move_assignable<_Alloc>::value

    > {};


template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __attribute__((__no_sanitize__("cfi")))
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),
                         std::__2::forward<_Args>(__args)...);
    }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };

template<typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template<typename _Alloc>
struct __is_allocator<_Alloc,
       typename __void_t<typename _Alloc::value_type>::type,
       typename __void_t<decltype(std::__2::declval<_Alloc&>().allocate(size_t(0)))>::type
     >
   : true_type {};





struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

    constexpr explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void* p) const noexcept {
        std::__2::__libcpp_deallocate(p, __size_, __align_);
    }

   private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
      return __holder_t(std::__2::__libcpp_allocate(__s, __align),
                     __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void* __p, size_t __s,
                                 size_t __align) noexcept {
      std::__2::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static __holder_t __allocate_type(size_t __n) {
      return __allocate_bytes(__n * sizeof(_Tp), alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static void __deallocate_type(void* __p, size_t __n) noexcept {
      __deallocate_bytes(__p, __n * sizeof(_Tp), alignof(_Tp));
  }
};


} }
# 654 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 1 3
# 517 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3


namespace std { inline namespace __2 {




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
# 551 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
# 578 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
# 605 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
# 632 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
# 659 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
# 686 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
# 713 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
# 740 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
# 769 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
# 796 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
# 823 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
# 850 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
# 877 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
# 904 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
# 931 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
# 958 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
# 1004 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
                            inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
                            inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}


template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun_t
    : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun1_t
    : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun_ref_t
    : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun_t
    : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun1_t
    : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun_ref_t
    : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
__attribute__ ((deprecated)) inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}






template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __mem_fn(type __f) noexcept : __f_(__f) {}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__2::__invoke(__f_, std::__2::forward<_ArgTypes>(__args)...);
    }
# 1405 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}







class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{

public:
    virtual ~bad_function_call() noexcept;

    virtual const char* what() const noexcept;

};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_bad_function_call()
{



    std::__2::abort();

}
# 1449 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Rp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool __not_null(_Fp const&) { return true; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool __not_null(_Fp* __ptr) { return __ptr; }

template <class _Ret, class _Class>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool __not_null(_Ret _Class::*__ptr) { return __ptr; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool __not_null(function<_Fp> const& __f) { return !!__f; }







}



namespace __function {



template <class _Fp, class _Ap, class _FB> class __alloc_func;
template <class _Fp, class _FB>
class __default_alloc_func;

template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Ap> __f_;

  public:
    typedef __attribute__((nodebug)) _Fp _Target;
    typedef __attribute__((nodebug)) _Ap _Alloc;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Target& __target() const { return __f_.first(); }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Alloc& __get_allocator() const { return __f_.second(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __alloc_func(_Target&& __f)
        : __f_(piecewise_construct, std::__2::forward_as_tuple(std::__2::move(__f)),
               std::__2::forward_as_tuple())
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __alloc_func(const _Target& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__2::forward_as_tuple(__f),
               std::__2::forward_as_tuple(__a))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __alloc_func(const _Target& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__2::forward_as_tuple(__f),
               std::__2::forward_as_tuple(std::__2::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __alloc_func(_Target&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__2::forward_as_tuple(std::__2::move(__f)),
               std::__2::forward_as_tuple(std::__2::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Rp operator()(_ArgTypes&&... __arg)
    {
        typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        return _Invoker::__call(__f_.first(),
                                std::__2::forward<_ArgTypes>(__arg)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __alloc_func* __clone() const
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef
            typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
                _AA;
        _AA __a(__f_.second());
        typedef __allocator_destructor<_AA> _Dp;
        unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        ::new ((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));
        return __hold.release();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void destroy() noexcept { __f_.~__compressed_pair<_Target, _Alloc>(); }

    static void __destroy_and_delete(__alloc_func* __f) {
      typedef allocator_traits<_Alloc> __alloc_traits;
      typedef typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
          _FunAlloc;
      _FunAlloc __a(__f->__get_allocator());
      __f->destroy();
      __a.deallocate(__f, 1);
    }
};

template <class _Fp, class _Rp, class... _ArgTypes>
class __default_alloc_func<_Fp, _Rp(_ArgTypes...)> {
  _Fp __f_;

public:
  typedef __attribute__((nodebug)) _Fp _Target;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  const _Target& __target() const { return __f_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit __default_alloc_func(_Target&& __f) : __f_(std::__2::move(__f)) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  explicit __default_alloc_func(const _Target& __f) : __f_(__f) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  _Rp operator()(_ArgTypes&&... __arg) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_, std::__2::forward<_ArgTypes>(__arg)...);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  __default_alloc_func* __clone() const {
      __builtin_new_allocator::__holder_t __hold =
        __builtin_new_allocator::__allocate_type<__default_alloc_func>(1);
    __default_alloc_func* __res =
        ::new ((void*)__hold.get()) __default_alloc_func(__f_);
    (void)__hold.release();
    return __res;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void destroy() noexcept { __f_.~_Target(); }

  static void __destroy_and_delete(__default_alloc_func* __f) {
    __f->destroy();
      __builtin_new_allocator::__deallocate_type<__default_alloc_func>(__f, 1);
  }
};



template<class _Fp> class __attribute__ ((__type_visibility__("default"))) __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __base() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;




};



template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __func(_Fp&& __f)
        : __f_(std::__2::move(__f)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(__f, __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(__f, std::__2::move(__a)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(std::__2::move(__f), std::__2::move(__a)) {}

    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&&... __arg);




};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new ((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new ((void*)__p) __func(__f_.__target(), __f_.__get_allocator());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
{
    __f_.destroy();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    __f_.destroy();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __f_(std::__2::forward<_ArgTypes>(__arg)...);
}
# 1757 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Fp> class __value_func;

template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>
{
    typename aligned_storage<3 * sizeof(void*)>::type __buf_;

    typedef __base<_Rp(_ArgTypes...)> __func;
    __func* __f_;

    __attribute__((__no_sanitize__("cfi"))) static __func* __as_base(void* p)
    {
        return reinterpret_cast<__func*>(p);
    }

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_func() noexcept : __f_(nullptr) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __value_func(_Fp&& __f, const _Alloc& __a)
        : __f_(nullptr)
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            _FunAlloc __af(__a);
            if (sizeof(_Fun) <= sizeof(__buf_) &&
                is_nothrow_copy_constructible<_Fp>::value &&
                is_nothrow_copy_constructible<_FunAlloc>::value)
            {
                __f_ =
                    ::new ((void*)&__buf_) _Fun(std::__2::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get()) _Fun(std::__2::move(__f), _Alloc(__a));
                __f_ = __hold.release();
            }
        }
    }

    template <class _Fp,
        class = typename enable_if<!is_same<typename decay<_Fp>::type, __value_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit __value_func(_Fp&& __f)
        : __value_func(std::__2::forward<_Fp>(__f), allocator<_Fp>()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_func(const __value_func& __f)
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
            __f_ = __f.__f_->__clone();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_func(__value_func&& __f) noexcept
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~__value_func()
    {
        if ((void*)__f_ == &__buf_)
            __f_->destroy();
        else if (__f_)
            __f_->destroy_deallocate();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_func& operator=(__value_func&& __f)
    {
        *this = nullptr;
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_func& operator=(nullptr_t)
    {
        __func* __f = __f_;
        __f_ = nullptr;
        if ((void*)__f == &__buf_)
            __f->destroy();
        else if (__f)
            __f->destroy_deallocate();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        if (__f_ == nullptr)
            __throw_bad_function_call();
        return (*__f_)(std::__2::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(__value_func& __f) noexcept
    {
        if (&__f == this)
            return;
        if ((void*)__f_ == &__buf_ && (void*)__f.__f_ == &__f.__buf_)
        {
            typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
            __func* __t = __as_base(&__tempbuf);
            __f_->__clone(__t);
            __f_->destroy();
            __f_ = nullptr;
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = nullptr;
            __f_ = __as_base(&__buf_);
            __t->__clone(__as_base(&__f.__buf_));
            __t->destroy();
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f_ == &__buf_)
        {
            __f_->__clone(__as_base(&__f.__buf_));
            __f_->destroy();
            __f_ = __f.__f_;
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = __f_;
            __f_ = __as_base(&__buf_);
        }
        else
            std::__2::swap(__f_, __f.__f_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit operator bool() const noexcept { return __f_ != nullptr; }
# 1946 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
};



union __policy_storage
{
    mutable char __small[sizeof(void*) * 2];
    void* __large;
};


template <typename _Fun>
struct __use_small_storage
    : public std::__2::integral_constant<
          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
                    alignof(_Fun) <= alignof(__policy_storage) &&
                    std::__2::is_trivially_copy_constructible<_Fun>::value &&
                    std::__2::is_trivially_destructible<_Fun>::value> {};



struct __policy
{

    void* (*const __clone)(const void*);
    void (*const __destroy)(void*);


    const bool __is_null;


    const std::type_info* const __type_info;



    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static const __policy* __create()
    {
        return __choose_policy<_Fun>(__use_small_storage<_Fun>());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static const __policy* __create_empty()
    {
        static const constexpr __policy __policy_ = {nullptr, nullptr,
                                                             true,



                                                             nullptr

        };
        return &__policy_;
    }

  private:
    template <typename _Fun> static void* __large_clone(const void* __s)
    {
        const _Fun* __f = static_cast<const _Fun*>(__s);
        return __f->__clone();
    }

    template <typename _Fun>
    static void __large_destroy(void* __s) {
      _Fun::__destroy_and_delete(static_cast<_Fun*>(__s));
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static const __policy*
    __choose_policy( false_type) {
      static const constexpr __policy __policy_ = {
          &__large_clone<_Fun>, &__large_destroy<_Fun>, false,



          nullptr

      };
        return &__policy_;
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static const __policy*
        __choose_policy( true_type)
    {
        static const constexpr __policy __policy_ = {
            nullptr, nullptr, false,



            nullptr

        };
        return &__policy_;
    }
};



template <typename _Tp>
using __fast_forward =
    typename std::__2::conditional<std::__2::is_scalar<_Tp>::value, _Tp, _Tp&&>::type;



template <class _Fp> struct __policy_invoker;

template <class _Rp, class... _ArgTypes>
struct __policy_invoker<_Rp(_ArgTypes...)>
{
    typedef _Rp (*__Call)(const __policy_storage*,
                          __fast_forward<_ArgTypes>...);

    __Call __call_;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_invoker() : __call_(&__call_empty) {}


    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static __policy_invoker __create()
    {
        return __policy_invoker(&__call_impl<_Fun>);
    }

  private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __policy_invoker(__Call __c) : __call_(__c) {}

    static _Rp __call_empty(const __policy_storage*,
                            __fast_forward<_ArgTypes>...)
    {
        __throw_bad_function_call();
    }

    template <typename _Fun>
    static _Rp __call_impl(const __policy_storage* __buf,
                           __fast_forward<_ArgTypes>... __args)
    {
        _Fun* __f = reinterpret_cast<_Fun*>(__use_small_storage<_Fun>::value
                                                ? &__buf->__small
                                                : __buf->__large);
        return (*__f)(std::__2::forward<_ArgTypes>(__args)...);
    }
};




template <class _Fp> class __policy_func;

template <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>
{

    __policy_storage __buf_;




    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
    __invoker __invoker_;



    const __policy* __policy_;

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_func() : __policy_(__policy::__create_empty()) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __policy_func(_Fp&& __f, const _Alloc& __a)
        : __policy_(__policy::__create_empty())
    {
        typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            __invoker_ = __invoker::template __create<_Fun>();
            __policy_ = __policy::__create<_Fun>();

            _FunAlloc __af(__a);
            if (__use_small_storage<_Fun>())
            {
                ::new ((void*)&__buf_.__small)
                    _Fun(std::__2::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get())
                    _Fun(std::__2::move(__f), _Alloc(__af));
                __buf_.__large = __hold.release();
            }
        }
    }

    template <class _Fp, class = typename enable_if<!is_same<typename decay<_Fp>::type, __policy_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit __policy_func(_Fp&& __f)
        : __policy_(__policy::__create_empty()) {
      typedef __default_alloc_func<_Fp, _Rp(_ArgTypes...)> _Fun;

      if (__function::__not_null(__f)) {
        __invoker_ = __invoker::template __create<_Fun>();
        __policy_ = __policy::__create<_Fun>();
        if (__use_small_storage<_Fun>()) {
          ::new ((void*)&__buf_.__small) _Fun(std::__2::move(__f));
        } else {
          __builtin_new_allocator::__holder_t __hold =
              __builtin_new_allocator::__allocate_type<_Fun>(1);
          __buf_.__large = ::new ((void*)__hold.get()) _Fun(std::__2::move(__f));
          (void)__hold.release();
        }
      }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_func(const __policy_func& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__clone)
            __buf_.__large = __policy_->__clone(__f.__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_func(__policy_func&& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__destroy)
        {
            __f.__policy_ = __policy::__create_empty();
            __f.__invoker_ = __invoker();
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~__policy_func()
    {
        if (__policy_->__destroy)
            __policy_->__destroy(__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_func& operator=(__policy_func&& __f)
    {
        *this = nullptr;
        __buf_ = __f.__buf_;
        __invoker_ = __f.__invoker_;
        __policy_ = __f.__policy_;
        __f.__policy_ = __policy::__create_empty();
        __f.__invoker_ = __invoker();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __policy_func& operator=(nullptr_t)
    {
        const __policy* __p = __policy_;
        __policy_ = __policy::__create_empty();
        __invoker_ = __invoker();
        if (__p->__destroy)
            __p->__destroy(__buf_.__large);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        return __invoker_.__call_(std::__2::addressof(__buf_),
                                  std::__2::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(__policy_func& __f)
    {
        std::__2::swap(__invoker_, __f.__invoker_);
        std::__2::swap(__policy_, __f.__policy_);
        std::__2::swap(__buf_, __f.__buf_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit operator bool() const noexcept
    {
        return !__policy_->__is_null;
    }
# 2257 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
};
# 2328 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
}

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{



    typedef __function::__policy_func<_Rp(_ArgTypes...)> __func;


    __func __f_;

    template <class _Fp, bool = _And<
        _IsNotSame<__uncvref_t<_Fp>, function>,
        __invokable<_Fp, _ArgTypes...>
    >::value>
    struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_void<_Rp>::value ||
                __is_core_convertible<typename __invoke_of<_Fp, _ArgTypes...>::type,
                                      _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };

  template <class _Fp>
  using _EnableIfLValueCallable = typename enable_if<__callable<_Fp&>::value>::type;
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    function() noexcept { }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    function(nullptr_t) noexcept {}
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<_Fp>>
    function(_Fp);


    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      function(allocator_arg_t, const _Alloc&) noexcept {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, function&&);
    template<class _Fp, class _Alloc, class = _EnableIfLValueCallable<_Fp>>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f);


    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<typename decay<_Fp>::type>>
    function& operator=(_Fp&&);

    ~function();


    void swap(function&) noexcept;


    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      void assign(_Fp&& __f, const _Alloc& __a)
        {function(allocator_arg, __a, std::__2::forward<_Fp>(__f)).swap(*this);}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit operator bool() const noexcept {
      return static_cast<bool>(__f_);
    }


    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:

    _Rp operator()(_ArgTypes...) const;







};
# 2479 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}


template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     const function& __f) : __f_(__f.__f_) {}


template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
    : __f_(std::__2::move(__f.__f_)) {}


template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                      function&& __f)
    : __f_(std::__2::move(__f.__f_)) {}


template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(std::__2::move(__f)) {}


template <class _Rp, class... _ArgTypes>
template <class _Fp, class _Alloc, class>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a,
                                      _Fp __f)
    : __f_(std::__2::move(__f), __a) {}


template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
{
    __f_ = std::__2::move(__f.__f_);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
{
    __f_ = nullptr;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__2::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
{
    __f_.swap(__f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    return __f_(std::__2::forward<_ArgTypes>(__arg)...);
}
# 2590 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
{return __x.swap(__y);}
# 2626 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};






template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};






namespace placeholders
{

template <int _Np> struct __ph {};
# 2661 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
                         constexpr __ph<1> _1{};
                         constexpr __ph<2> _2{};
                         constexpr __ph<3> _3{};
                         constexpr __ph<4> _4{};
                         constexpr __ph<5> _5{};
                         constexpr __ph<6> _6{};
                         constexpr __ph<7> _7{};
                         constexpr __ph<8> _8{};
                         constexpr __ph<9> _9{};
                         constexpr __ph<10> _10{};


}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};




template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__2::forward<_Uj>(std::__2::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename _EnableIf
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return std::__2::__mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__2::forward<typename tuple_element<_Indx, _Uj>::type>(std::__2::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;

template <bool _Invokable, class _Ti, class ..._Uj>
struct __mu_return_invokable
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti,
                              __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                              _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return std::__2::__invoke(__f, std::__2::__mu(std::__2::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__2::forward<_Gp>(__f)),
          __bound_args_(std::__2::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return std::__2::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__2::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return std::__2::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__2::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__2::forward<_Gp>(__f),
               std::__2::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), std::__2::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), std::__2::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__2::forward<_Fp>(__f), std::__2::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__2::forward<_Fp>(__f), std::__2::forward<_BoundArgs>(__bound_args)...);
}
# 3050 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1>
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return std::__2::make_pair(__first1, __first1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return std::__2::make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return std::__2::make_pair(__first1, __m1);
            if (++__m1 == __last1)
                return std::__2::make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>

pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    const _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return std::__2::make_pair(__first1, __first1);
    const _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return std::__2::make_pair(__last1, __last1);
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);

    while (true)
    {
        while (true)
        {
            if (__first1 == __s)
                return std::__2::make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return std::__2::make_pair(__first1, __first1 + __len2);
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}
# 3169 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\functional" 3
template <class _Container, class _Predicate>
inline typename _Container::size_type
__libcpp_erase_if_container(_Container& __c, _Predicate __pred) {
  typename _Container::size_type __old_size = __c.size();

  const typename _Container::iterator __last = __c.end();
  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }

  return __old_size - __c.size();
}

} }
# 655 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 2 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 1 3
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bits" 1 3
# 17 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bits" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 21 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bits" 2 3


namespace std { inline namespace __2 {



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_ctz(unsigned __x) noexcept { return __builtin_ctz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_ctz(unsigned long __x) noexcept { return __builtin_ctzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_ctz(unsigned long long __x) noexcept { return __builtin_ctzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_clz(unsigned __x) noexcept { return __builtin_clz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_clz(unsigned long __x) noexcept { return __builtin_clzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_clz(unsigned long long __x) noexcept { return __builtin_clzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_popcount(unsigned __x) noexcept { return __builtin_popcount(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_popcount(unsigned long __x) noexcept { return __builtin_popcountl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
int __libcpp_popcount(unsigned long long __x) noexcept { return __builtin_popcountll(__x); }
# 142 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bits" 3
} }
# 59 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 2 3
# 73 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 77 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 2 3

namespace std { inline namespace __2 {


template <class _Tp>
using __bitop_unsigned_integer __attribute__((nodebug)) = integral_constant<bool,
         is_integral<_Tp>::value &&
         is_unsigned<_Tp>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, bool>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, signed char>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, wchar_t>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, char16_t>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, char32_t>::value
    >;


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp __rotl(_Tp __t, unsigned int __cnt) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotl requires unsigned");
    const unsigned int __dig = numeric_limits<_Tp>::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp __rotr(_Tp __t, unsigned int __cnt) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotr requires unsigned");
    const unsigned int __dig = numeric_limits<_Tp>::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}



template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __countr_zero(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_zero requires unsigned");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;

    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_ctz(static_cast<unsigned int>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_ctz(static_cast<unsigned long>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_ctz(static_cast<unsigned long long>(__t));
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while ((__iter = __libcpp_ctz(static_cast<unsigned long long>(__t))) == __ulldigits)
        {
            __ret += __iter;
            __t >>= __ulldigits;
        }
        return __ret + __iter;
    }
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __countl_zero(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_zero requires unsigned");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;

    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_clz(static_cast<unsigned int>(__t))
              - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_clz(static_cast<unsigned long>(__t))
              - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_clz(static_cast<unsigned long long>(__t))
              - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while (true) {
            __t = __rotr(__t, __ulldigits);
            if ((__iter = __countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                break;
            __ret += __iter;
            }
        return __ret + __iter;
    }
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __countl_one(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_one requires unsigned");
    return __t != numeric_limits<_Tp>::max()
        ? __countl_zero(static_cast<_Tp>(~__t))
        : numeric_limits<_Tp>::digits;
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __countr_one(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_one requires unsigned");
    return __t != numeric_limits<_Tp>::max()
        ? __countr_zero(static_cast<_Tp>(~__t))
        : numeric_limits<_Tp>::digits;
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int
__popcount(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__libcpp_popcount requires unsigned");
    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_popcount(static_cast<unsigned int>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_popcount(static_cast<unsigned long>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_popcount(static_cast<unsigned long long>(__t));
    else
    {
        int __ret = 0;
        while (__t != 0)
        {
            __ret += __libcpp_popcount(static_cast<unsigned long long>(__t));
            __t >>= numeric_limits<unsigned long long>::digits;
        }
        return __ret;
    }
}



template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
unsigned __bit_log2(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__bit_log2 requires unsigned");
    return numeric_limits<_Tp>::digits - 1 - __countl_zero(__t);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
bool __has_single_bit(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__has_single_bit requires unsigned");
    return __t != 0 && (((__t & (__t - 1)) == 0));
}
# 367 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bit" 3
} }
# 658 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 2 3
# 664 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 668 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 2 3


namespace std { inline namespace __2 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __invert() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __invert(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};



template <typename _Integral>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    is_integral<_Integral>::value,
    _Integral
>::type
__half_positive(_Integral __value)
{
    return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
}

template <typename _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    !is_integral<_Tp>::value,
    _Tp
>::type
__half_positive(_Tp __value)
{
    return __value / 2;
}
# 835 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _Comp>
struct __comp_ref_type {



  typedef typename add_lvalue_reference<_Comp>::type type;



};



template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return __f;
}
# 922 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _InputIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
                              _ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
                              _BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__2::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__2::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                              _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__2::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__2::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__2::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__2::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1265 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__2::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1346 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                                                    bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    if (__first1 == __last1)
        return true;


    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__2::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__2::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        _ForwardIterator1 __match = __first1;
        for (; __match != __i; ++__match)
            if (__pred(*__match, *__i))
                break;
        if (__match == __i) {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__2::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__2::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1506 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__2::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category())
            .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__2::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}
# 1542 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
                              _ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
                              _RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__2::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, std::__2::__convert_to_integral(__count), __value_, __pred,
           typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__2::search_n(__first, __last, std::__2::__convert_to_integral(__count),
                           __value_, __equal_to<__v, _Tp>());
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    const _Tp*
>::type
__unwrap_iter(__wrap_iter<const _Tp*> __i)
{
    return __i.base();
}
# 1705 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__copy_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__2::__copy_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__2::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__2::__copy_constexpr(
            std::__2::__unwrap_iter(__first), std::__2::__unwrap_iter(__last), std::__2::__unwrap_iter(__result));
    } else {
        return std::__2::__copy(
            std::__2::__unwrap_iter(__first), std::__2::__unwrap_iter(__last), std::__2::__unwrap_iter(__result));
    }
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__copy_backward_constexpr(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    return std::__2::__copy_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__2::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__2::__copy_backward_constexpr(std::__2::__unwrap_iter(__first),
                                                std::__2::__unwrap_iter(__last),
                                                std::__2::__unwrap_iter(__result));
    } else {
        return std::__2::__copy_backward(std::__2::__unwrap_iter(__first),
                                      std::__2::__unwrap_iter(__last),
                                      std::__2::__unwrap_iter(__result));
    }
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__2::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__2::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::__2::copy(__first, __first + __n, __result);
}





template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__move_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = std::__2::move(*__first);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__2::__move_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    if (__libcpp_is_constant_evaluated())
        return std::__2::__move_constexpr(__first, __last, __result);
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__2::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__2::__move(std::__2::__unwrap_iter(__first), std::__2::__unwrap_iter(__last), std::__2::__unwrap_iter(__result));
}





template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__move_backward_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__2::move(*--__last);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__2::__move_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    if (__libcpp_is_constant_evaluated())
        return std::__2::__move_backward_constexpr(__first, __last, __result);
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__2::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__2::__move_backward(std::__2::__unwrap_iter(__first), std::__2::__unwrap_iter(__last), std::__2::__unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__2::__fill_n(__first, std::__2::__convert_to_integral(__n), __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__2::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__2::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(std::__2::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
                                                    _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__2::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__2::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
                                                    _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__2::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__2::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
                                                    _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__2::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__2::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__2::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
                              _ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__2::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__2::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        std::__2::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            std::__2::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__2::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
                              _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__2::move(*__first);
    _ForwardIterator __lm1 = std::__2::move(std::__2::next(__first), __last, __first);
    *__lm1 = std::__2::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
                              _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__2::prev(__last);
    value_type __tmp = std::__2::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__2::move_backward(__first, __lm1, __last);
    *__first = std::__2::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
                              _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
                              _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__2::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__2::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__2::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__2::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__2::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              _ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__2::forward_iterator_tag)
{
    typedef typename std::__2::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__2::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__2::next(__first) == __middle)
            return std::__2::__rotate_left(__first, __last);
    }
    return std::__2::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              _BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__2::bidirectional_iterator_tag)
{
    typedef typename std::__2::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__2::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__2::next(__first) == __middle)
            return std::__2::__rotate_left(__first, __last);
        if (std::__2::next(__middle) == __last)
            return std::__2::__rotate_right(__first, __last);
    }
    return std::__2::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              _RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__2::random_access_iterator_tag)
{
    typedef typename std::__2::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__2::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__2::next(__first) == __middle)
            return std::__2::__rotate_left(__first, __last);
        if (std::__2::next(__middle) == __last)
            return std::__2::__rotate_right(__first, __last);
        return std::__2::__rotate_gcd(__first, __middle, __last);
    }
    return std::__2::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                              _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__2::__rotate(__first, __middle, __last,
                           typename std::__2::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__2::copy(__first, __middle, std::__2::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::min_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__2::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__2::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__2::min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::__2::min_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::max_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__2::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__2::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__2::max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::__2::max_element(__t.begin(), __t.end(), __less<_Tp>());
}
# 2719 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _ForwardIterator, class _Compare>

pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::minmax_element requires a ForwardIterator");
  pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__2::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__2::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    pair<_Tp, _Tp> __result(*__first, *__first);

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(*__first, __prev)) {
            if ( __comp(*__first, __result.first)) __result.first = *__first;
            if (!__comp(__prev, __result.second)) __result.second = __prev;
            }
        else {
            if ( __comp(__prev, __result.first)) __result.first = __prev;
            if (!__comp(*__first, __result.second)) __result.second = *__first;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__2::minmax(__t, __less<_Tp>());
}







template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    uniform_int_distribution() : uniform_int_distribution(0) {}
    explicit uniform_int_distribution(
        result_type __a, result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}






    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __libcpp_clz(_Rp) - 1;
    if ((_Rp & (numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}



class __attribute__ ((__visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static constexpr result_type min() {return _Min;}
    static constexpr result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
                            void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
                            void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

               _RandomNumberGenerator&& __rand)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __rand(__d);
            if (__i != difference_type(0))
              swap(*__first, *(__first + __i));
        }
    }
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator & __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void) ++__k) {
    _Distance __r = std::__2::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::__2::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = std::__2::distance(__first, __last);
  for (__n = std::__2::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__2::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
        _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
        _Difference;
  static_assert(__is_cpp17_forward_iterator<_PopulationIterator>::value ||
                __is_cpp17_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__2::__sample(
      __first, __last, __output_iter, _CommonType(__n),
      __g, _PopCategory());
}
# 3252 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _UniformRandomNumberGenerator&& __g)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}
# 3377 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
template <class _InputIterator, class _Predicate>
                                                    bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
                              _ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
                              _BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__2::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
                              pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
                              _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__2::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__2::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__2::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__2::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__2::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__2::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__2::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__2::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = std::__2::__stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__2::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__2::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator()(_Tp* __p) const {std::__2::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__2::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__2::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__2::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__2::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__2::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__2::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }

        *__first = std::__2::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__2::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__2::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = std::__2::__stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__2::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__2::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__2::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__2::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__2::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__2::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
                                                    _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__2::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__2::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__2::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
                              unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = std::__2::__sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
__attribute__ ((__visibility__("hidden")))
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = std::__2::__sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BidirectionalIterator>
                              void
__selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BidirectionalIterator __i = std::__2::min_element<_BidirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BidirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BidirectionalIterator __j = __i;
            value_type __t(std::__2::move(*__j));
            for (_BidirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__2::move(*__k);
            *__j = std::__2::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__2::__sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__2::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__2::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__2::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__2::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__2::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__2::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__2::__sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__2::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__2::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__2::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                      typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new ((void*)__last2) value_type(std::__2::move(*__first1));
        __d.template __incr<value_type>();
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new ((void*)__j2) value_type(std::__2::move(*__i2));
                __d.template __incr<value_type>();
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__2::move(*__i2);
                *__j2 = std::__2::move(*__first1);
            }
            else
            {
                ::new ((void*)__j2) value_type(std::__2::move(*__first1));
                __d.template __incr<value_type>();
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__2::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__2::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__2::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__2::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__2::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__2::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__2::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__2::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__2::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__2::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__sort<_Comp_ref>(__first, __last, _Comp_ref(__comp));
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__2::sort((uintptr_t*)__first, (uintptr_t*)__last, __less<uintptr_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__2::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__2::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);



template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__2::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__2::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__2::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__2::__lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__2::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__2::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__2::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__2::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__2::__upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__2::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
                              pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__2::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__2::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__2::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      std::__2::__lower_bound<_Compare>(__first, __m, __value_, __comp),
                      std::__2::__upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__equal_range<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__2::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = std::__2::__lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__binary_search<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__2::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>

_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__2::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__2::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__2::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__2::move(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = std::__2::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__2::move(*__first1);
            ++__first1;
        }
    }

}

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__2::move(*__i));
        std::__2::__half_inplace_merge<_Compare>(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__2::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        typedef __invert<_Compare> _Inverted;
        std::__2::__half_inplace_merge<_Inverted>(_Rv(__p), _Rv(__buff),
                                    _RBi(__middle), _RBi(__first),
                                    _RBi(__last), _Inverted(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return std::__2::__buffered_inplace_merge<_Compare>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
# 4657 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__2::advance(__m2, __len21);
            __m1 = std::__2::__upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__2::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__2::advance(__m1, __len11);
            __m2 = std::__2::__lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__2::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__2::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            std::__2::__inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            std::__2::__inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__2::distance(__first, __middle);
    difference_type __len2 = std::__2::distance(__middle, __last);
    difference_type __buf_size = std::__2::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf = std::__2::get_temporary_buffer<value_type>(__buf_size);
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__2::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__2::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__2::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new ((void*)__result) value_type(std::__2::move(*__first2));
            __d.template __incr<value_type>();
            ++__first2;
        }
        else
        {
            ::new ((void*)__result) value_type(std::__2::move(*__first1));
            __d.template __incr<value_type>();
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result)
                *__result = std::__2::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__2::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__2::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, (void) ++__result)
        *__result = std::__2::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new ((void*)__first2) value_type(std::__2::move(*__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
        if (__comp(*--__last1, *__first1))
        {
            ::new ((void*)__first2) value_type(std::__2::move(*__last1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__2::move(*__first1));
        }
        else
        {
            ::new ((void*)__first2) value_type(std::__2::move(*__first1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__2::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        std::__2::__insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    std::__2::__stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    std::__2::__stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    std::__2::__merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        std::__2::__insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        std::__2::__stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)nullptr);
        std::__2::__stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)nullptr);
        std::__2::__merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    std::__2::__stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    std::__2::__stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    std::__2::__inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__2::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
                                                    _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__2::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__2::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__2::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__2::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
                              void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__2::move(*__last));
            do
            {
                *__last = std::__2::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__2::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
                              void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator ,
            _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(std::__2::move(*__start));
    do
    {

        *__start = std::__2::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::__2::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        std::__2::__sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
                              void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {

        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            std::__2::__sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__make_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
                              void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, (void) --__n)
        std::__2::__pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__sort_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__2::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
                              void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    std::__2::__make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            std::__2::__sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    std::__2::__sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__2::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
                              _RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, (void) ++__r)
            *__r = *__first;
        std::__2::__make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                std::__2::__sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        std::__2::__sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__2::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template<class _Compare, class _RandomAccessIterator>
                              bool
__nth_element_find_guard(_RandomAccessIterator& __i, _RandomAccessIterator& __j,
                         _RandomAccessIterator& __m, _Compare __comp)
{

    while (--__j != __i)
    {
        if (__comp(*__j, *__m))
        {
            return true;
        }
    }
    return false;
}

template<class _Compare, class _RandomAccessIterator>
                              bool
__nth_element_partloop(_RandomAccessIterator __first, _RandomAccessIterator __last,
                       _RandomAccessIterator& __i, _RandomAccessIterator& __j,
                       unsigned& __n_swaps, _Compare __comp)
{


    ++__i;
    __j = __last;
    if (!__comp(*__first, *--__j))
    {
        while (true)
        {
            if (__i == __j)
                return true;
            if (__comp(*__first, *__i))
            {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
            }
            ++__i;
        }
    }

    if (__i == __j)
        return true;
    while (true)
    {
        while (!__comp(*__first, *__i))
            ++__i;
        while (__comp(*__first, *--__j))
            ;
        if (__i >= __j)
            break;
        swap(*__i, *__j);
        ++__n_swaps;
        ++__i;
    }


    return false;
}

template <class _Compare, class _RandomAccessIterator>
                              void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {

        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__2::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            std::__2::__selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__2::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {

            if (std::__2::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp)) {
                swap(*__i, *__j);
                ++__n_swaps;

            } else if (std::__2::__nth_element_partloop<_Compare>(__first, __last, __i, __j, __n_swaps, __comp)) {
                return;
            } else if (__nth < __i) {
                return;
            } else {


                __first = __i;
                continue;
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (true)
                {
                    if (++__j == __i)

                        return;
                    if (__comp(*__j, *__m))

                        break;
                    __m = __j;
                }
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (++__j == __last)

                        return;
                    if (__comp(*__j, *__m))

                        break;
                    __m = __j;
                }
            }
        }

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__2::__nth_element<_Comp_ref>(__first, __nth, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__2::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__2::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__2::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            if (!__comp(*__first1, *__first2))
                ++__first2;
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__2::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__2::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__2::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__2::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__2::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__2::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__2::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__2::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__2::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
                              bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__2::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__2::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__next_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__2::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
                              bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__2::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__2::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__2::__prev_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__2::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 2 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwchar" 1 3
# 107 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwchar" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwctype" 1 3
# 53 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwctype" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cctype" 1 3
# 38 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cctype" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctype.h" 1 3
# 36 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctype.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 1 3
# 43 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
        namespace std {

        extern "C" {
# 134 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
extern __attribute__((__nothrow__)) __attribute__((__const__)) unsigned char **__rt_ctype_table(void);




    inline int isalnum(int __c) { return ((*std:: __rt_ctype_table())[__c] & (16 +8 +32)); }







    inline int isalpha(int __c) { return ((*std:: __rt_ctype_table())[__c] & (16 +8 +128)); }







    inline int iscntrl(int __c) { return ((*std:: __rt_ctype_table())[__c] & 64); }
# 165 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
    inline int isdigit(int __c) { return ((*std:: __rt_ctype_table())[__c] == 32); }






    extern int (isblank)(int );





    inline int isgraph(int __c) {return((*std:: __rt_ctype_table())[__c] & (8 +16 +32 +128 +2));}







    inline int islower(int __c) { return ((*std:: __rt_ctype_table())[__c] & 8); }







    inline int isprint(int __c) { return ((*std:: __rt_ctype_table())[__c] & (8 +16 +32 +2 +4)); }
# 203 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
    inline int ispunct(int __c) { return ((*std:: __rt_ctype_table())[__c] & 2); }







    inline int isspace(int __c) { return ((*std:: __rt_ctype_table())[__c] & 1); }







    inline int isupper(int __c) { return ((*std:: __rt_ctype_table())[__c] & 16); }
# 229 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }

    inline int isxdigit(int __c){return __isxdigit_helper((*std:: __rt_ctype_table())[__c]) & 128;}
# 240 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\ctype.h" 3
extern int tolower(int );



extern int toupper(int );




         }
      }





      using ::std::isalnum;
      using ::std::isalpha;
      using ::std::iscntrl;
      using ::std::isdigit;
      using ::std::isblank;
      using ::std::isgraph;
      using ::std::islower;
      using ::std::isprint;
      using ::std::ispunct;
      using ::std::isspace;
      using ::std::isupper;
      using ::std::isxdigit;
      using ::std::tolower;
      using ::std::toupper;
# 39 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctype.h" 2 3
# 39 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cctype" 2 3
# 42 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cctype" 3


namespace std { inline namespace __2 {
# 103 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cctype" 3
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }
# 54 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwctype" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wctype.h" 1 3
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wctype.h" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wctype.h" 1 3
# 21 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wctype.h" 3
        namespace std {
      extern "C" {






      typedef int wint_t;





    typedef void *wctype_t;
    typedef void *wctrans_t;




    __attribute__((__nothrow__)) int iswalnum(wint_t );
    __attribute__((__nothrow__)) int iswalpha(wint_t );
    __attribute__((__nothrow__)) int iswblank(wint_t );
    __attribute__((__nothrow__)) int iswcntrl(wint_t );
    __attribute__((__nothrow__)) int iswgraph(wint_t );
    __attribute__((__nothrow__)) int iswprint(wint_t );
    __attribute__((__nothrow__)) int iswpunct(wint_t );
    __attribute__((__nothrow__)) int iswspace(wint_t );
    __attribute__((__nothrow__)) int iswlower(wint_t );
    __attribute__((__nothrow__)) int iswupper(wint_t );
    __attribute__((__nothrow__)) int iswdigit(wint_t );
    __attribute__((__nothrow__)) int iswxdigit(wint_t );
    __attribute__((__nothrow__)) wint_t towlower(wint_t );
    __attribute__((__nothrow__)) wint_t towupper(wint_t );

    __attribute__((__nothrow__)) wctype_t wctype(const char * ) __attribute__((__nonnull__(1)));
    __attribute__((__nothrow__)) int iswctype(wint_t , wctype_t );

    __attribute__((__nothrow__)) wctrans_t wctrans(const char * ) __attribute__((__nonnull__(1)));
    __attribute__((__nothrow__)) wint_t towctrans(wint_t , wctrans_t );


         }
      }
# 74 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\wctype.h" 3
      using ::std::wint_t;
      using ::std::wctype_t;
      using ::std::wctrans_t;
      using ::std::iswalnum;
      using ::std::iswalpha;
      using ::std::iswblank;
      using ::std::iswcntrl;
      using ::std::iswgraph;
      using ::std::iswprint;
      using ::std::iswpunct;
      using ::std::iswspace;
      using ::std::iswlower;
      using ::std::iswupper;
      using ::std::iswdigit;
      using ::std::iswxdigit;
      using ::std::towlower;
      using ::std::towupper;
      using ::std::wctype;
      using ::std::iswctype;
      using ::std::wctrans;
      using ::std::towctrans;
# 55 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wctype.h" 2 3
# 55 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwctype" 2 3
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwctype" 3


namespace std { inline namespace __2 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }
# 108 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwchar" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\wchar.h" 1 3
# 109 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwchar" 2 3
# 112 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cwchar" 3


namespace std { inline namespace __2 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;



using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;
using ::wcstof;
using ::wcstold;
using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;
using ::vwscanf;
using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;


} }
# 61 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 2 3
# 67 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 71 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 2 3


namespace std { inline namespace __2 {
# 194 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static
    char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

template <class _CharT>
                              int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline
                              size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline
                              const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

template <class _CharT>
                              _CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <class _CharT>
static inline
_CharT* __move_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    if (__s1 < __s2) {
      std::__2::copy(__s2, __s2 + __n, __s1);
    } else if (__s2 < __s1) {
      std::__2::copy_backward(__s2, __s2 + __n, __s1 + __n);
    }
    return __s1;
}

template <class _CharT>
static inline
_CharT* __copy_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    std::__2::copy_n(__s2, __n, __s1);
    return __s1;
}

template <class _CharT>
static inline
_CharT* __assign_constexpr(_CharT* __s, size_t __n, _CharT __a) noexcept
{
     std::__2::fill_n(__s, __n, __a);
     return __s;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static inline size_t
    length(const char_type* __s) noexcept {return __builtin_strlen(__s);}
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__2::memmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__2::memcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : (char_type*)std::__2::memset(__s, to_int_type(__a), __n);
        }

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

inline
int
char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_memcmp(__s1, __s2, __n);
# 430 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
}

inline
const char*
char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 451 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
}




template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static
    size_t length(const char_type* __s) noexcept;
    static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__2::wmemmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__2::wmemcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__2::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : std::__2::wmemset(__s, __a, __n);
        }
    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(((::std:: wint_t)-1));}
};

inline
int
char_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_wmemcmp(__s1, __s2, __n);
# 532 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
}


template <class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
inline size_t __char_traits_length_checked(const typename _Traits::char_type* __s) noexcept {



  return _Traits::length(__s);

}

inline
size_t
char_traits<wchar_t>::length(const char_type* __s) noexcept
{

    return __builtin_wcslen(__s);
# 560 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
}

inline
const wchar_t*
char_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_wmemchr(__s, __a, __n);
# 581 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
}
# 695 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__string" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}






template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == nullptr)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == nullptr)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const _CharT *__r = __search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::__2::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__2::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__2::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == nullptr)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == nullptr)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;

    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}

};

} }
# 180 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 2 3
# 190 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 194 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 2 3


namespace std { inline namespace __2 {

template<class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string_view;

typedef basic_string_view<char> string_view;



typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;

template<class _CharT, class _Traits>
class
    __attribute__((__preferred_name__(string_view)))



    __attribute__((__preferred_name__(u16string_view)))
    __attribute__((__preferred_name__(u32string_view)))
    __attribute__((__preferred_name__(wstring_view)))
    basic_string_view {
public:

    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _CharT* pointer;
    typedef const _CharT* const_pointer;
    typedef _CharT& reference;
    typedef const _CharT& const_reference;
    typedef const_pointer const_iterator;
    typedef const_iterator iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr const size_type npos = -1;

    static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view() noexcept : __data (nullptr), __size(0) {}

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view(const basic_string_view&) noexcept = default;

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view& operator=(const basic_string_view&) noexcept = default;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view(const _CharT* __s, size_type __len) noexcept
        : __data(__s), __size(__len)
    {



    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view(const _CharT* __s)
        : __data(__s), __size(std::__2::__char_traits_length_checked<_Traits>(__s)) {}


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept { return cbegin(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept { return cend(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept { return __data; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept { return __data + __size; }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type length() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    bool empty() const noexcept { return __size == 0; }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reference operator[](size_type __pos) const noexcept {
      return ((void)0), __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reference at(size_type __pos) const
    {
        return __pos >= size()
            ? (__throw_out_of_range("string_view::at"), __data[0])
            : __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reference front() const noexcept
    {
        return ((void)0), __data[0];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reference back() const noexcept
    {
        return ((void)0), __data[__size-1];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer data() const noexcept { return __data; }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void remove_prefix(size_type __n) noexcept
    {
        ((void)0);
        __data += __n;
        __size -= __n;
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void remove_suffix(size_type __n) noexcept
    {
        ((void)0);
        __size -= __n;
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_string_view& __other) noexcept
    {
        const value_type *__p = __data;
        __data = __other.__data;
        __other.__data = __p;

        size_type __sz = __size;
        __size = __other.__size;
        __other.__size = __sz;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
    {
        if (__pos > size())
            __throw_out_of_range("string_view::copy");
        size_type __rlen = std::__2::min(__n, size() - __pos);
        _Traits::copy(__s, data() + __pos, __rlen);
        return __rlen;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
    {
        return __pos > size()
            ? (__throw_out_of_range("string_view::substr"), basic_string_view())
            : basic_string_view(data() + __pos, std::__2::min(__n, size() - __pos));
    }

                                  int compare(basic_string_view __sv) const noexcept
    {
        size_type __rlen = std::__2::min( size(), __sv.size());
        int __retval = _Traits::compare(data(), __sv.data(), __rlen);
        if ( __retval == 0 )
            __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
        return __retval;
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
    {
        return substr(__pos1, __n1).compare(__sv);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare( size_type __pos1, size_type __n1,
                basic_string_view __sv, size_type __pos2, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(const _CharT* __s) const noexcept
    {
        return compare(basic_string_view(__s));
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s));
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(_CharT __c, size_type __pos = 0) const noexcept
    {
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(const _CharT* __s, size_type __pos = 0) const
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
    {
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
    { return find(__c, __pos); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(const _CharT* __s, size_type __pos=0) const
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
    { return rfind(__c, __pos); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
    {
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
    {
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }
# 643 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 3
private:
    const value_type* __data;
    size_type __size;
};




template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}



template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}



template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator>(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}



template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}



template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}

template<class _CharT, class _Traits>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __str);


template<class _CharT>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string_view<_CharT, char_traits<_CharT> > >
    : public unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const noexcept {
        return __do_string_hash(__val.data(), __val.data() + __val.size());
    }
};
# 867 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string_view" 3
} }
# 513 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 2 3
# 534 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 538 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 2 3


namespace std { inline namespace __2 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__ ((__visibility__("default"))) string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{
    std::__2::__throw_length_error("basic_string");
}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{
    std::__2::__throw_out_of_range("basic_string");
}

extern template class __attribute__ ((__visibility__("default"))) __basic_string_common<true>;


template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};
# 649 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};



template <class _CharT, size_t = sizeof(_CharT)>
struct __padding
{
    unsigned char __xx[sizeof(_CharT)-1];
};

template <class _CharT>
struct __padding<_CharT, 1>
{
};
# 679 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;


template<class _CharT, class _Traits, class _Allocator>
class
    __attribute__ ((__type_visibility__("default")))




    __attribute__((__preferred_name__(u16string)))
    __attribute__((__preferred_name__(u32string)))

    basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;

private:



    struct __long
    {
        pointer __data_;
        size_type __size_;
        size_type __cap_;
    };





    static const size_type __short_mask = 0x80;
    static const size_type __long_mask = ~(size_type(~0) >> 1);


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        value_type __data_[__min_cap];
        struct
            : __padding<value_type>
        {
            unsigned char __size_;
        };
    };
# 787 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    __attribute__ ((__visibility__("default")))
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit basic_string(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value);




    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(basic_string&& __str)

        noexcept(is_nothrow_move_constructible<allocator_type>::value);




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(basic_string&& __str, const allocator_type& __a);


    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
      ((void)0);
      __init(__s, traits_type::length(__s));



    }

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string(const _CharT* __s, const _Allocator& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(size_type __n, _CharT __c);

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);

    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t);

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t, const allocator_type& __a);

    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);


    inline ~basic_string();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    basic_string& operator=(const basic_string& __str);

    template <class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
    basic_string& operator=(const _Tp& __t)
        {__self_view __sv = __t; return assign(__sv);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 931 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator begin() noexcept
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator end() noexcept
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type length() const noexcept {return size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type capacity() const noexcept
        {return (__is_long() ? __get_long_cap()
                             : static_cast<size_type>(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type __requested_capacity);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __resize_default_init(size_type __n);

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void reserve() noexcept {shrink_to_fit();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void shrink_to_fit() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept {return size() == 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](size_type __pos) noexcept;

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string >::value,
            basic_string&
        >
                                            operator+=(const _Tp& __t) {__self_view __sv = __t; return append(__sv);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& append(const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf<
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __append_default_init(size_type __n);

    template <class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp (__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    append(_ForwardIterator __first, _ForwardIterator __last) {
      return __append_forward_unsafe(__first, __last);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference front() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference front() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference back() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference back() const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::__2::move(__str); return *this;}

    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
           __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >
        assign(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 insert(size_type __pos1, const _Tp& __t)
    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
           __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_string& __str)



        noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const value_type* c_str() const noexcept {return data();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const value_type* data() const noexcept {return std::__2::__to_address(__get_pointer());}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find(const _Tp& __t, size_type __pos = 0) const;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              rfind(const _Tp& __t, size_type __pos = npos) const;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_of(const _Tp& __t, size_type __pos = 0) const;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_of(const _Tp& __t, size_type __pos = npos) const;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_not_of(const _Tp &__t, size_type __pos = 0) const;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_not_of(const _Tp& __t, size_type __pos = npos) const;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(const basic_string& __str) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
        compare(const _Tp &__t) const;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            int
        >
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const noexcept;
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
# 1455 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __clear_and_shrink() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __shrink_or_extend(size_type __target_capacity);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool __is_long() const noexcept
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1474 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type& __alloc() noexcept
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept
        {return __r_.second();}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_short_size(size_type __s) noexcept



        {__r_.first().__s.__size_ = (unsigned char)(__s);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type __get_short_size() const noexcept



        {return __r_.first().__s.__size_;}
# 1520 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_long_cap(size_type __s) noexcept
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type __get_long_cap() const noexcept
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __zero() noexcept
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type __recommend(size_type __s) noexcept
        {
        if (__s < __min_cap) return static_cast<size_type>(__min_cap) - 1;
        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        if (__guess == __min_cap) ++__guess;
        return __guess;
        }

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);
# 1597 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
    void __init_copy_ctor_external(const value_type* __s, size_type __sz);

    template <class _InputIterator>
    inline
    _EnableIf
    <
        __is_exactly_cpp17_input_iterator<_InputIterator>::value
    >
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline
    _EnableIf
    <
        __is_cpp17_forward_iterator<_ForwardIterator>::value
    >
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);




    template <bool __is_short>
    basic_string& __assign_no_alias(const value_type* __s, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __erase_to_end(size_type __pos);



    void __erase_external_with_move(size_type __pos, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                    __clear_and_shrink();
                    __alloc() = std::__2::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign(basic_string& __str, true_type)



        noexcept(is_nothrow_move_assignable<allocator_type>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__2::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    basic_string& __assign_external(const value_type* __s);
    basic_string& __assign_external(const value_type* __s, size_type __n);


    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
      pointer __p = __is_long()
                        ? (__set_long_size(__n), __get_long_pointer())
                        : (__set_short_size(__n), __get_short_pointer());
      traits_type::move(std::__2::__to_address(__p), __s, __n);
      traits_type::assign(__p[__n], value_type());
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};




extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init_copy_ctor_external(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::__assign_external(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::__assign_external(value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::__assign_no_alias<false>(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::__assign_no_alias<true>(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__erase_external_with_move(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);
extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init_copy_ctor_external(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::__assign_external(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::__assign_external(value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::__assign_no_alias<false>(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::__assign_no_alias<true>(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__erase_external_with_move(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);
# 1764 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1802 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
     : __r_(__default_init_tag(), __default_init_tag())
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



: __r_(__default_init_tag(), __a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__2::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__2::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
     : __r_(__default_init_tag(), __default_init_tag())
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__2::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());




}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__2::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
    const value_type* __s, size_type __sz) {
  pointer __p;
  if (__sz < __min_cap) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      this->__throw_length_error();
    size_t __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__2::__to_address(__p), __s, __sz + 1);
}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)

        noexcept(is_nothrow_move_constructible<allocator_type>::value)



    : __r_(std::__2::move(__str.__r_))
{
    __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (__str.__is_long() && __a != __str.__alloc())
        __init(std::__2::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
    else
    {
        __r_.first().__r = __str.__r_.first().__r;
        __str.__zero();
    }





}



template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__2::__to_address(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__2::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
_EnableIf
<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();




    for (; __first != __last; ++__first)
        push_back(*__first);
# 2145 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline

basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__2::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__2::__to_address(__p),
                          std::__2::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__2::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__2::__to_address(__p) + __n_copy + __n_add,
                          std::__2::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__2::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__2::__to_address(__p),
                          std::__2::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__2::__to_address(__p) + __n_copy + __n_add,
                          std::__2::__to_address(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
    const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? __min_cap : __get_long_cap();
  if (__n < __cap) {
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__2::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(
    const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type* __p = std::__2::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    return (__builtin_constant_p(__n) && __n < __min_cap)
               ? __assign_short(__s, __n)
               : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__2::__to_address(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
  if (this != &__str) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        __r_.first().__r = __str.__r_.first().__r;
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)



    noexcept(is_nothrow_move_assignable<allocator_type>::value)

{
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());

    if (!is_nothrow_move_assignable<allocator_type>::value) {
      __set_short_size(0);
      traits_type::assign(__get_short_pointer()[0], value_type());
    }

  }
  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  __str.__set_short_size(0);
  traits_type::assign(__str.__get_short_pointer()[0], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__str, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
     __is_exactly_cpp17_input_iterator <_InputIterator>::value
          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__2::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__sv.data() + __pos, std::__2::min(__n, __sz - __pos));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return __builtin_constant_p(*__s)
               ? (traits_type::length(__s) < __min_cap
                      ? __assign_short(__s, traits_type::length(__s))
                      : __assign_external(__s, traits_type::length(__s)))
               : __assign_external(__s);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__2::__to_address(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__2::__to_address(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _Tp>
bool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)
{
    return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)
{
    return false;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
    _ForwardIterator __first, _ForwardIterator __last)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "function requires a ForwardIterator");
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_ref = *__first;
        if (__ptr_in_range(std::__2::addressof(__tmp_ref), data(), data() + size()))
        {
            const basic_string __temp (__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
        else
        {
            if (__cap - __sz < __n)
                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__2::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
    _EnableIf
    <
        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        basic_string<_CharT, _Traits, _Allocator>&
    >
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__sv.data() + __pos, std::__2::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__2::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__2::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__2::__to_address(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
   __is_exactly_cpp17_input_iterator<_InputIterator>::value
        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
   typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_char = *__first;
        if (__ptr_in_range(std::__2::addressof(__tmp_char), data(), data() + size()))
        {
            const basic_string __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }

        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__2::__to_address(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__2::__to_address(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__2::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::__2::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__2::__to_address(__get_long_pointer());
    }
    else
    {
        __p = std::__2::__to_address(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__2::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__2::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:


        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__2::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__2::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__2::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__2::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::__2::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}





template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
    size_type __pos, size_type __n)
{
    if (__n)
    {
        size_type __sz = size();
        value_type* __p = std::__2::__to_address(__get_pointer());
        __n = std::__2::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  if (__pos > size()) this->__throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (__n > __sz) {
       __append_default_init(__n - __sz);
    } else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
{
    if (__requested_capacity > max_size())
        this->__throw_length_error();






    size_type __target_capacity = std::__2::max(__requested_capacity, size());
    __target_capacity = __recommend(__target_capacity);
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() noexcept
{
    size_type __target_capacity = __recommend(size());
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
{
    size_type __cap = capacity();
    size_type __sz = size();

    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__target_capacity == __min_cap - 1)
    {
        __was_long = true;
        __now_long = false;
        __new_data = __get_short_pointer();
        __p = __get_long_pointer();
    }
    else
    {
        if (__target_capacity > __cap)
            __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);
        else
        {




                __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);







            if (__new_data == nullptr)
                return;

        }
        __now_long = true;
        __was_long = __is_long();
        __p = __get_pointer();
    }
    traits_type::copy(std::__2::__to_address(__new_data),
                        std::__2::__to_address(__p), size()+1);
    if (__was_long)
        __alloc_traits::deallocate(__alloc(), __p, __cap+1);
    if (__now_long)
    {
        __set_long_cap(__target_capacity+1);
        __set_long_size(__sz);
        __set_long_pointer(__new_data);
    }
    else
        __set_short_size(__sz);
    __invalidate_all_iterators();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front() noexcept
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const noexcept
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back() noexcept
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const noexcept
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__2::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)



        noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{







    ((void)0);



    std::__2::swap(__r_.first(), __str.__r_.first());
    std::__2::__swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const
{
    __self_view __sv = __t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__2::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__2::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__2::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t) const
{
    __self_view __sv = __t;
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template<class _CharT, class _Traits, class _Allocator>
inline
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == nullptr)
        return false;
    if (data()[size()] != value_type())
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept
{
    clear();
    if(__is_long())
    {
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        __set_long_cap(0);
        __set_short_size(0);
        traits_type::assign(*__get_short_pointer(), value_type());
    }
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::__2::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__2::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__2::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::__2::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::__2::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::__2::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::__2::move(__lhs);
}





template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}

__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) float stof (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) double stod (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) long double stold(const string& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) float stof (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) double stod (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) long double stold(const wstring& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) __attribute__((pcs("aapcs"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("default")))
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
               basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __attribute__ ((__type_visibility__("default")))
    hash<basic_string<_CharT, char_traits<_CharT>, _Allocator> >
    : public unary_function<
          basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t>
{
    size_t
    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const noexcept
    { return __do_string_hash(__val.data(), __val.data() + __val.size()); }
};


template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4560 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\string" 3
} }
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 1 3
# 276 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bit_reference" 1 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bit_reference" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bit_reference" 2 3


namespace std { inline namespace __2 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_reference(const __bit_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_const_reference(const __bit_const_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__2::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__2::__find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__2::__find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__2::__libcpp_popcount(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__2::__libcpp_popcount(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__2::__libcpp_popcount(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__2::__libcpp_popcount(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__2::__libcpp_popcount(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__2::__libcpp_popcount(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__2::__count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__2::__count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__2::memset(std::__2::__to_address(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__2::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__2::memset(std::__2::__to_address(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            std::__2::__fill_n_true(__first, __n);
        else
            std::__2::__fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__2::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__2::memmove(std::__2::__to_address(__result.__seg_),
                       std::__2::__to_address(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return std::__2::__copy_aligned(__first, __last, __result);
    return std::__2::__copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__2::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__2::memmove(std::__2::__to_address(__result.__seg_),
                       std::__2::__to_address(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__2::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__2::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return std::__2::__copy_backward_aligned(__first, __last, __result);
    return std::__2::__copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__2::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__2::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__2::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__2::__swap_ranges_aligned(__first1, __last1, __first2);
    return std::__2::__swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__2::copy(__first, __middle, __b.begin());
                std::__2::copy(__b.begin(), __b.end(), std::__2::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__2::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__2::copy(__middle, __last, __b.begin());
                std::__2::copy_backward(__b.begin(), __b.end(), std::__2::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__2::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__2::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__2::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__2::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__2::__equal_aligned(__first1, __last1, __first2);
    return std::__2::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator() noexcept



    {}


    using __type_for_copy_to_const =
      _If<_IsConst, __bit_iterator<_Cp, false>, struct __private_nat>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_iterator(const __type_for_copy_to_const& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}




    using __type_for_abi_non_trivial_copy_ctor =
      _If<!_IsConst, __bit_iterator, struct __private_nat>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_iterator(__type_for_abi_non_trivial_copy_ctor const& __it) noexcept
      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_iterator& operator=(__bit_iterator const&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 277 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\climits" 1 3
# 41 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\climits" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 1 3
# 44 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 57 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\limits.h" 1 3
# 58 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 2 3
# 42 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\climits" 2 3
# 45 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\climits" 3
# 279 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 2 3







# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__split_buffer" 1 3
# 11 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__split_buffer" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__split_buffer" 2 3


namespace std { inline namespace __2 {

template <bool>
class __split_buffer_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __alloc_rr& __alloc() noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const __alloc_rr& __alloc() const noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pointer& __end_cap() noexcept {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const pointer& __end_cap() const noexcept {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __split_buffer()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __split_buffer(__alloc_rr& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();

    __split_buffer(__split_buffer&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
    __split_buffer& operator=(__split_buffer&& __c)
        noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator begin() noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator begin() const noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator end() noexcept {return __end_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator end() const noexcept {return __end_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept
        {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference front() {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference front() const {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() noexcept;
    void push_front(const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void push_back(const_reference __x);
    void push_front(value_type&& __x);
    void push_back(value_type&& __x);
    template <class... _Args>
        void emplace_back(_Args&&... __args);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIter>::value &&
           !__is_cpp17_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;

    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);


    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__2::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        {}

    struct _ConstructTransaction {
      explicit _ConstructTransaction(pointer* __p, size_type __n) noexcept
      : __pos_(*__p), __end_(*__p + __n), __dest_(__p) {
      }
      ~_ConstructTransaction() {
        *__dest_ = __pos_;
      }
      pointer __pos_;
     const pointer __end_;
    private:
     pointer *__dest_;
    };
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(), std::__2::__to_address(__tx.__pos_));
    }
}







template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(),
            std::__2::__to_address(__tx.__pos_), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_cpp17_input_iterator<_InputIter>::value &&
    !__is_cpp17_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__2::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__2::__to_address(__buf.__end_), std::__2::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__2::__to_address(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    _ConstructTransaction __tx(&this->__end_, std::__2::distance(__first, __last));
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, ++__first) {
        __alloc_traits::construct(this->__alloc(),
            std::__2::__to_address(__tx.__pos_), *__first);
    }
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), std::__2::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__2::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__2::move(__c.__first_)),
      __begin_(std::__2::move(__c.__begin_)),
      __end_(std::__2::move(__c.__end_)),
      __end_cap_(std::__2::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        size_type __cap = __c.size();
        __first_ = __alloc_traits::allocate(__alloc(), __cap);
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __cap;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::__2::swap(__first_, __x.__first_);
    std::__2::swap(__begin_, __x.__begin_);
    std::__2::swap(__end_, __x.__end_);
    std::__2::swap(__end_cap(), __x.__end_cap());
    std::__2::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__2::swap(__first_, __t.__first_);
        std::__2::swap(__begin_, __t.__begin_);
        std::__2::swap(__end_, __t.__end_);
        std::__2::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());






    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__2::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__2::__to_address(__begin_-1), __x);
    --__begin_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__2::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__2::__to_address(__begin_-1),
            std::__2::move(__x));
    --__begin_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__2::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__2::__to_address(__end_), __x);
    ++__end_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__2::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__2::__to_address(__end_),
            std::__2::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__2::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__2::swap(__first_, __t.__first_);
            std::__2::swap(__begin_, __t.__begin_);
            std::__2::swap(__end_, __t.__end_);
            std::__2::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__2::__to_address(__end_),
                              std::__2::forward<_Args>(__args)...);
    ++__end_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 287 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 2 3
# 293 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 297 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 2 3


namespace std { inline namespace __2 {

template <bool>
class __attribute__ ((__type_visibility__("default"))) __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __vector_base_common() {}
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
    std::__2::__throw_length_error("vector");
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
    std::__2::__throw_out_of_range("vector");
}

extern template class __attribute__ ((__visibility__("default"))) __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type& __alloc() noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const allocator_type& __alloc() const noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer& __end_cap() noexcept
        {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const pointer& __end_cap() const noexcept
        {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __vector_base(const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __vector_base(allocator_type&& __a) noexcept;

    ~__vector_base();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__2::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept
{
    pointer __soon_to_be_end = __end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__2::__to_address(--__soon_to_be_end));
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __a)
{
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base(allocator_type&& __a) noexcept
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, std::__2::move(__a)) {}


template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {



        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



        : __base(__a)
    {



    }
    explicit vector(size_type __n);



    vector(size_type __n, const value_type& __x);
    vector(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~vector()
    {
        __annotate_delete();



    }

    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector& operator=(const vector& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector(vector&& __x)



        noexcept(is_nothrow_move_constructible<allocator_type>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector(vector&& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator end() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return __base::capacity();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    size_type max_size() const noexcept;
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](size_type __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference operator[](size_type __n) const noexcept;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference front() noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference front() const noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference back() noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference back() const noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_type* data() noexcept
        {return std::__2::__to_address(this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const value_type* data() const noexcept
        {return std::__2::__to_address(this->__begin_);}





    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __emplace_back(_Arg&& __arg) {
      emplace_back(std::__2::forward<_Arg>(__arg));
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void push_back(const_reference __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void push_back(value_type&& __x);

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))



        void emplace_back(_Args&&... __args);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);


    iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);


    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)



        noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);



    bool __invariants() const;
# 801 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __invalidate_iterators_past(pointer __new_last);
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __make_iter(pointer __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator __make_iter(const_pointer __p) const noexcept;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        __invalidate_iterators_past(__new_last);
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }


    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    inline void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    inline void __emplace_back_slow_path(_Args&&... __args);
# 867 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __annotate_contiguous_container(const void*, const void*, const void*,
                                         const void*) const noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __annotate_new(size_type __current_size) const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __annotate_delete() const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __annotate_increase(size_type __n) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __annotate_shrink(size_type __old_size) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }

  struct _ConstructTransaction {
    explicit _ConstructTransaction(vector &__v, size_type __n)
      : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {



    }
    ~_ConstructTransaction() {
      __v_.__end_ = __pos_;





    }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class ..._Args>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  void __construct_one_at_end(_Args&& ...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__2::__to_address(__tx.__pos_),
        std::__2::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }
};
# 948 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{

    __annotate_delete();
    std::__2::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__2::swap(this->__begin_, __v.__begin_);
    std::__2::swap(this->__end_, __v.__end_);
    std::__2::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    std::__2::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, __p, __v.__begin_);
    std::__2::__construct_forward_with_exception_guarantees(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__2::swap(this->__begin_, __v.__begin_);
    std::__2::swap(this->__end_, __v.__end_);
    std::__2::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}
# 987 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::__2::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__2::max<size_type>(2*__cap, __new_size);
}






template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__2::__to_address(__pos));
    }
}







template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__2::__to_address(__pos), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    std::__2::__construct_range_forward(this->__alloc(), __first, __last, __tx.__pos_);
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}
# 1147 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(vector&& __x)



        noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __base(std::__2::move(__x.__alloc()))
{




    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __base::__move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __new_size = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__new_size <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (__new_size > size())
        {
            __growing = true;
            __mid = __first;
            std::__2::advance(__mid, size());
        }
        pointer __m = std::__2::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last, __new_size - size());
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__2::fill_n(this->__begin_, std::__2::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {




            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);






    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__2::__to_address(__v.__end_), std::__2::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __construct_one_at_end(__x);
    }
    else
        __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__2::move(__x));
    }
    else
        __push_back_slow_path(std::__2::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__2::__to_address(__v.__end_), std::__2::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline



void

vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__2::forward<_Args>(__args)...);
    }
    else
        __emplace_back_slow_path(std::__2::forward<_Args>(__args)...);



}



template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::__2::move(__p + 1, this->__end_, __p));
    this->__invalidate_iterators_past(__p-1);
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
# 1736 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::__2::move(__p + (__last - __first), this->__end_, __p));
        this->__invalidate_iterators_past(__p - 1);
    }
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    {
      pointer __i = __from_s + __n;
      _ConstructTransaction __tx(*this, __from_e - __i);
      for (pointer __pos = __tx.__pos_; __i < __from_e;
           ++__i, ++__pos, __tx.__pos_ = __pos) {
          __alloc_traits::construct(this->__alloc(),
                                    std::__2::__to_address(__pos),
                                    std::__2::move(*__i));
      }
    }
    std::__2::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(__x);
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__2::move(__x));
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__2::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::__2::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__2::forward<_Args>(__args)...);
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__2::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__2::move(__tmp.get());
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::__2::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__2::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __construct_one_at_end(*__first);
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {




            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;
# 1959 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
    }
    __p = std::__2::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), std::__2::make_move_iterator(__v.begin()),
                             std::__2::make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__2::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::__2::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                std::__2::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
    ((void)0);



    std::__2::swap(this->__begin_, __x.__begin_);
    std::__2::swap(this->__end_, __x.__end_);
    std::__2::swap(this->__end_cap(), __x.__end_cap());
    std::__2::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2119 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2147 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
  ((void)__new_last);

}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value);



    ~vector();
    explicit vector(size_type __n);



    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);


    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector(vector&& __v)



        noexcept(is_nothrow_move_constructible<allocator_type>::value);

    vector(vector&& __v, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value &&
           !__is_cpp17_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept
        {return __size_;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference front() {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);
# 2380 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void pop_back() {--__size_;}







    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__size_ = 0;}

    void swap(vector&)



        noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);


    static void swap(reference __x, reference __y) noexcept { std::__2::swap(__x, __y); }

    void resize(size_type __sz, value_type __x = false);
    void flip() noexcept;

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __invalidate_all_iterators();
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    static size_type __align_it(size_type __new_size) noexcept
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reference __make_ref(size_type __pos) const noexcept
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                __vdeallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__2::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}
# 2528 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__2::max(2*__cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__2::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__2::distance(__first, __last);
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__2::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<bool, _Allocator>::vector(const allocator_type& __a)

        noexcept(is_nothrow_copy_constructible<allocator_type>::value)



    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}
# 2673 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2724 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2751 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__2::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}



template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                __vdeallocate();
                __vallocate(__v.__size_);
            }
            std::__2::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}



template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) vector<bool, _Allocator>::vector(vector&& __v)



    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::__2::move(__v.__cap_alloc_)) {
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__2::fill_n(begin(), __n, __x);
    }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::__2::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            __vdeallocate();
            __vallocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.__vallocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {




            vector(*this, allocator_type(__alloc())).swap(*this);






    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__2::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__2::copy(cbegin(), __position, __v.begin());
        std::__2::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__2::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__2::copy(cbegin(), __position, __v.begin());
        std::__2::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__2::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {




            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;
# 3160 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
    }
    __p = std::__2::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::__2::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__2::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__2::copy(cbegin(), __position, __v.begin());
        std::__2::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__2::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__2::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__2::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
    std::__2::swap(this->__begin_, __x.__begin_);
    std::__2::swap(this->__size_, __x.__size_);
    std::__2::swap(this->__cap(), __x.__cap());
    std::__2::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__2::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__2::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() noexcept
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__2::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__2::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 3410 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\vector" 3
} }
# 44 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 1 3
# 429 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 1 3
# 21 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 25 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 2 3


namespace std { inline namespace __2 {
# 36 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
# 76 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
__tree_is_left_child(_NodePtr __x) noexcept
{
    return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == nullptr)
        return 1;


    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
        return 0;

    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
        return 0;

    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
        return 0;

    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = std::__2::__tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0;
    if (__h != std::__2::__tree_sub_invariant(__x->__right_))
        return 0;
    return __h + __x->__is_black_;
}




template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == nullptr)
        return true;

    if (__root->__parent_ == nullptr)
        return false;
    if (!std::__2::__tree_is_left_child(__root))
        return false;

    if (!__root->__is_black_)
        return false;

    return std::__2::__tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_NodePtr
__tree_min(_NodePtr __x) noexcept
{
    while (__x->__left_ != nullptr)
        __x = __x->__left_;
    return __x;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_NodePtr
__tree_max(_NodePtr __x) noexcept
{
    while (__x->__right_ != nullptr)
        __x = __x->__right_;
    return __x;
}



template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return std::__2::__tree_min(__x->__right_);
    while (!std::__2::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return static_cast<_EndNodePtr>(std::__2::__tree_min(__x->__right_));
    while (!std::__2::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return static_cast<_EndNodePtr>(__x->__parent_);
}




template <class _NodePtr, class _EndNodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept
{
    if (__x->__left_ != nullptr)
        return std::__2::__tree_max(__x->__left_);
    _NodePtr __xx = static_cast<_NodePtr>(__x);
    while (std::__2::__tree_is_left_child(__xx))
        __xx = __xx->__parent_unsafe();
    return __xx->__parent_unsafe();
}



template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) noexcept
{
    while (true)
    {
        if (__x->__left_ != nullptr)
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != nullptr)
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}




template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != nullptr)
        __x->__right_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__2::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __x;
    __x->__set_parent(__y);
}




template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != nullptr)
        __x->__left_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__2::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__right_ = __x;
    __x->__set_parent(__y);
}
# 276 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_unsafe()->__is_black_)
    {

        if (std::__2::__tree_is_left_child(__x->__parent_unsafe()))
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!std::__2::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__2::__tree_left_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__2::__tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (std::__2::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__2::__tree_right_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__2::__tree_left_rotate(__x);
                break;
            }
        }
    }
}
# 346 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) noexcept
{




    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?
                    __z : std::__2::__tree_next(__z);

    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

    _NodePtr __w = nullptr;

    if (__x != nullptr)
        __x->__parent_ = __y->__parent_;
    if (std::__2::__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_unsafe()->__right_;
        else
            __root = __x;
    }
    else
    {
        __y->__parent_unsafe()->__right_ = __x;

        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;


    if (__y != __z)
    {

        __y->__parent_ = __z->__parent_;
        if (std::__2::__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__set_parent(__y);
        __y->__right_ = __z->__right_;
        if (__y->__right_ != nullptr)
            __y->__right_->__set_parent(__y);
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }


    if (__removed_black && __root != nullptr)
    {
# 413 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
        if (__x != nullptr)
            __x->__is_black_ = true;
        else
        {





            while (true)
            {
                if (!std::__2::__tree_is_left_child(__w))
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__2::__tree_left_rotate(__w->__parent_unsafe());


                        if (__root == __w->__left_)
                            __root = __w;

                        __w = __w->__left_->__right_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__2::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)
                        {

                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__2::__tree_right_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        std::__2::__tree_left_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__2::__tree_right_rotate(__w->__parent_unsafe());


                        if (__root == __w->__right_)
                            __root = __w;

                        __w = __w->__right_->__left_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__2::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)
                        {

                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__2::__tree_left_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        std::__2::__tree_right_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
            }
        }
    }
}




template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};

template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__2::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__2::move(__v);
  }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static key_type const&
  __get_key(__node_value_type const& __t) {
    return __t.__get_value().first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      key_type const&>::type
  __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static __container_value_type const&
  __get_value(__node_value_type const& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__2::addressof(__n.__get_value());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;

  typedef __end_node_pointer __parent_pointer;







private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;

  typedef typename __base::__end_node_pointer __iter_pointer;






private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __set_parent(pointer __p) {
        __parent_ = static_cast<__parent_pointer>(__p);
    }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;

    __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};


template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;


public:
    bool __value_constructed;


    __tree_node_destructor(const __tree_node_destructor &) = default;
    __tree_node_destructor& operator=(const __tree_node_destructor&) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
        : __na_(__na),
          __value_constructed(__val)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};
# 809 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __tree_iterator() noexcept



    {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__2::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__2::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __tree_const_iterator() noexcept



    {}

private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_const_iterator(__non_const_iterator __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_const_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__2::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_const_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__2::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __tree_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __tree_const_iterator(__end_node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

};

template<class _Tp, class _Compare>

    __attribute__((diagnose_if(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;

    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;

    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;

    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iter_pointer __end_node() noexcept
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iter_pointer __end_node() const noexcept
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          __node_allocator& __node_alloc() noexcept {return __pair1_.second();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const __node_allocator& __node_alloc() const noexcept
        {return __pair1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          __iter_pointer& __begin_node() noexcept {return __begin_node_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const __iter_pointer& __begin_node() const noexcept {return __begin_node_;}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type __alloc() const noexcept
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          size_type& size() noexcept {return __pair3_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const size_type& size() const noexcept {return __pair3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          value_compare& value_comp() noexcept {return __pair3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const value_compare& value_comp() const noexcept
        {return __pair3_.second();}
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __node_pointer __root() const noexcept
        {return static_cast<__node_pointer>(__end_node()->__left_);}

    __node_base_pointer* __root_ptr() const noexcept {
        return std::__2::addressof(__end_node()->__left_);
    }

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value);


    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _ForwardIterator>
        void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
    __tree(__tree&& __t)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value);


    __tree(__tree&& __t, const allocator_type& __a);
    __tree& operator=(__tree&& __t)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);



    ~__tree();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator begin() noexcept {return iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return const_iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator end() noexcept {return iterator(__end_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return const_iterator(__end_node());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept
        {return std::__2::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type >::max());}

    void clear() noexcept;

    void swap(__tree& __t)

        noexcept(__is_nothrow_swappable<value_compare>::value && (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__node_allocator>::value));
# 1140 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_unique_key_args(_Key const&, _Args&&... __args);
    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

    template <class... _Args>
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

    template <class... _Args>
    iterator __emplace_multi(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
        return __emplace_unique_extract_key(std::__2::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__2::forward<_First>(__f),
                                              std::__2::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
        return __emplace_unique_impl(std::__2::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__2::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__2::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__2::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_unique_extract_key(__p, std::__2::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        iterator
    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
        return __emplace_hint_unique_key_args(__p, __f,
                                              std::__2::forward<_First>(__f),
                                              std::__2::forward<_Second>(__s)).first;
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
        return __emplace_hint_unique_impl(__p, std::__2::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
      return __emplace_hint_unique_impl(__p, std::__2::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
      return __emplace_hint_unique_key_args(__p, __x, std::__2::forward<_Pp>(__x)).first;
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
      return __emplace_hint_unique_key_args(__p, __x.first, std::__2::forward<_Pp>(__x)).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::__2::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::__2::move(__v)).first;
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __insert_unique(_Vp&& __v) {
        return __emplace_unique(std::__2::forward<_Vp>(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_unique(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_unique(__p, std::__2::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_multi(__container_value_type&& __v) {
        return __emplace_multi(std::__2::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_multi(__p, std::__2::move(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_multi(_Vp&& __v) {
        return __emplace_multi(std::__2::forward<_Vp>(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __insert_multi(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_multi(__p, std::__2::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> __node_assign_unique(const __container_value_type& __v, __node_pointer __dest);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator
    __remove_node_pointer(__node_pointer) noexcept;
# 1352 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__parent_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node) noexcept;

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) noexcept;
private:
    __node_base_pointer&
        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf(const_iterator __hint,
                    __parent_pointer& __parent, const key_type& __v);


    template <class _Key>
    __node_base_pointer&
        __find_equal(__parent_pointer& __parent, const _Key& __v);
    template <class _Key>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __node_base_pointer&
    __find_equal(__parent_pointer& __parent, const _Key& __v) const {
      return const_cast<__tree*>(this)->__find_equal(__parent, __v);
    }
    template <class _Key>
    __node_base_pointer&
        __find_equal(const_iterator __hint, __parent_pointer& __parent,
                     __node_base_pointer& __dummy,
                     const _Key& __v);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    void destroy(__node_pointer __nd) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {
        if (__node_alloc() != __t.__node_alloc())
            clear();
        __node_alloc() = __t.__node_alloc();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __copy_assign_alloc(const __tree&, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree& __t)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__node_alloc() = std::__2::move(__t.__node_alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __move_assign_alloc(__tree&, false_type) noexcept {}

    struct _DetachedTreeCache {
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      explicit _DetachedTreeCache(__tree *__t) noexcept : __t_(__t),
        __cache_root_(__detach_from_tree(__t)) {
          __advance();
        }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      __node_pointer __get() const noexcept {
        return __cache_elem_;
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      void __advance() noexcept {
        __cache_elem_ = __cache_root_;
        if (__cache_root_) {
          __cache_root_ = __detach_next(__cache_root_);
        }
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      ~_DetachedTreeCache() {
        __t_->destroy(__cache_elem_);
        if (__cache_root_) {
          while (__cache_root_->__parent_ != nullptr)
            __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
          __t_->destroy(__cache_root_);
        }
      }

       _DetachedTreeCache(_DetachedTreeCache const&) = delete;
       _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

    private:
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      static __node_pointer __detach_from_tree(__tree *__t) noexcept;
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
      static __node_pointer __detach_next(__node_pointer) noexcept;

      __tree *__t_;
      __node_pointer __cache_root_;
      __node_pointer __cache_elem_;
    };


    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value)


    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree *__t) noexcept
{
    __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
    __t->__begin_node() = __t->__end_node();
    __t->__end_node()->__left_->__parent_ = nullptr;
    __t->__end_node()->__left_ = nullptr;
    __t->size() = 0;

    if (__cache->__right_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__right_);


    return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) noexcept
{
    if (__cache->__parent_ == nullptr)
        return nullptr;
    if (std::__2::__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == nullptr)
            return __cache;
        return static_cast<__node_pointer>(std::__2::__tree_leaf(__cache->__right_));
    }

    __cache->__parent_unsafe()->__right_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == nullptr)
        return __cache;
    return static_cast<__node_pointer>(std::__2::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef iterator_traits<_ForwardIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "__assign_unique requires a forward iterator");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
          for (; __cache.__get() != nullptr && __first != __last; ++__first) {
              if (__node_assign_unique(*__first, __cache.__get()).second)
                  __cache.__advance();
            }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
        for (; __cache.__get() && __first != __last; ++__first) {
            __cache.__get()->__value_ = *__first;
            __node_insert_multi(__cache.__get());
            __cache.__advance();
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value)


    : __begin_node_(std::__2::move(__t.__begin_node_)),
      __pair1_(std::__2::move(__t.__pair1_)),
      __pair3_(std::__2::move(__t.__pair3_))
{
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::__2::move(__t.value_comp()))
{
    if (__a == __t.__alloc())
    {
        if (__t.size() == 0)
            __begin_node() = __end_node();
        else
        {
            __begin_node() = __t.__begin_node();
            __end_node()->__left_ = __t.__end_node()->__left_;
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            size() = __t.size();
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = nullptr;
            __t.size() = 0;
        }
    }
    else
    {
        __begin_node() = __end_node();
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)

{
    destroy(static_cast<__node_pointer>(__end_node()->__left_));
    __begin_node_ = __t.__begin_node_;
    __pair1_.first() = __t.__pair1_.first();
    __move_assign_alloc(__t);
    __pair3_ = std::__2::move(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)
{
    if (__node_alloc() == __t.__node_alloc())
        __move_assign(__t, true_type());
    else
    {
        value_comp() = std::__2::move(__t.value_comp());
        const_iterator __e = end();
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            while (__cache.__get() != nullptr && __t.size() != 0) {
              __cache.__get()->__value_ = std::__2::move(__t.remove(__t.begin())->__value_);
              __node_insert_multi(__cache.__get());
              __cache.__advance();
            }
        }
        while (__t.size() != 0)
            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)




{
    __move_assign(__t, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)

        noexcept(__is_nothrow_swappable<value_compare>::value && (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__node_allocator>::value))







{
    using std::__2::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    std::__2::__swap_allocator(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() noexcept
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,
                                                   const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,
                                                    const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer& __parent,
                                               const key_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_leaf_high(__parent, __v);
    }

    return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    __node_base_pointer* __nd_ptr = __root_ptr();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr) {
                    __nd_ptr = std::__2::addressof(__nd->__left_);
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr) {
                    __nd_ptr = std::__2::addressof(__nd->__right_);
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__nd);
                return *__nd_ptr;
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}
# 2013 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer& __parent,
                                                __node_base_pointer& __dummy,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v))
    {

        const_iterator __next = std::__2::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {

            if (__hint.__get_np()->__right_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }

        return __find_equal(__parent, __v);
    }

    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer& __child,
    __node_base_pointer __new_node) noexcept
{
    __new_node->__left_ = nullptr;
    __new_node->__right_ = nullptr;
    __new_node->__parent_ = __parent;

    __child = __new_node;
    if (__begin_node()->__left_ != nullptr)
        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
    std::__2::__tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class ..._Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_tree_value_type<_Args...>::value,
                  "Cannot construct from __value_type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__2::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    return __h;
}


template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__2::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type& __v, __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__v));
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __nd->__value_ = __v;
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) noexcept
{
    iterator __r(__ptr);
    ++__r;
    if (__begin_node() == __ptr)
        __begin_node() = __r.__ptr_;
    --size();
    std::__2::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__ptr));
    return __r;
}
# 2415 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__tree" 3
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    iterator __r = __remove_node_pointer(__np);
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(
        const_cast<__node_value_type&>(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return std::__2::distance(
                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__2::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__2::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept
{
    __node_pointer __np = __p.__get_np();
    if (__begin_node() == __p.__ptr_)
    {
        if (__np->__right_ != nullptr)
            __begin_node() = static_cast<__iter_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
    }
    --size();
    std::__2::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 430 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 1 3
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\optional" 1 3
# 163 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\optional" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 167 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\optional" 2 3


namespace std
{

class __attribute__ ((__visibility__("default"))) bad_optional_access
    : public exception
{
public:

    virtual ~bad_optional_access() noexcept;
    virtual const char* what() const noexcept;
};

}
# 16 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 2 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 2 3

namespace std { inline namespace __2 {
# 205 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__node_handle" 3
} }
# 431 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 2 3
# 436 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3


namespace std { inline namespace __2 {

template <class _Key, class _Compare, class _Allocator>
class multiset;

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) set
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;






    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit set(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit set(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        set(_InputIterator __f, _InputIterator __l,
            const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,
            const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }
# 530 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set(const set& __s)
        : __tree_(__s.__tree_)
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set& operator=(const set& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set(set&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__2::move(__s.__tree_)) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit set(const allocator_type& __a)
        : __tree_(__a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set(const set& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    set(set&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    set& operator=(set&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__2::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~set() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __tree_.__emplace_unique(std::__2::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_unique(__p, std::__2::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,bool> insert(const value_type& __v)
        {return __tree_.__insert_unique(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_unique(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_unique(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,bool> insert(value_type&& __v)
        {return __tree_.__insert_unique(std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_unique(__p, std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}
# 758 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(set& __s) noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 785 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}
# 800 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}
# 818 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}
# 835 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}
# 851 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
};
# 883 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)
    : __tree_(std::__2::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__2::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__2::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return std::__2::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(set<_Key, _Compare, _Allocator>& __x,
     set<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 971 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) multiset
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;





    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multiset(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multiset(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }
# 1049 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset(const multiset& __s)
        : __tree_(__s.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset& operator=(const multiset& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset(multiset&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__2::move(__s.__tree_)) {}

    multiset(multiset&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multiset(const allocator_type& __a)
        : __tree_(__a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset(const multiset& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multiset& operator=(multiset&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__2::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~multiset() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator emplace(_Args&&... __args)
            {return __tree_.__emplace_multi(std::__2::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_multi(__p, std::__2::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const value_type& __v)
        {return __tree_.__insert_multi(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_multi(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p, std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}
# 1284 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(multiset& __s)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 1312 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}
# 1327 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}
# 1345 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}
# 1362 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}
# 1378 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
};
# 1410 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)
    : __tree_(std::__2::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__2::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__2::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return std::__2::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(multiset<_Key, _Compare, _Allocator>& __x,
     multiset<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1497 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\set" 3
} }
# 45 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h" 2
# 150 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
namespace flatbuffers {

  const char* FLATBUFFERS_VERSION();
}
# 279 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
template<typename T> constexpr inline bool IsConstTrue(T t) {
  return !!t;
}
# 305 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
namespace flatbuffers {





typedef uint32_t uoffset_t;


typedef int32_t soffset_t;



typedef uint16_t voffset_t;

typedef uintmax_t largest_scalar_t;
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
template<typename T> T EndianSwap(T t) {
# 355 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
  if (sizeof(T) == 1) {
    return t;
  } else if (sizeof(T) == 2) {
    union { T t; uint16_t i; } u = { t };
    u.i = __builtin_bswap16(u.i);
    return u.t;
  } else if (sizeof(T) == 4) {
    union { T t; uint32_t i; } u = { t };
    u.i = __builtin_bswap32(u.i);
    return u.t;
  } else if (sizeof(T) == 8) {
    union { T t; uint64_t i; } u = { t };
    u.i = __builtin_bswap64(u.i);
    return u.t;
  } else {
    ((0) ? (void)0 : ::std:: __aeabi_assert("0", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h", 370),
# 370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
#pragma clang diagnostic push
# 370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
#pragma clang diagnostic ignored "-Wassume"
# 370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
 (__builtin_assume)((0)?1:0)
# 370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
#pragma clang diagnostic pop
# 370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
);
    return t;
  }
}






template<typename T> T EndianScalar(T t) {

    return t;



}

template<typename T>

__attribute__((no_sanitize("alignment")))
T ReadScalar(const void *p) {
  return EndianScalar(*reinterpret_cast<const T *>(p));
}
# 402 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
template<typename T>

__attribute__((no_sanitize("alignment")))
void WriteScalar(void *p, T t) {
  *reinterpret_cast<T *>(p) = EndianScalar(t);
}

template<typename T> struct Offset;
template<typename T> __attribute__((no_sanitize("alignment"))) void WriteScalar(void *p, Offset<T> t) {
  *reinterpret_cast<uoffset_t *>(p) = EndianScalar(t.o);
}
# 421 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/base.h"
__attribute__((no_sanitize("unsigned-integer-overflow")))
inline size_t PaddingBytes(size_t buf_size, size_t scalar_size) {
  return ((~buf_size) + 1) & (scalar_size - 1);
}

}
# 21 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h" 2
# 1 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h" 1
# 51 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
namespace flatbuffers {



inline char& string_back(std::string &value) {
  return value[value.length() - 1];
}

inline char string_back(const std::string &value) {
  return value[value.length() - 1];
}



template <typename T> inline T *vector_data(std::vector<T> &vector) {


  return vector.empty() ? nullptr : &vector[0];
}

template <typename T> inline const T *vector_data(
    const std::vector<T> &vector) {
  return vector.empty() ? nullptr : &vector[0];
}

template <typename T, typename V>
inline void vector_emplace_back(std::vector<T> *vector, V &&data) {



    vector->emplace_back(std::forward<V>(data));

}



    template <typename T>
    using numeric_limits = std::numeric_limits<T>;
# 141 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
    template <typename T> using is_scalar = std::is_scalar<T>;
    template <typename T, typename U> using is_same = std::is_same<T,U>;
    template <typename T> using is_floating_point = std::is_floating_point<T>;
    template <typename T> using is_unsigned = std::is_unsigned<T>;
    template <typename T> using is_enum = std::is_enum<T>;
    template <typename T> using make_unsigned = std::make_unsigned<T>;
    template<bool B, class T, class F>
    using conditional = std::conditional<B, T, F>;
    template<class T, T v>
    using integral_constant = std::integral_constant<T, v>;
# 192 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
    template <class T> using unique_ptr = std::unique_ptr<T>;
# 321 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
struct nullopt_t {
  explicit constexpr nullopt_t(int) {}
};


  namespace internal {
    template <class> struct nullopt_holder {
      static constexpr nullopt_t instance_ = nullopt_t(0);
    };
    template<class Dummy>
    constexpr nullopt_t nullopt_holder<Dummy>::instance_;
  }
  static constexpr const nullopt_t &nullopt = internal::nullopt_holder<void>::instance_;
# 347 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
template<class T>
class Optional final {



  static_assert(flatbuffers::is_scalar<T>::value, "unexpected type T");

 public:
  ~Optional() {}

  constexpr Optional() noexcept
    : value_(), has_value_(false) {}

  constexpr Optional(nullopt_t) noexcept
    : value_(), has_value_(false) {}

  constexpr Optional(T val) noexcept
    : value_(val), has_value_(true) {}

  constexpr Optional(const Optional &other) noexcept
    : value_(other.value_), has_value_(other.has_value_) {}

                              Optional &operator=(const Optional &other) noexcept {
    value_ = other.value_;
    has_value_ = other.has_value_;
    return *this;
  }

                              Optional &operator=(nullopt_t) noexcept {
    value_ = T();
    has_value_ = false;
    return *this;
  }

                              Optional &operator=(T val) noexcept {
    value_ = val;
    has_value_ = true;
    return *this;
  }

  void reset() noexcept {
    *this = nullopt;
  }

  void swap(Optional &other) noexcept {
    std::swap(value_, other.value_);
    std::swap(has_value_, other.has_value_);
  }

  constexpr explicit operator bool() const noexcept {
    return has_value_;
  }

  constexpr bool has_value() const noexcept {
    return has_value_;
  }

  constexpr const T& operator*() const noexcept {
    return value_;
  }

  const T& value() const {
    ((has_value()) ? (void)0 : ::std:: __aeabi_assert("has_value()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h", 409),
# 409 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
#pragma clang diagnostic push
# 409 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
#pragma clang diagnostic ignored "-Wassume"
# 409 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
 (__builtin_assume)((has_value())?1:0)
# 409 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
#pragma clang diagnostic pop
# 409 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/stl_emulation.h"
);
    return value_;
  }

  T value_or(T default_value) const noexcept {
    return has_value() ? value_ : default_value;
  }

 private:
  T value_;
  bool has_value_;
};

template<class T>
constexpr bool operator==(const Optional<T>& opt, nullopt_t) noexcept {
  return !opt;
}
template<class T>
constexpr bool operator==(nullopt_t, const Optional<T>& opt) noexcept {
  return !opt;
}

template<class T, class U>
constexpr bool operator==(const Optional<T>& lhs, const U& rhs) noexcept {
  return static_cast<bool>(lhs) && (*lhs == rhs);
}

template<class T, class U>
constexpr bool operator==(const T& lhs, const Optional<U>& rhs) noexcept {
  return static_cast<bool>(rhs) && (lhs == *rhs);
}

template<class T, class U>
constexpr bool operator==(const Optional<T>& lhs, const Optional<U>& rhs) noexcept {
  return static_cast<bool>(lhs) != static_cast<bool>(rhs)
              ? false
              : !static_cast<bool>(lhs) ? false : (*lhs == *rhs);
}


}
# 22 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h" 2
# 31 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
namespace flatbuffers {



template<typename T> inline bool IsTheSameAs(T e, T def) { return e == def; }
# 54 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
template<typename T>
inline bool IsOutRange(const T &v, const T &low, const T &high) {
  return (v < low) || (high < v);
}


template<typename T>
inline bool IsInRange(const T &v, const T &low, const T &high) {
  return !IsOutRange(v, low, high);
}



template<typename T> struct Offset {
  uoffset_t o;
  Offset() : o(0) {}
  Offset(uoffset_t _o) : o(_o) {}
  Offset<void> Union() const { return Offset<void>(o); }
  bool IsNull() const { return !o; }
};

inline void EndianCheck() {
  int endiantest = 1;

  ((*reinterpret_cast<char *>(&endiantest) == 1) ? (void)0 : ::std:: __aeabi_assert("*reinterpret_cast<char *>(&endiantest) == FLATBUFFERS_LITTLEENDIAN", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 79),
# 78 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 78 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 78 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((*reinterpret_cast<char *>(&endiantest) == 1)?1:0)
# 78 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 78 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);

  (void)endiantest;
}

template<typename T> constexpr size_t AlignOf() {





      return __alignof__(T);





}
# 105 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
template<typename T> struct IndirectHelper {
  typedef T return_type;
  typedef T mutable_return_type;
  static const size_t element_stride = sizeof(T);
  static return_type Read(const uint8_t *p, uoffset_t i) {
    return EndianScalar((reinterpret_cast<const T *>(p))[i]);
  }
};
template<typename T> struct IndirectHelper<Offset<T>> {
  typedef const T *return_type;
  typedef T *mutable_return_type;
  static const size_t element_stride = sizeof(uoffset_t);
  static return_type Read(const uint8_t *p, uoffset_t i) {
    p += i * sizeof(uoffset_t);
    return reinterpret_cast<return_type>(p + ReadScalar<uoffset_t>(p));
  }
};
template<typename T> struct IndirectHelper<const T *> {
  typedef const T *return_type;
  typedef T *mutable_return_type;
  static const size_t element_stride = sizeof(T);
  static return_type Read(const uint8_t *p, uoffset_t i) {
    return reinterpret_cast<const T *>(p + i * sizeof(T));
  }
};



template<typename T, typename IT> struct VectorIterator {
  typedef std::random_access_iterator_tag iterator_category;
  typedef IT value_type;
  typedef ptrdiff_t difference_type;
  typedef IT *pointer;
  typedef IT &reference;

  VectorIterator(const uint8_t *data, uoffset_t i)
      : data_(data + IndirectHelper<T>::element_stride * i) {}
  VectorIterator(const VectorIterator &other) : data_(other.data_) {}
  VectorIterator() : data_(nullptr) {}

  VectorIterator &operator=(const VectorIterator &other) {
    data_ = other.data_;
    return *this;
  }



  VectorIterator &operator=(VectorIterator &&other) {
    data_ = other.data_;
    return *this;
  }



  bool operator==(const VectorIterator &other) const {
    return data_ == other.data_;
  }

  bool operator<(const VectorIterator &other) const {
    return data_ < other.data_;
  }

  bool operator!=(const VectorIterator &other) const {
    return data_ != other.data_;
  }

  difference_type operator-(const VectorIterator &other) const {
    return (data_ - other.data_) / IndirectHelper<T>::element_stride;
  }

  IT operator*() const { return IndirectHelper<T>::Read(data_, 0); }

  IT operator->() const { return IndirectHelper<T>::Read(data_, 0); }

  VectorIterator &operator++() {
    data_ += IndirectHelper<T>::element_stride;
    return *this;
  }

  VectorIterator operator++(int) {
    VectorIterator temp(data_, 0);
    data_ += IndirectHelper<T>::element_stride;
    return temp;
  }

  VectorIterator operator+(const uoffset_t &offset) const {
    return VectorIterator(data_ + offset * IndirectHelper<T>::element_stride,
                          0);
  }

  VectorIterator &operator+=(const uoffset_t &offset) {
    data_ += offset * IndirectHelper<T>::element_stride;
    return *this;
  }

  VectorIterator &operator--() {
    data_ -= IndirectHelper<T>::element_stride;
    return *this;
  }

  VectorIterator operator--(int) {
    VectorIterator temp(data_, 0);
    data_ -= IndirectHelper<T>::element_stride;
    return temp;
  }

  VectorIterator operator-(const uoffset_t &offset) const {
    return VectorIterator(data_ - offset * IndirectHelper<T>::element_stride,
                          0);
  }

  VectorIterator &operator-=(const uoffset_t &offset) {
    data_ -= offset * IndirectHelper<T>::element_stride;
    return *this;
  }

 private:
  const uint8_t *data_;
};

template<typename Iterator>
struct VectorReverseIterator : public std::reverse_iterator<Iterator> {
  explicit VectorReverseIterator(Iterator iter)
      : std::reverse_iterator<Iterator>(iter) {}

  typename Iterator::value_type operator*() const {
    return *(std::reverse_iterator<Iterator>::current);
  }

  typename Iterator::value_type operator->() const {
    return *(std::reverse_iterator<Iterator>::current);
  }
};

struct String;



template<typename T> class Vector {
 public:
  typedef VectorIterator<T, typename IndirectHelper<T>::mutable_return_type>
      iterator;
  typedef VectorIterator<T, typename IndirectHelper<T>::return_type>
      const_iterator;
  typedef VectorReverseIterator<iterator> reverse_iterator;
  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;

  uoffset_t size() const { return EndianScalar(length_); }



  uoffset_t Length() const { return size(); }

  typedef typename IndirectHelper<T>::return_type return_type;
  typedef typename IndirectHelper<T>::mutable_return_type mutable_return_type;

  return_type Get(uoffset_t i) const {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 262),
# 262 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 262 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 262 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 262 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 262 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return IndirectHelper<T>::Read(Data(), i);
  }

  return_type operator[](uoffset_t i) const { return Get(i); }




  template<typename E> E GetEnum(uoffset_t i) const {
    return static_cast<E>(Get(i));
  }



  template<typename U> const U *GetAs(uoffset_t i) const {
    return reinterpret_cast<const U *>(Get(i));
  }



  const String *GetAsString(uoffset_t i) const {
    return reinterpret_cast<const String *>(Get(i));
  }

  const void *GetStructFromOffset(size_t o) const {
    return reinterpret_cast<const void *>(Data() + o);
  }

  iterator begin() { return iterator(Data(), 0); }
  const_iterator begin() const { return const_iterator(Data(), 0); }

  iterator end() { return iterator(Data(), size()); }
  const_iterator end() const { return const_iterator(Data(), size()); }

  reverse_iterator rbegin() { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end() - 1);
  }

  reverse_iterator rend() { return reverse_iterator(begin() - 1); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin() - 1);
  }

  const_iterator cbegin() const { return begin(); }

  const_iterator cend() const { return end(); }

  const_reverse_iterator crbegin() const { return rbegin(); }

  const_reverse_iterator crend() const { return rend(); }



  void Mutate(uoffset_t i, const T &val) {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 318),
# 318 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 318 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 318 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 318 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 318 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    WriteScalar(data() + i, val);
  }




  void MutateOffset(uoffset_t i, const uint8_t *val) {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 326),
# 326 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 326 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 326 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 326 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 326 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    static_assert(sizeof(T) == sizeof(uoffset_t), "Unrelated types");
    WriteScalar(data() + i,
                static_cast<uoffset_t>(val - (Data() + i * sizeof(uoffset_t))));
  }


  mutable_return_type GetMutableObject(uoffset_t i) const {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 334),
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 334 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return const_cast<mutable_return_type>(IndirectHelper<T>::Read(Data(), i));
  }


  const uint8_t *Data() const {
    return reinterpret_cast<const uint8_t *>(&length_ + 1);
  }

  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }


  const T *data() const { return reinterpret_cast<const T *>(Data()); }
  T *data() { return reinterpret_cast<T *>(Data()); }

  template<typename K> return_type LookupByKey(K key) const {
    void *search_result = std::bsearch(
        &key, Data(), size(), IndirectHelper<T>::element_stride, KeyCompare<K>);

    if (!search_result) {
      return nullptr;
    }

    const uint8_t *element = reinterpret_cast<const uint8_t *>(search_result);

    return IndirectHelper<T>::Read(element, 0);
  }

 protected:


  Vector();

  uoffset_t length_;

 private:


  Vector(const Vector &);
  Vector &operator=(const Vector &);

  template<typename K> static int KeyCompare(const void *ap, const void *bp) {
    const K *key = reinterpret_cast<const K *>(ap);
    const uint8_t *data = reinterpret_cast<const uint8_t *>(bp);
    auto table = IndirectHelper<T>::Read(data, 0);



    return -table->KeyCompareWithValue(*key);
  }
};



class VectorOfAny {
 public:
  uoffset_t size() const { return EndianScalar(length_); }

  const uint8_t *Data() const {
    return reinterpret_cast<const uint8_t *>(&length_ + 1);
  }
  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }

 protected:
  VectorOfAny();

  uoffset_t length_;

 private:
  VectorOfAny(const VectorOfAny &);
  VectorOfAny &operator=(const VectorOfAny &);
};


template<typename T, typename U>
Vector<Offset<T>> *VectorCast(Vector<Offset<U>> *ptr) {
  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
  return reinterpret_cast<Vector<Offset<T>> *>(ptr);
}

template<typename T, typename U>
const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
  return reinterpret_cast<const Vector<Offset<T>> *>(ptr);
}




template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
  return v ? v->size() : 0;
}


template<typename T, uint16_t length> class Array {
  typedef
      typename flatbuffers::integral_constant<bool,
                                              flatbuffers::is_scalar<T>::value>
          scalar_tag;
  typedef
      typename flatbuffers::conditional<scalar_tag::value, T, const T *>::type
          IndirectHelperType;

 public:
  typedef typename IndirectHelper<IndirectHelperType>::return_type return_type;
  typedef VectorIterator<T, return_type> const_iterator;
  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;

  constexpr uint16_t size() const { return length; }

  return_type Get(uoffset_t i) const {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 445),
# 445 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 445 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 445 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 445 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 445 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return IndirectHelper<IndirectHelperType>::Read(Data(), i);
  }

  return_type operator[](uoffset_t i) const { return Get(i); }




  template<typename E> E GetEnum(uoffset_t i) const {
    return static_cast<E>(Get(i));
  }

  const_iterator begin() const { return const_iterator(Data(), 0); }
  const_iterator end() const { return const_iterator(Data(), size()); }

  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const { return const_reverse_iterator(end()); }

  const_iterator cbegin() const { return begin(); }
  const_iterator cend() const { return end(); }

  const_reverse_iterator crbegin() const { return rbegin(); }
  const_reverse_iterator crend() const { return rend(); }






  typename flatbuffers::conditional<scalar_tag::value, void, T *>::type
  GetMutablePointer(uoffset_t i) const {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 479),
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return const_cast<T *>(&data()[i]);
  }


  void Mutate(uoffset_t i, const T &val) { MutateImpl(scalar_tag(), i, val); }


  const uint8_t *Data() const { return data_; }

  uint8_t *Data() { return data_; }


  const T *data() const { return reinterpret_cast<const T *>(Data()); }
  T *data() { return reinterpret_cast<T *>(Data()); }

 protected:
  void MutateImpl(flatbuffers::integral_constant<bool, true>, uoffset_t i,
                  const T &val) {
    ((i < size()) ? (void)0 : ::std:: __aeabi_assert("i < size()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 498),
# 498 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 498 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 498 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((i < size())?1:0)
# 498 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 498 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    WriteScalar(data() + i, val);
  }

  void MutateImpl(flatbuffers::integral_constant<bool, false>, uoffset_t i,
                  const T &val) {
    *(GetMutablePointer(i)) = val;
  }







  constexpr Array();




  uint8_t data_[length * sizeof(T)];

 private:


  Array(const Array &);
  Array &operator=(const Array &);
};



template<typename T, uint16_t length> class Array<Offset<T>, length> {
  static_assert(flatbuffers::is_same<T, void>::value, "unexpected type T");

 public:
  typedef const void *return_type;

  const uint8_t *Data() const { return data_; }


  return_type operator[](uoffset_t) const {
    ((false) ? (void)0 : ::std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 539),
# 539 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 539 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 539 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((false)?1:0)
# 539 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 539 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return nullptr;
  }

 private:

  Array();
  Array(const Array &);
  Array &operator=(const Array &);

  uint8_t data_[1];
};



static inline bool StringLessThan(const char *a_data, uoffset_t a_size,
                                  const char *b_data, uoffset_t b_size) {
  const auto cmp = memcmp(a_data, b_data, (std::min)(a_size, b_size));
  return cmp == 0 ? a_size < b_size : cmp < 0;
}

struct String : public Vector<char> {
  const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
  std::string str() const { return std::string(c_str(), size()); }
# 572 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  bool operator<(const String &o) const {
    return StringLessThan(this->data(), this->size(), o.data(), o.size());
  }
};



static inline std::string GetString(const String *str) {
  return str ? str->str() : "";
}



static inline const char *GetCstring(const String *str) {
  return str ? str->c_str() : "";
}
# 599 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
class Allocator {
 public:
  virtual ~Allocator() {}


  virtual uint8_t *allocate(size_t size) = 0;


  virtual void deallocate(uint8_t *p, size_t size) = 0;






  virtual uint8_t *reallocate_downward(uint8_t *old_p, size_t old_size,
                                       size_t new_size, size_t in_use_back,
                                       size_t in_use_front) {
    ((new_size > old_size) ? (void)0 : ::std:: __aeabi_assert("new_size > old_size", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 617),
# 617 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 617 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 617 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((new_size > old_size)?1:0)
# 617 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 617 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    uint8_t *new_p = allocate(new_size);
    memcpy_downward(old_p, old_size, new_p, new_size, in_use_back,
                    in_use_front);
    deallocate(old_p, old_size);
    return new_p;
  }

 protected:




  void memcpy_downward(uint8_t *old_p, size_t old_size, uint8_t *new_p,
                       size_t new_size, size_t in_use_back,
                       size_t in_use_front) {
    memcpy(new_p + new_size - in_use_back, old_p + old_size - in_use_back,
           in_use_back);
    memcpy(new_p, old_p, in_use_front);
  }
};


class DefaultAllocator : public Allocator {
 public:
  uint8_t *allocate(size_t size) override {
    return new uint8_t[size];
  }

  void deallocate(uint8_t *p, size_t) override { delete[] p; }

  static void dealloc(void *p, size_t) { delete[] static_cast<uint8_t *>(p); }
};





inline uint8_t *Allocate(Allocator *allocator, size_t size) {
  return allocator ? allocator->allocate(size)
                   : DefaultAllocator().allocate(size);
}

inline void Deallocate(Allocator *allocator, uint8_t *p, size_t size) {
  if (allocator)
    allocator->deallocate(p, size);
  else
    DefaultAllocator().deallocate(p, size);
}

inline uint8_t *ReallocateDownward(Allocator *allocator, uint8_t *old_p,
                                   size_t old_size, size_t new_size,
                                   size_t in_use_back, size_t in_use_front) {
  return allocator ? allocator->reallocate_downward(old_p, old_size, new_size,
                                                    in_use_back, in_use_front)
                   : DefaultAllocator().reallocate_downward(
                         old_p, old_size, new_size, in_use_back, in_use_front);
}




class DetachedBuffer {
 public:
  DetachedBuffer()
      : allocator_(nullptr),
        own_allocator_(false),
        buf_(nullptr),
        reserved_(0),
        cur_(nullptr),
        size_(0) {}

  DetachedBuffer(Allocator *allocator, bool own_allocator, uint8_t *buf,
                 size_t reserved, uint8_t *cur, size_t sz)
      : allocator_(allocator),
        own_allocator_(own_allocator),
        buf_(buf),
        reserved_(reserved),
        cur_(cur),
        size_(sz) {}




  DetachedBuffer(DetachedBuffer &&other)
      : allocator_(other.allocator_),
        own_allocator_(other.own_allocator_),
        buf_(other.buf_),
        reserved_(other.reserved_),
        cur_(other.cur_),
        size_(other.size_) {
    other.reset();
  }







  DetachedBuffer &operator=(DetachedBuffer &&other) {
    if (this == &other) return *this;

    destroy();

    allocator_ = other.allocator_;
    own_allocator_ = other.own_allocator_;
    buf_ = other.buf_;
    reserved_ = other.reserved_;
    cur_ = other.cur_;
    size_ = other.size_;

    other.reset();

    return *this;
  }




  ~DetachedBuffer() { destroy(); }

  const uint8_t *data() const { return cur_; }

  uint8_t *data() { return cur_; }

  size_t size() const { return size_; }
# 769 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  DetachedBuffer(const DetachedBuffer &other) = delete;
  DetachedBuffer &operator=(const DetachedBuffer &other) = delete;





 protected:
  Allocator *allocator_;
  bool own_allocator_;
  uint8_t *buf_;
  size_t reserved_;
  uint8_t *cur_;
  size_t size_;

  inline void destroy() {
    if (buf_) Deallocate(allocator_, buf_, reserved_);
    if (own_allocator_ && allocator_) { delete allocator_; }
    reset();
  }

  inline void reset() {
    allocator_ = nullptr;
    own_allocator_ = false;
    buf_ = nullptr;
    reserved_ = 0;
    cur_ = nullptr;
    size_ = 0;
  }
};







class vector_downward {
 public:
  explicit vector_downward(size_t initial_size, Allocator *allocator,
                           bool own_allocator, size_t buffer_minalign)
      : allocator_(allocator),
        own_allocator_(own_allocator),
        initial_size_(initial_size),
        buffer_minalign_(buffer_minalign),
        reserved_(0),
        buf_(nullptr),
        cur_(nullptr),
        scratch_(nullptr) {}



  vector_downward(vector_downward &&other)




      : allocator_(other.allocator_),
        own_allocator_(other.own_allocator_),
        initial_size_(other.initial_size_),
        buffer_minalign_(other.buffer_minalign_),
        reserved_(other.reserved_),
        buf_(other.buf_),
        cur_(other.cur_),
        scratch_(other.scratch_) {



    other.own_allocator_ = false;
    other.reserved_ = 0;
    other.buf_ = nullptr;
    other.cur_ = nullptr;
    other.scratch_ = nullptr;
  }




  vector_downward &operator=(vector_downward &&other) {

    vector_downward temp(std::move(other));
    swap(temp);
    return *this;
  }




  ~vector_downward() {
    clear_buffer();
    clear_allocator();
  }

  void reset() {
    clear_buffer();
    clear();
  }

  void clear() {
    if (buf_) {
      cur_ = buf_ + reserved_;
    } else {
      reserved_ = 0;
      cur_ = nullptr;
    }
    clear_scratch();
  }

  void clear_scratch() { scratch_ = buf_; }

  void clear_allocator() {
    if (own_allocator_ && allocator_) { delete allocator_; }
    allocator_ = nullptr;
    own_allocator_ = false;
  }

  void clear_buffer() {
    if (buf_) Deallocate(allocator_, buf_, reserved_);
    buf_ = nullptr;
  }


  uint8_t *release_raw(size_t &allocated_bytes, size_t &offset) {
    auto *buf = buf_;
    allocated_bytes = reserved_;
    offset = static_cast<size_t>(cur_ - buf_);



    buf_ = nullptr;
    clear();
    return buf;
  }


  DetachedBuffer release() {

    DetachedBuffer fb(allocator_, own_allocator_, buf_, reserved_, cur_,
                      size());
    if (own_allocator_) {
      allocator_ = nullptr;
      own_allocator_ = false;
    }
    buf_ = nullptr;
    clear();
    return fb;
  }

  size_t ensure_space(size_t len) {
    ((cur_ >= scratch_ && scratch_ >= buf_) ? (void)0 : ::std:: __aeabi_assert("cur_ >= scratch_ && scratch_ >= buf_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 918),
# 918 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 918 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 918 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((cur_ >= scratch_ && scratch_ >= buf_)?1:0)
# 918 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 918 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    if (len > static_cast<size_t>(cur_ - scratch_)) { reallocate(len); }


    ((size() < ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1)) ? (void)0 : ::std:: __aeabi_assert("size() < FLATBUFFERS_MAX_BUFFER_SIZE", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 922),
# 922 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 922 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 922 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((size() < ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1))?1:0)
# 922 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 922 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return len;
  }

  inline uint8_t *make_space(size_t len) {
    size_t space = ensure_space(len);
    cur_ -= space;
    return cur_;
  }


  Allocator *get_custom_allocator() { return allocator_; }

  uoffset_t size() const {
    return static_cast<uoffset_t>(reserved_ - (cur_ - buf_));
  }

  uoffset_t scratch_size() const {
    return static_cast<uoffset_t>(scratch_ - buf_);
  }

  size_t capacity() const { return reserved_; }

  uint8_t *data() const {
    ((cur_) ? (void)0 : ::std:: __aeabi_assert("cur_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 946),
# 946 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 946 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 946 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((cur_)?1:0)
# 946 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 946 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return cur_;
  }

  uint8_t *scratch_data() const {
    ((buf_) ? (void)0 : ::std:: __aeabi_assert("buf_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 951),
# 951 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 951 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 951 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((buf_)?1:0)
# 951 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 951 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return buf_;
  }

  uint8_t *scratch_end() const {
    ((scratch_) ? (void)0 : ::std:: __aeabi_assert("scratch_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 956),
# 956 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 956 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 956 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((scratch_)?1:0)
# 956 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 956 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return scratch_;
  }

  uint8_t *data_at(size_t offset) const { return buf_ + reserved_ - offset; }

  void push(const uint8_t *bytes, size_t num) {
    if (num > 0) { memcpy(make_space(num), bytes, num); }
  }


  template<typename T> void push_small(const T &little_endian_t) {
    make_space(sizeof(T));
    *reinterpret_cast<T *>(cur_) = little_endian_t;
  }

  template<typename T> void scratch_push_small(const T &t) {
    ensure_space(sizeof(T));
    *reinterpret_cast<T *>(scratch_) = t;
    scratch_ += sizeof(T);
  }



  void fill(size_t zero_pad_bytes) {
    make_space(zero_pad_bytes);
    for (size_t i = 0; i < zero_pad_bytes; i++) cur_[i] = 0;
  }



  void fill_big(size_t zero_pad_bytes) {
    memset(make_space(zero_pad_bytes), 0, zero_pad_bytes);
  }

  void pop(size_t bytes_to_remove) { cur_ += bytes_to_remove; }
  void scratch_pop(size_t bytes_to_remove) { scratch_ -= bytes_to_remove; }

  void swap(vector_downward &other) {
    using std::swap;
    swap(allocator_, other.allocator_);
    swap(own_allocator_, other.own_allocator_);
    swap(initial_size_, other.initial_size_);
    swap(buffer_minalign_, other.buffer_minalign_);
    swap(reserved_, other.reserved_);
    swap(buf_, other.buf_);
    swap(cur_, other.cur_);
    swap(scratch_, other.scratch_);
  }

  void swap_allocator(vector_downward &other) {
    using std::swap;
    swap(allocator_, other.allocator_);
    swap(own_allocator_, other.own_allocator_);
  }

 private:

  vector_downward(const vector_downward &) = delete;
  vector_downward &operator=(const vector_downward &) = delete;

  Allocator *allocator_;
  bool own_allocator_;
  size_t initial_size_;
  size_t buffer_minalign_;
  size_t reserved_;
  uint8_t *buf_;
  uint8_t *cur_;
  uint8_t *scratch_;

  void reallocate(size_t len) {
    auto old_reserved = reserved_;
    auto old_size = size();
    auto old_scratch_size = scratch_size();
    reserved_ +=
        (std::max)(len, old_reserved ? old_reserved / 2 : initial_size_);
    reserved_ = (reserved_ + buffer_minalign_ - 1) & ~(buffer_minalign_ - 1);
    if (buf_) {
      buf_ = ReallocateDownward(allocator_, buf_, old_reserved, reserved_,
                                old_size, old_scratch_size);
    } else {
      buf_ = Allocate(allocator_, reserved_);
    }
    cur_ = buf_ + reserved_ - old_size;
    scratch_ = buf_ + old_scratch_size;
  }
};


inline voffset_t FieldIndexToOffset(voffset_t field_id) {

  const int fixed_fields = 2;
  return static_cast<voffset_t>((field_id + fixed_fields) * sizeof(voffset_t));
}

template<typename T, typename Alloc>
const T *data(const std::vector<T, Alloc> &v) {


  static uint8_t t;
  return v.empty() ? reinterpret_cast<const T *>(&t) : &v.front();
}
template<typename T, typename Alloc> T *data(std::vector<T, Alloc> &v) {


  static uint8_t t;
  return v.empty() ? reinterpret_cast<T *>(&t) : &v.front();
}
# 1076 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
class FlatBufferBuilder {
 public:
# 1089 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  explicit FlatBufferBuilder(
      size_t initial_size = 1024, Allocator *allocator = nullptr,
      bool own_allocator = false,
      size_t buffer_minalign = AlignOf<largest_scalar_t>())
      : buf_(initial_size, allocator, own_allocator, buffer_minalign),
        num_field_loc(0),
        max_voffset_(0),
        nested(false),
        finished(false),
        minalign_(1),
        force_defaults_(false),
        dedup_vtables_(true),
        string_pool(nullptr) {
    EndianCheck();
  }




  FlatBufferBuilder(FlatBufferBuilder &&other)



    : buf_(1024, nullptr, false, AlignOf<largest_scalar_t>()),
      num_field_loc(0),
      max_voffset_(0),
      nested(false),
      finished(false),
      minalign_(1),
      force_defaults_(false),
      dedup_vtables_(true),
      string_pool(nullptr) {
    EndianCheck();


    Swap(other);
  }






  FlatBufferBuilder &operator=(FlatBufferBuilder &&other) {

    FlatBufferBuilder temp(std::move(other));
    Swap(temp);
    return *this;
  }




  void Swap(FlatBufferBuilder &other) {
    using std::swap;
    buf_.swap(other.buf_);
    swap(num_field_loc, other.num_field_loc);
    swap(max_voffset_, other.max_voffset_);
    swap(nested, other.nested);
    swap(finished, other.finished);
    swap(minalign_, other.minalign_);
    swap(force_defaults_, other.force_defaults_);
    swap(dedup_vtables_, other.dedup_vtables_);
    swap(string_pool, other.string_pool);
  }

  ~FlatBufferBuilder() {
    if (string_pool) delete string_pool;
  }

  void Reset() {
    Clear();
    buf_.reset();
  }



  void Clear() {
    ClearOffsets();
    buf_.clear();
    nested = false;
    finished = false;
    minalign_ = 1;
    if (string_pool) string_pool->clear();
  }



  uoffset_t GetSize() const { return buf_.size(); }




  uint8_t *GetBufferPointer() const {
    Finished();
    return buf_.data();
  }



  uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }






  DetachedBuffer ReleaseBufferPointer() {
    Finished();
    return buf_.release();
  }



  DetachedBuffer Release() {
    Finished();
    return buf_.release();
  }
# 1217 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
    Finished();
    return buf_.release_raw(size, offset);
  }






  size_t GetBufferMinAlignment() const {
    Finished();
    return minalign_;
  }


  void Finished() const {





    ((finished) ? (void)0 : ::std:: __aeabi_assert("finished", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1239),
# 1239 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1239 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1239 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((finished)?1:0)
# 1239 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1239 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
  }







  void ForceDefaults(bool fd) { force_defaults_ = fd; }



  void DedupVtables(bool dedup) { dedup_vtables_ = dedup; }


  void Pad(size_t num_bytes) { buf_.fill(num_bytes); }

  void TrackMinAlign(size_t elem_size) {
    if (elem_size > minalign_) minalign_ = elem_size;
  }

  void Align(size_t elem_size) {
    TrackMinAlign(elem_size);
    buf_.fill(PaddingBytes(buf_.size(), elem_size));
  }

  void PushFlatBuffer(const uint8_t *bytes, size_t size) {
    PushBytes(bytes, size);
    finished = true;
  }

  void PushBytes(const uint8_t *bytes, size_t size) { buf_.push(bytes, size); }

  void PopBytes(size_t amount) { buf_.pop(amount); }

  template<typename T> void AssertScalarT() {

    static_assert(flatbuffers::is_scalar<T>::value, "T must be a scalar type");
  }


  template<typename T> uoffset_t PushElement(T element) {
    AssertScalarT<T>();
    T litle_endian_element = EndianScalar(element);
    Align(sizeof(T));
    buf_.push_small(litle_endian_element);
    return GetSize();
  }

  template<typename T> uoffset_t PushElement(Offset<T> off) {

    return PushElement(ReferTo(off.o));
  }



  void TrackField(voffset_t field, uoffset_t off) {
    FieldLoc fl = { off, field };
    buf_.scratch_push_small(fl);
    num_field_loc++;
    max_voffset_ = (std::max)(max_voffset_, field);
  }


  template<typename T> void AddElement(voffset_t field, T e, T def) {

    if (IsTheSameAs(e, def) && !force_defaults_) return;
    auto off = PushElement(e);
    TrackField(field, off);
  }

  template<typename T> void AddElement(voffset_t field, T e) {
    auto off = PushElement(e);
    TrackField(field, off);
  }

  template<typename T> void AddOffset(voffset_t field, Offset<T> off) {
    if (off.IsNull()) return;
    AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
  }

  template<typename T> void AddStruct(voffset_t field, const T *structptr) {
    if (!structptr) return;
    Align(AlignOf<T>());
    buf_.push_small(*structptr);
    TrackField(field, GetSize());
  }

  void AddStructOffset(voffset_t field, uoffset_t off) {
    TrackField(field, off);
  }




  uoffset_t ReferTo(uoffset_t off) {

    Align(sizeof(uoffset_t));

    ((off && off <= GetSize()) ? (void)0 : ::std:: __aeabi_assert("off && off <= GetSize()", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1339),
# 1339 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1339 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1339 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((off && off <= GetSize())?1:0)
# 1339 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1339 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    return GetSize() - off + static_cast<uoffset_t>(sizeof(uoffset_t));
  }

  void NotNested() {
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
    ((!nested) ? (void)0 : ::std:: __aeabi_assert("!nested", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1352),
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((!nested)?1:0)
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1352 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);

    ((!num_field_loc) ? (void)0 : ::std:: __aeabi_assert("!num_field_loc", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1354),
# 1354 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1354 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1354 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((!num_field_loc)?1:0)
# 1354 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1354 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
  }



  uoffset_t StartTable() {
    NotNested();
    nested = true;
    return GetSize();
  }




  uoffset_t EndTable(uoffset_t start) {

    ((nested) ? (void)0 : ::std:: __aeabi_assert("nested", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1370),
# 1370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((nested)?1:0)
# 1370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1370 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);


    auto vtableoffsetloc = PushElement<soffset_t>(0);





    max_voffset_ =
        (std::max)(static_cast<voffset_t>(max_voffset_ + sizeof(voffset_t)),
                   FieldIndexToOffset(0));
    buf_.fill_big(max_voffset_);
    auto table_object_size = vtableoffsetloc - start;

    ((table_object_size < 0x10000) ? (void)0 : ::std:: __aeabi_assert("table_object_size < 0x10000", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1385),
# 1385 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1385 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1385 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((table_object_size < 0x10000)?1:0)
# 1385 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1385 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    WriteScalar<voffset_t>(buf_.data() + sizeof(voffset_t),
                           static_cast<voffset_t>(table_object_size));
    WriteScalar<voffset_t>(buf_.data(), max_voffset_);

    for (auto it = buf_.scratch_end() - num_field_loc * sizeof(FieldLoc);
         it < buf_.scratch_end(); it += sizeof(FieldLoc)) {
      auto field_location = reinterpret_cast<FieldLoc *>(it);
      auto pos = static_cast<voffset_t>(vtableoffsetloc - field_location->off);

      ((!ReadScalar<voffset_t>(buf_.data() + field_location->id)) ? (void)0 : ::std:: __aeabi_assert("!ReadScalar<voffset_t>(buf_.data() + field_location->id)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1396),
# 1395 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1395 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1395 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((!ReadScalar<voffset_t>(buf_.data() + field_location->id))?1:0)
# 1395 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1395 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);

      WriteScalar<voffset_t>(buf_.data() + field_location->id, pos);
    }
    ClearOffsets();
    auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
    auto vt1_size = ReadScalar<voffset_t>(vt1);
    auto vt_use = GetSize();


    if (dedup_vtables_) {
      for (auto it = buf_.scratch_data(); it < buf_.scratch_end();
           it += sizeof(uoffset_t)) {
        auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
        auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
        auto vt2_size = ReadScalar<voffset_t>(vt2);
        if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
        vt_use = *vt_offset_ptr;
        buf_.pop(GetSize() - vtableoffsetloc);
        break;
      }
    }

    if (vt_use == GetSize()) { buf_.scratch_push_small(vt_use); }





    WriteScalar(buf_.data_at(vtableoffsetloc),
                static_cast<soffset_t>(vt_use) -
                    static_cast<soffset_t>(vtableoffsetloc));

    nested = false;
    return vtableoffsetloc;
  }


  uoffset_t EndTable(uoffset_t start, voffset_t ) {
    return EndTable(start);
  }



  template<typename T> void Required(Offset<T> table, voffset_t field);

  uoffset_t StartStruct(size_t alignment) {
    Align(alignment);
    return GetSize();
  }

  uoffset_t EndStruct() { return GetSize(); }

  void ClearOffsets() {
    buf_.scratch_pop(num_field_loc * sizeof(FieldLoc));
    num_field_loc = 0;
    max_voffset_ = 0;
  }



  void PreAlign(size_t len, size_t alignment) {
    TrackMinAlign(alignment);
    buf_.fill(PaddingBytes(GetSize() + len, alignment));
  }
  template<typename T> void PreAlign(size_t len) {
    AssertScalarT<T>();
    PreAlign(len, sizeof(T));
  }






  Offset<String> CreateString(const char *str, size_t len) {
    NotNested();
    PreAlign<uoffset_t>(len + 1);
    buf_.fill(1);
    PushBytes(reinterpret_cast<const uint8_t *>(str), len);
    PushElement(static_cast<uoffset_t>(len));
    return Offset<String>(GetSize());
  }




  Offset<String> CreateString(const char *str) {
    return CreateString(str, strlen(str));
  }




  Offset<String> CreateString(char *str) {
    return CreateString(str, strlen(str));
  }




  Offset<String> CreateString(const std::string &str) {
    return CreateString(str.c_str(), str.length());
  }
# 1514 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  Offset<String> CreateString(const String *str) {
    return str ? CreateString(str->c_str(), str->size()) : 0;
  }





  template<typename T> Offset<String> CreateString(const T &str) {
    return CreateString(str.c_str(), str.length());
  }







  Offset<String> CreateSharedString(const char *str, size_t len) {
    if (!string_pool)
      string_pool = new StringOffsetMap(StringOffsetCompare(buf_));
    auto size_before_string = buf_.size();


    auto off = CreateString(str, len);
    auto it = string_pool->find(off);

    if (it != string_pool->end()) {

      buf_.pop(buf_.size() - size_before_string);
      return *it;
    }

    string_pool->insert(off);
    return off;
  }






  Offset<String> CreateSharedString(const char *str) {
    return CreateSharedString(str, strlen(str));
  }






  Offset<String> CreateSharedString(const std::string &str) {
    return CreateSharedString(str.c_str(), str.length());
  }






  Offset<String> CreateSharedString(const String *str) {
    return CreateSharedString(str->c_str(), str->size());
  }


  uoffset_t EndVector(size_t len) {
    ((nested) ? (void)0 : ::std:: __aeabi_assert("nested", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 1580),
# 1580 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 1580 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1580 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((nested)?1:0)
# 1580 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 1580 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
    nested = false;
    return PushElement(static_cast<uoffset_t>(len));
  }

  void StartVector(size_t len, size_t elemsize) {
    NotNested();
    nested = true;
    PreAlign<uoffset_t>(len * elemsize);
    PreAlign(len * elemsize, elemsize);
  }






  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
    PreAlign(len * elemsize, alignment);
  }


  void ForceStringAlignment(size_t len, size_t alignment) {
    PreAlign((len + 1) * sizeof(char), alignment);
  }
# 1615 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {


    AssertScalarT<T>();
    StartVector(len, sizeof(T));
    if (len == 0) {
      return Offset<Vector<T>>(EndVector(len));
    }


      PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
# 1636 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
    return Offset<Vector<T>>(EndVector(len));
  }

  template<typename T>
  Offset<Vector<Offset<T>>> CreateVector(const Offset<T> *v, size_t len) {
    StartVector(len, sizeof(Offset<T>));
    for (auto i = len; i > 0;) { PushElement(v[--i]); }
    return Offset<Vector<Offset<T>>>(EndVector(len));
  }







  template<typename T> Offset<Vector<T>> CreateVector(const std::vector<T> &v) {
    return CreateVector(data(v), v.size());
  }




  Offset<Vector<uint8_t>> CreateVector(const std::vector<bool> &v) {
    StartVector(v.size(), sizeof(uint8_t));
    for (auto i = v.size(); i > 0;) {
      PushElement(static_cast<uint8_t>(v[--i]));
    }
    return Offset<Vector<uint8_t>>(EndVector(v.size()));
  }
# 1676 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T> Offset<Vector<T>> CreateVector(size_t vector_size,
      const std::function<T (size_t i)> &f) {
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);
    return CreateVector(elems);
  }
# 1694 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename F, typename S>
  Offset<Vector<T>> CreateVector(size_t vector_size, F f, S *state) {
    std::vector<T> elems(vector_size);
    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i, state);
    return CreateVector(elems);
  }







  Offset<Vector<Offset<String>>> CreateVectorOfStrings(
      const std::vector<std::string> &v) {
    std::vector<Offset<String>> offsets(v.size());
    for (size_t i = 0; i < v.size(); i++) offsets[i] = CreateString(v[i]);
    return CreateVector(offsets);
  }
# 1721 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfStructs(const T *v, size_t len) {
    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());
    PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
    return Offset<Vector<const T *>>(EndVector(len));
  }
# 1736 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(const S *v,
                                                        size_t len) {
    extern T Pack(const S &);
    std::vector<T> vv(len);
    std::transform(v, v + len, vv.begin(), Pack);
    return CreateVectorOfStructs<T>(data(vv), vv.size());
  }
# 1755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
      size_t vector_size, const std::function<void(size_t i, T *)> &filler) {
    T* structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      filler(i, structs);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }
# 1776 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename F, typename S>
  Offset<Vector<const T *>> CreateVectorOfStructs(size_t vector_size, F f,
                                                  S *state) {
    T *structs = StartVectorOfStructs<T>(vector_size);
    for (size_t i = 0; i < vector_size; i++) {
      f(i, structs, state);
      structs++;
    }
    return EndVectorOfStructs<T>(vector_size);
  }







  template<typename T, typename Alloc>
  Offset<Vector<const T *>> CreateVectorOfStructs(
      const std::vector<T, Alloc> &v) {
    return CreateVectorOfStructs(data(v), v.size());
  }
# 1807 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
      const std::vector<S> &v) {
    return CreateVectorOfNativeStructs<T, S>(data(v), v.size());
  }


  template<typename T> struct StructKeyComparator {
    bool operator()(const T &a, const T &b) const {
      return a.KeyCompareLessThan(&b);
    }

    StructKeyComparator &operator=(const StructKeyComparator &) = delete;

  };
# 1831 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfSortedStructs(std::vector<T> *v) {
    return CreateVectorOfSortedStructs(data(*v), v->size());
  }
# 1844 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(
      std::vector<S> *v) {
    return CreateVectorOfSortedNativeStructs<T, S>(data(*v), v->size());
  }
# 1858 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<const T *>> CreateVectorOfSortedStructs(T *v, size_t len) {
    std::sort(v, v + len, StructKeyComparator<T>());
    return CreateVectorOfStructs(v, len);
  }
# 1873 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T, typename S>
  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(S *v,
                                                              size_t len) {
    extern T Pack(const S &);
    typedef T (*Pack_t)(const S &);
    std::vector<T> vv(len);
    std::transform(v, v + len, vv.begin(), static_cast<Pack_t &>(Pack));
    return CreateVectorOfSortedStructs<T>(vv, len);
  }


  template<typename T> struct TableKeyComparator {
    TableKeyComparator(vector_downward &buf) : buf_(buf) {}
    TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) {}
    bool operator()(const Offset<T> &a, const Offset<T> &b) const {
      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
      return table_a->KeyCompareLessThan(table_b);
    }
    vector_downward &buf_;

   private:
    TableKeyComparator &operator=(const TableKeyComparator &other) = delete;
  };
# 1907 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(Offset<T> *v,
                                                       size_t len) {
    std::sort(v, v + len, TableKeyComparator<T>(buf_));
    return CreateVector(v, len);
  }
# 1921 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
      std::vector<Offset<T>> *v) {
    return CreateVectorOfSortedTables(data(*v), v->size());
  }
# 1934 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  uoffset_t CreateUninitializedVector(size_t len, size_t elemsize,
                                      uint8_t **buf) {
    NotNested();
    StartVector(len, elemsize);
    buf_.make_space(len * elemsize);
    auto vec_start = GetSize();
    auto vec_end = EndVector(len);
    *buf = buf_.data_at(vec_start);
    return vec_end;
  }
# 1953 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
    AssertScalarT<T>();
    return CreateUninitializedVector(len, sizeof(T),
                                     reinterpret_cast<uint8_t **>(buf));
  }

  template<typename T>
  Offset<Vector<const T *>> CreateUninitializedVectorOfStructs(size_t len,
                                                               T **buf) {
    return CreateUninitializedVector(len, sizeof(T),
                                     reinterpret_cast<uint8_t **>(buf));
  }




  template<typename T, typename U>
  Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
    AssertScalarT<T>();
    AssertScalarT<U>();
    StartVector(len, sizeof(T));
    for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
    return Offset<Vector<T>>(EndVector(len));
  }


  template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
    NotNested();
    Align(AlignOf<T>());
    buf_.push_small(structobj);
    return Offset<const T *>(GetSize());
  }


  static const size_t kFileIdentifierLength = 4;




  template<typename T>
  void Finish(Offset<T> root, const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, false);
  }
# 2005 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  template<typename T>
  void FinishSizePrefixed(Offset<T> root,
                          const char *file_identifier = nullptr) {
    Finish(root.o, file_identifier, true);
  }

  void SwapBufAllocator(FlatBufferBuilder &other) {
    buf_.swap_allocator(other.buf_);
  }

 protected:

  FlatBufferBuilder(const FlatBufferBuilder &);
  FlatBufferBuilder &operator=(const FlatBufferBuilder &);

  void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
    NotNested();
    buf_.clear_scratch();

    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) + sizeof(uoffset_t) +
                 (file_identifier ? kFileIdentifierLength : 0),
             minalign_);
    if (file_identifier) {
      ((strlen(file_identifier) == kFileIdentifierLength) ? (void)0 : ::std:: __aeabi_assert("strlen(file_identifier) == kFileIdentifierLength", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 2028),
# 2028 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 2028 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 2028 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((strlen(file_identifier) == kFileIdentifierLength)?1:0)
# 2028 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 2028 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),
                kFileIdentifierLength);
    }
    PushElement(ReferTo(root));
    if (size_prefix) { PushElement(GetSize()); }
    finished = true;
  }

  struct FieldLoc {
    uoffset_t off;
    voffset_t id;
  };

  vector_downward buf_;



  uoffset_t num_field_loc;


  voffset_t max_voffset_;


  bool nested;


  bool finished;

  size_t minalign_;

  bool force_defaults_;

  bool dedup_vtables_;

  struct StringOffsetCompare {
    StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}
    bool operator()(const Offset<String> &a, const Offset<String> &b) const {
      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
      return StringLessThan(stra->data(), stra->size(), strb->data(),
                            strb->size());
    }
    const vector_downward *buf_;
  };


  typedef std::set<Offset<String>, StringOffsetCompare> StringOffsetMap;
  StringOffsetMap *string_pool;

 private:


  template<typename T> T *StartVectorOfStructs(size_t vector_size) {
    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());
    return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
  }



  template<typename T>
  Offset<Vector<const T *>> EndVectorOfStructs(size_t vector_size) {
    return Offset<Vector<const T *>>(EndVector(vector_size));
  }
};




template<typename T> T *GetMutableRoot(void *buf) {
  EndianCheck();
  return reinterpret_cast<T *>(
      reinterpret_cast<uint8_t *>(buf) +
      EndianScalar(*reinterpret_cast<uoffset_t *>(buf)));
}

template<typename T> const T *GetRoot(const void *buf) {
  return GetMutableRoot<T>(const_cast<void *>(buf));
}

template<typename T> const T *GetSizePrefixedRoot(const void *buf) {
  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(uoffset_t));
}




template<typename T>
T *GetMutableTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
  return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() + fbb.GetSize() -
                               offset.o);
}

template<typename T>
const T *GetTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
  return GetMutableTemporaryPointer<T>(fbb, offset);
}
# 2133 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
inline const char *GetBufferIdentifier(const void *buf,
                                       bool size_prefixed = false) {
  return reinterpret_cast<const char *>(buf) +
         ((size_prefixed) ? 2 * sizeof(uoffset_t) : sizeof(uoffset_t));
}


inline bool BufferHasIdentifier(const void *buf, const char *identifier,
                                bool size_prefixed = false) {
  return strncmp(GetBufferIdentifier(buf, size_prefixed), identifier,
                 FlatBufferBuilder::kFileIdentifierLength) == 0;
}


class Verifier final {
 public:
  Verifier(const uint8_t *buf, size_t buf_len, uoffset_t _max_depth = 64,
           uoffset_t _max_tables = 1000000, bool _check_alignment = true)
      : buf_(buf),
        size_(buf_len),
        depth_(0),
        max_depth_(_max_depth),
        num_tables_(0),
        max_tables_(_max_tables),
        upper_bound_(0),
        check_alignment_(_check_alignment) {
    ((size_ < ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1)) ? (void)0 : ::std:: __aeabi_assert("size_ < FLATBUFFERS_MAX_BUFFER_SIZE", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 2159),
# 2159 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 2159 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 2159 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((size_ < ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1))?1:0)
# 2159 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 2159 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
  }


  bool Check(bool ok) const {
# 2173 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
    return ok;
  }


  bool Verify(size_t elem, size_t elem_len) const {







    return Check(elem_len < size_ && elem <= size_ - elem_len);
  }

  template<typename T> bool VerifyAlignment(size_t elem) const {
    return Check((elem & (sizeof(T) - 1)) == 0 || !check_alignment_);
  }


  template<typename T> bool Verify(size_t elem) const {
    return VerifyAlignment<T>(elem) && Verify(elem, sizeof(T));
  }

  bool VerifyFromPointer(const uint8_t *p, size_t len) {
    auto o = static_cast<size_t>(p - buf_);
    return Verify(o, len);
  }


  bool Verify(const uint8_t *base, voffset_t elem_off, size_t elem_len) const {
    return Verify(static_cast<size_t>(base - buf_) + elem_off, elem_len);
  }

  template<typename T>
  bool Verify(const uint8_t *base, voffset_t elem_off) const {
    return Verify(static_cast<size_t>(base - buf_) + elem_off, sizeof(T));
  }


  template<typename T> bool VerifyTable(const T *table) {
    return !table || table->Verify(*this);
  }


  template<typename T> bool VerifyVector(const Vector<T> *vec) const {
    return !vec || VerifyVectorOrString(reinterpret_cast<const uint8_t *>(vec),
                                        sizeof(T));
  }


  template<typename T> bool VerifyVector(const Vector<const T *> *vec) const {
    return VerifyVector(reinterpret_cast<const Vector<T> *>(vec));
  }


  bool VerifyString(const String *str) const {
    size_t end;
    return !str || (VerifyVectorOrString(reinterpret_cast<const uint8_t *>(str),
                                         1, &end) &&
                    Verify(end, 1) &&
                    Check(buf_[end] == '\0'));
  }


  bool VerifyVectorOrString(const uint8_t *vec, size_t elem_size,
                            size_t *end = nullptr) const {
    auto veco = static_cast<size_t>(vec - buf_);

    if (!Verify<uoffset_t>(veco)) return false;


    auto size = ReadScalar<uoffset_t>(vec);
    auto max_elems = ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1) / elem_size;
    if (!Check(size < max_elems))
      return false;
    auto byte_size = sizeof(size) + elem_size * size;
    if (end) *end = veco + byte_size;
    return Verify(veco, byte_size);
  }


  bool VerifyVectorOfStrings(const Vector<Offset<String>> *vec) const {
    if (vec) {
      for (uoffset_t i = 0; i < vec->size(); i++) {
        if (!VerifyString(vec->Get(i))) return false;
      }
    }
    return true;
  }


  template<typename T> bool VerifyVectorOfTables(const Vector<Offset<T>> *vec) {
    if (vec) {
      for (uoffset_t i = 0; i < vec->size(); i++) {
        if (!vec->Get(i)->Verify(*this)) return false;
      }
    }
    return true;
  }

  __attribute__((no_sanitize("unsigned-integer-overflow"))) bool VerifyTableStart(
      const uint8_t *table) {

    auto tableo = static_cast<size_t>(table - buf_);
    if (!Verify<soffset_t>(tableo)) return false;


    auto vtableo = tableo - static_cast<size_t>(ReadScalar<soffset_t>(table));

    return VerifyComplexity() && Verify<voffset_t>(vtableo) &&
           VerifyAlignment<voffset_t>(ReadScalar<voffset_t>(buf_ + vtableo)) &&
           Verify(vtableo, ReadScalar<voffset_t>(buf_ + vtableo));
  }

  template<typename T>
  bool VerifyBufferFromStart(const char *identifier, size_t start) {
    if (identifier && !Check((size_ >= 2 * sizeof(flatbuffers::uoffset_t) &&
                              BufferHasIdentifier(buf_ + start, identifier)))) {
      return false;
    }


    auto o = VerifyOffset(start);
    return o && reinterpret_cast<const T *>(buf_ + start + o)->Verify(*this)




        ;

  }


  template<typename T> bool VerifyBuffer() { return VerifyBuffer<T>(nullptr); }

  template<typename T> bool VerifyBuffer(const char *identifier) {
    return VerifyBufferFromStart<T>(identifier, 0);
  }

  template<typename T> bool VerifySizePrefixedBuffer(const char *identifier) {
    return Verify<uoffset_t>(0U) &&
           ReadScalar<uoffset_t>(buf_) == size_ - sizeof(uoffset_t) &&
           VerifyBufferFromStart<T>(identifier, sizeof(uoffset_t));
  }

  uoffset_t VerifyOffset(size_t start) const {
    if (!Verify<uoffset_t>(start)) return 0;
    auto o = ReadScalar<uoffset_t>(buf_ + start);

    if (!Check(o != 0)) return 0;

    if (!Check(static_cast<soffset_t>(o) >= 0)) return 0;


    if (!Verify(start + o, 1)) return 0;
    return o;
  }

  uoffset_t VerifyOffset(const uint8_t *base, voffset_t start) const {
    return VerifyOffset(static_cast<size_t>(base - buf_) + start);
  }





  bool VerifyComplexity() {
    depth_++;
    num_tables_++;
    return Check(depth_ <= max_depth_ && num_tables_ <= max_tables_);
  }


  bool EndTable() {
    depth_--;
    return true;
  }


  size_t GetComputedSize() const {
# 2362 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
      (void)upper_bound_;
      ((false) ? (void)0 : ::std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 2363),
# 2363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 2363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 2363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((false)?1:0)
# 2363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 2363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
      return 0;


  }

 private:
  const uint8_t *buf_;
  size_t size_;
  uoffset_t depth_;
  uoffset_t max_depth_;
  uoffset_t num_tables_;
  uoffset_t max_tables_;
  mutable size_t upper_bound_;
  bool check_alignment_;
};




struct BufferRefBase {};
template<typename T> struct BufferRef : BufferRefBase {
  BufferRef() : buf(nullptr), len(0), must_free(false) {}
  BufferRef(uint8_t *_buf, uoffset_t _len)
      : buf(_buf), len(_len), must_free(false) {}

  ~BufferRef() {
    if (must_free) free(buf);
  }

  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }

  bool Verify() {
    Verifier verifier(buf, len);
    return verifier.VerifyBuffer<T>(nullptr);
  }

  uint8_t *buf;
  uoffset_t len;
  bool must_free;
};





class Struct final {
 public:
  template<typename T> T GetField(uoffset_t o) const {
    return ReadScalar<T>(&data_[o]);
  }

  template<typename T> T GetStruct(uoffset_t o) const {
    return reinterpret_cast<T>(&data_[o]);
  }

  const uint8_t *GetAddressOf(uoffset_t o) const { return &data_[o]; }
  uint8_t *GetAddressOf(uoffset_t o) { return &data_[o]; }

 private:


  Struct();
  Struct(const Struct &);
  Struct &operator=(const Struct &);

  uint8_t data_[1];
};



class Table {
 public:
  const uint8_t *GetVTable() const {
    return data_ - ReadScalar<soffset_t>(data_);
  }



  voffset_t GetOptionalFieldOffset(voffset_t field) const {

    auto vtable = GetVTable();

    auto vtsize = ReadScalar<voffset_t>(vtable);


    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;
  }

  template<typename T> T GetField(voffset_t field, T defaultval) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;
  }

  template<typename P> P GetPointer(voffset_t field) {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = data_ + field_offset;
    return field_offset ? reinterpret_cast<P>(p + ReadScalar<uoffset_t>(p))
                        : nullptr;
  }
  template<typename P> P GetPointer(voffset_t field) const {
    return const_cast<Table *>(this)->GetPointer<P>(field);
  }

  template<typename P> P GetStruct(voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = const_cast<uint8_t *>(data_ + field_offset);
    return field_offset ? reinterpret_cast<P>(p) : nullptr;
  }

  template<typename Raw, typename Face>
  flatbuffers::Optional<Face> GetOptional(voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    auto p = data_ + field_offset;
    return field_offset ? Optional<Face>(static_cast<Face>(ReadScalar<Raw>(p)))
                        : Optional<Face>();
  }

  template<typename T> bool SetField(voffset_t field, T val, T def) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return IsTheSameAs(val, def);
    WriteScalar(data_ + field_offset, val);
    return true;
  }
  template<typename T> bool SetField(voffset_t field, T val) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return false;
    WriteScalar(data_ + field_offset, val);
    return true;
  }

  bool SetPointer(voffset_t field, const uint8_t *val) {
    auto field_offset = GetOptionalFieldOffset(field);
    if (!field_offset) return false;
    WriteScalar(data_ + field_offset,
                static_cast<uoffset_t>(val - (data_ + field_offset)));
    return true;
  }

  uint8_t *GetAddressOf(voffset_t field) {
    auto field_offset = GetOptionalFieldOffset(field);
    return field_offset ? data_ + field_offset : nullptr;
  }
  const uint8_t *GetAddressOf(voffset_t field) const {
    return const_cast<Table *>(this)->GetAddressOf(field);
  }

  bool CheckField(voffset_t field) const {
    return GetOptionalFieldOffset(field) != 0;
  }



  bool VerifyTableStart(Verifier &verifier) const {
    return verifier.VerifyTableStart(data_);
  }


  template<typename T>
  bool VerifyField(const Verifier &verifier, voffset_t field) const {


    auto field_offset = GetOptionalFieldOffset(field);

    return !field_offset || verifier.Verify<T>(data_, field_offset);
  }


  template<typename T>
  bool VerifyFieldRequired(const Verifier &verifier, voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return verifier.Check(field_offset != 0) &&
           verifier.Verify<T>(data_, field_offset);
  }


  bool VerifyOffset(const Verifier &verifier, voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return !field_offset || verifier.VerifyOffset(data_, field_offset);
  }

  bool VerifyOffsetRequired(const Verifier &verifier, voffset_t field) const {
    auto field_offset = GetOptionalFieldOffset(field);
    return verifier.Check(field_offset != 0) &&
           verifier.VerifyOffset(data_, field_offset);
  }

 private:


  Table();
  Table(const Table &other);
  Table &operator=(const Table &);

  uint8_t data_[1];
};



template<>
inline flatbuffers::Optional<bool> Table::GetOptional<uint8_t, bool>(
    voffset_t field) const {
  auto field_offset = GetOptionalFieldOffset(field);
  auto p = data_ + field_offset;
  return field_offset ? Optional<bool>(ReadScalar<uint8_t>(p) != 0)
                      : Optional<bool>();
}

template<typename T>
void FlatBufferBuilder::Required(Offset<T> table, voffset_t field) {
  auto table_ptr = reinterpret_cast<const Table *>(buf_.data_at(table.o));
  bool ok = table_ptr->GetOptionalFieldOffset(field) != 0;

  ((ok) ? (void)0 : ::std:: __aeabi_assert("ok", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 2576),
# 2576 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 2576 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 2576 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((ok)?1:0)
# 2576 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 2576 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
  (void)ok;
}





inline const uint8_t *GetBufferStartFromRootPointer(const void *root) {
  auto table = reinterpret_cast<const Table *>(root);
  auto vtable = table->GetVTable();

  auto start = (std::min)(vtable, reinterpret_cast<const uint8_t *>(root));

  start = reinterpret_cast<const uint8_t *>(reinterpret_cast<uintptr_t>(start) &
                                            ~(sizeof(uoffset_t) - 1));
# 2601 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
  static_assert(FlatBufferBuilder::kFileIdentifierLength == sizeof(uoffset_t),
                "file_identifier is assumed to be the same size as uoffset_t");
  for (auto possible_roots = 16 / sizeof(uoffset_t) + 1;
       possible_roots; possible_roots--) {
    start -= sizeof(uoffset_t);
    if (ReadScalar<uoffset_t>(start) + start ==
        reinterpret_cast<const uint8_t *>(root))
      return start;
  }




  ((false) ? (void)0 : ::std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h", 2614),
# 2614 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic push
# 2614 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 2614 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
 (__builtin_assume)((false)?1:0)
# 2614 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
#pragma clang diagnostic pop
# 2614 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
);
  return nullptr;
}


inline uoffset_t GetPrefixedSize(const uint8_t *buf) {
  return ReadScalar<uoffset_t>(buf);
}




struct NativeTable {};
# 2636 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
typedef uint64_t hash_value_t;





  typedef std::function<void (void **pointer_adr, hash_value_t hash)>
          resolver_function_t;
  typedef std::function<hash_value_t (void *pointer)> rehasher_function_t;
# 2655 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
template<typename T>
bool IsFieldPresent(const T *table, typename T::FlatBuffersVTableOffset field) {

  return reinterpret_cast<const Table *>(table)->CheckField(
      static_cast<voffset_t>(field));
}




inline int LookupEnum(const char **names, const char *name) {
  for (const char **p = names; *p; p++)
    if (!strcmp(*p, name)) return static_cast<int>(p - names);
  return -1;
}
# 2711 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
enum SequenceType { ST_TABLE, ST_STRUCT, ST_UNION, ST_ENUM };
# 2731 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
enum ElementaryType {

    ET_UTYPE, ET_BOOL, ET_CHAR, ET_UCHAR, ET_SHORT, ET_USHORT, ET_INT, ET_UINT, ET_LONG, ET_ULONG, ET_FLOAT, ET_DOUBLE, ET_STRING, ET_SEQUENCE,

};

inline const char * const *ElementaryTypeNames() {
  static const char * const names[] = {

      "ET_UTYPE", "ET_BOOL", "ET_CHAR", "ET_UCHAR", "ET_SHORT", "ET_USHORT", "ET_INT", "ET_UINT", "ET_LONG", "ET_ULONG", "ET_FLOAT", "ET_DOUBLE", "ET_STRING", "ET_SEQUENCE",

  };
  return names;
}



struct TypeCode {
  uint16_t base_type : 4;
  uint16_t is_repeating : 1;
  int16_t sequence_ref : 11;
};

static_assert(sizeof(TypeCode) == 2, "TypeCode");

struct TypeTable;


typedef const TypeTable *(*TypeFunction)();

struct TypeTable {
  SequenceType st;
  size_t num_elems;
  const TypeCode *type_codes;
  const TypeFunction *type_refs;
  const int16_t *array_sizes;
  const int64_t *values;
  const char *const *names;
};
# 2824 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flatbuffers.h"
}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/schema/schema_generated.h" 2

namespace tflite {

struct CustomQuantization;
struct CustomQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersT;

struct Int32Vector;
struct Int32VectorT;

struct Uint16Vector;
struct Uint16VectorT;

struct Uint8Vector;
struct Uint8VectorT;

struct DimensionMetadata;
struct DimensionMetadataT;

struct SparsityParameters;
struct SparsityParametersT;

struct Tensor;
struct TensorT;

struct Conv2DOptions;
struct Conv2DOptionsT;

struct Conv3DOptions;
struct Conv3DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsT;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsT;

struct SubOptions;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsT;

struct CosOptions;
struct CosOptionsT;

struct ReducerOptions;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsT;

struct RankOptions;
struct RankOptionsT;

struct PowOptions;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsT;

struct HardSwishOptions;
struct HardSwishOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsT;

struct UniqueOptions;
struct UniqueOptionsT;

struct ReverseV2Options;
struct ReverseV2OptionsT;

struct AddNOptions;
struct AddNOptionsT;

struct GatherNdOptions;
struct GatherNdOptionsT;

struct WhereOptions;
struct WhereOptionsT;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsT;

struct MatrixDiagOptions;
struct MatrixDiagOptionsT;

struct QuantizeOptions;
struct QuantizeOptionsT;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsT;

struct IfOptions;
struct IfOptionsT;

struct CallOnceOptions;
struct CallOnceOptionsT;

struct WhileOptions;
struct WhileOptionsT;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsT;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsT;

struct ScatterNdOptions;
struct ScatterNdOptionsT;

struct SelectV2Options;
struct SelectV2OptionsT;

struct DensifyOptions;
struct DensifyOptionsT;

struct SegmentSumOptions;
struct SegmentSumOptionsT;

struct BatchMatMulOptions;
struct BatchMatMulOptionsT;

struct CumsumOptions;
struct CumsumOptionsT;

struct BroadcastToOptions;
struct BroadcastToOptionsT;

struct Rfft2dOptions;
struct Rfft2dOptionsT;

struct HashtableOptions;
struct HashtableOptionsT;

struct HashtableFindOptions;
struct HashtableFindOptionsT;

struct HashtableImportOptions;
struct HashtableImportOptionsT;

struct HashtableSizeOptions;
struct HashtableSizeOptionsT;

struct VarHandleOptions;
struct VarHandleOptionsT;

struct ReadVariableOptions;
struct ReadVariableOptionsT;

struct AssignVariableOptions;
struct AssignVariableOptionsT;

struct RandomOptions;
struct RandomOptionsT;

struct BucketizeOptions;
struct BucketizeOptionsT;

struct GeluOptions;
struct GeluOptionsT;

struct DynamicUpdateSliceOptions;
struct DynamicUpdateSliceOptionsT;

struct OperatorCode;
struct OperatorCodeT;

struct Operator;
struct OperatorT;

struct SubGraph;
struct SubGraphT;

struct Buffer;
struct BufferT;

struct Metadata;
struct MetadataT;

struct TensorMap;
struct TensorMapT;

struct SignatureDef;
struct SignatureDefT;

struct Model;
struct ModelT;

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_UINT16 = 16,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_UINT16
};

inline const TensorType (&EnumValuesTensorType())[17] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8,
    TensorType_FLOAT64,
    TensorType_COMPLEX128,
    TensorType_UINT64,
    TensorType_RESOURCE,
    TensorType_VARIANT,
    TensorType_UINT32,
    TensorType_UINT16
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[18] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    "UINT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_UINT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[3] = {
    "NONE",
    "CustomQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<tflite::CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

struct QuantizationDetailsUnion {
  QuantizationDetails type;
  void *value;

  QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
  QuantizationDetailsUnion(QuantizationDetailsUnion&& u) noexcept :
    type(QuantizationDetails_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  QuantizationDetailsUnion(const QuantizationDetailsUnion &) noexcept;
  QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u) noexcept
    { QuantizationDetailsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) noexcept
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~QuantizationDetailsUnion() { Reset(); }

  void Reset();


  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = QuantizationDetailsTraits<typename RT::TableType>::enum_value;
    if (type != QuantizationDetails_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }


  static void *UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::CustomQuantizationT *AsCustomQuantization() {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<tflite::CustomQuantizationT *>(value) : nullptr;
  }
  const tflite::CustomQuantizationT *AsCustomQuantization() const {
    return type == QuantizationDetails_CustomQuantization ?
      reinterpret_cast<const tflite::CustomQuantizationT *>(value) : nullptr;
  }
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DimensionType {
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
  static const DimensionType values[] = {
    DimensionType_DENSE,
    DimensionType_SPARSE_CSR
  };
  return values;
}

inline const char * const *EnumNamesDimensionType() {
  static const char * const names[3] = {
    "DENSE",
    "SPARSE_CSR",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e) {
  if (flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector {
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
  static const SparseIndexVector values[] = {
    SparseIndexVector_NONE,
    SparseIndexVector_Int32Vector,
    SparseIndexVector_Uint16Vector,
    SparseIndexVector_Uint8Vector
  };
  return values;
}

inline const char * const *EnumNamesSparseIndexVector() {
  static const char * const names[5] = {
    "NONE",
    "Int32Vector",
    "Uint16Vector",
    "Uint8Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {
  if (flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template<typename T> struct SparseIndexVectorTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template<> struct SparseIndexVectorTraits<tflite::Int32Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template<> struct SparseIndexVectorTraits<tflite::Uint16Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template<> struct SparseIndexVectorTraits<tflite::Uint8Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

struct SparseIndexVectorUnion {
  SparseIndexVector type;
  void *value;

  SparseIndexVectorUnion() : type(SparseIndexVector_NONE), value(nullptr) {}
  SparseIndexVectorUnion(SparseIndexVectorUnion&& u) noexcept :
    type(SparseIndexVector_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SparseIndexVectorUnion(const SparseIndexVectorUnion &) noexcept;
  SparseIndexVectorUnion &operator=(const SparseIndexVectorUnion &u) noexcept
    { SparseIndexVectorUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SparseIndexVectorUnion &operator=(SparseIndexVectorUnion &&u) noexcept
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SparseIndexVectorUnion() { Reset(); }

  void Reset();


  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SparseIndexVectorTraits<typename RT::TableType>::enum_value;
    if (type != SparseIndexVector_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }


  static void *UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::Int32VectorT *AsInt32Vector() {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<tflite::Int32VectorT *>(value) : nullptr;
  }
  const tflite::Int32VectorT *AsInt32Vector() const {
    return type == SparseIndexVector_Int32Vector ?
      reinterpret_cast<const tflite::Int32VectorT *>(value) : nullptr;
  }
  tflite::Uint16VectorT *AsUint16Vector() {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<tflite::Uint16VectorT *>(value) : nullptr;
  }
  const tflite::Uint16VectorT *AsUint16Vector() const {
    return type == SparseIndexVector_Uint16Vector ?
      reinterpret_cast<const tflite::Uint16VectorT *>(value) : nullptr;
  }
  tflite::Uint8VectorT *AsUint8Vector() {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<tflite::Uint8VectorT *>(value) : nullptr;
  }
  const tflite::Uint8VectorT *AsUint8Vector() const {
    return type == SparseIndexVector_Uint8Vector ?
      reinterpret_cast<const tflite::Uint8VectorT *>(value) : nullptr;
  }
};

bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);
bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_BUCKETIZE = 147,
  BuiltinOperator_RANDOM_UNIFORM = 148,
  BuiltinOperator_MULTINOMIAL = 149,
  BuiltinOperator_GELU = 150,
  BuiltinOperator_DYNAMIC_UPDATE_SLICE = 151,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_DYNAMIC_UPDATE_SLICE
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[152] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEPTH_TO_SPACE,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V,
    BuiltinOperator_UNIQUE,
    BuiltinOperator_CEIL,
    BuiltinOperator_REVERSE_V2,
    BuiltinOperator_ADD_N,
    BuiltinOperator_GATHER_ND,
    BuiltinOperator_COS,
    BuiltinOperator_WHERE,
    BuiltinOperator_RANK,
    BuiltinOperator_ELU,
    BuiltinOperator_REVERSE_SEQUENCE,
    BuiltinOperator_MATRIX_DIAG,
    BuiltinOperator_QUANTIZE,
    BuiltinOperator_MATRIX_SET_DIAG,
    BuiltinOperator_ROUND,
    BuiltinOperator_HARD_SWISH,
    BuiltinOperator_IF,
    BuiltinOperator_WHILE,
    BuiltinOperator_NON_MAX_SUPPRESSION_V4,
    BuiltinOperator_NON_MAX_SUPPRESSION_V5,
    BuiltinOperator_SCATTER_ND,
    BuiltinOperator_SELECT_V2,
    BuiltinOperator_DENSIFY,
    BuiltinOperator_SEGMENT_SUM,
    BuiltinOperator_BATCH_MATMUL,
    BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
    BuiltinOperator_CUMSUM,
    BuiltinOperator_CALL_ONCE,
    BuiltinOperator_BROADCAST_TO,
    BuiltinOperator_RFFT2D,
    BuiltinOperator_CONV_3D,
    BuiltinOperator_IMAG,
    BuiltinOperator_REAL,
    BuiltinOperator_COMPLEX_ABS,
    BuiltinOperator_HASHTABLE,
    BuiltinOperator_HASHTABLE_FIND,
    BuiltinOperator_HASHTABLE_IMPORT,
    BuiltinOperator_HASHTABLE_SIZE,
    BuiltinOperator_REDUCE_ALL,
    BuiltinOperator_CONV_3D_TRANSPOSE,
    BuiltinOperator_VAR_HANDLE,
    BuiltinOperator_READ_VARIABLE,
    BuiltinOperator_ASSIGN_VARIABLE,
    BuiltinOperator_BROADCAST_ARGS,
    BuiltinOperator_RANDOM_STANDARD_NORMAL,
    BuiltinOperator_BUCKETIZE,
    BuiltinOperator_RANDOM_UNIFORM,
    BuiltinOperator_MULTINOMIAL,
    BuiltinOperator_GELU,
    BuiltinOperator_DYNAMIC_UPDATE_SLICE
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOperator() {
  static const char * const names[153] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "DEPTH_TO_SPACE",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    "UNIQUE",
    "CEIL",
    "REVERSE_V2",
    "ADD_N",
    "GATHER_ND",
    "COS",
    "WHERE",
    "RANK",
    "ELU",
    "REVERSE_SEQUENCE",
    "MATRIX_DIAG",
    "QUANTIZE",
    "MATRIX_SET_DIAG",
    "ROUND",
    "HARD_SWISH",
    "IF",
    "WHILE",
    "NON_MAX_SUPPRESSION_V4",
    "NON_MAX_SUPPRESSION_V5",
    "SCATTER_ND",
    "SELECT_V2",
    "DENSIFY",
    "SEGMENT_SUM",
    "BATCH_MATMUL",
    "PLACEHOLDER_FOR_GREATER_OP_CODES",
    "CUMSUM",
    "CALL_ONCE",
    "BROADCAST_TO",
    "RFFT2D",
    "CONV_3D",
    "IMAG",
    "REAL",
    "COMPLEX_ABS",
    "HASHTABLE",
    "HASHTABLE_FIND",
    "HASHTABLE_IMPORT",
    "HASHTABLE_SIZE",
    "REDUCE_ALL",
    "CONV_3D_TRANSPOSE",
    "VAR_HANDLE",
    "READ_VARIABLE",
    "ASSIGN_VARIABLE",
    "BROADCAST_ARGS",
    "RANDOM_STANDARD_NORMAL",
    "BUCKETIZE",
    "RANDOM_UNIFORM",
    "MULTINOMIAL",
    "GELU",
    "DYNAMIC_UPDATE_SLICE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_DYNAMIC_UPDATE_SLICE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BucketizeOptions = 115,
  BuiltinOptions_GeluOptions = 116,
  BuiltinOptions_DynamicUpdateSliceOptions = 117,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_DynamicUpdateSliceOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[118] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions,
    BuiltinOptions_UniqueOptions,
    BuiltinOptions_ReverseV2Options,
    BuiltinOptions_AddNOptions,
    BuiltinOptions_GatherNdOptions,
    BuiltinOptions_CosOptions,
    BuiltinOptions_WhereOptions,
    BuiltinOptions_RankOptions,
    BuiltinOptions_ReverseSequenceOptions,
    BuiltinOptions_MatrixDiagOptions,
    BuiltinOptions_QuantizeOptions,
    BuiltinOptions_MatrixSetDiagOptions,
    BuiltinOptions_HardSwishOptions,
    BuiltinOptions_IfOptions,
    BuiltinOptions_WhileOptions,
    BuiltinOptions_DepthToSpaceOptions,
    BuiltinOptions_NonMaxSuppressionV4Options,
    BuiltinOptions_NonMaxSuppressionV5Options,
    BuiltinOptions_ScatterNdOptions,
    BuiltinOptions_SelectV2Options,
    BuiltinOptions_DensifyOptions,
    BuiltinOptions_SegmentSumOptions,
    BuiltinOptions_BatchMatMulOptions,
    BuiltinOptions_CumsumOptions,
    BuiltinOptions_CallOnceOptions,
    BuiltinOptions_BroadcastToOptions,
    BuiltinOptions_Rfft2dOptions,
    BuiltinOptions_Conv3DOptions,
    BuiltinOptions_HashtableOptions,
    BuiltinOptions_HashtableFindOptions,
    BuiltinOptions_HashtableImportOptions,
    BuiltinOptions_HashtableSizeOptions,
    BuiltinOptions_VarHandleOptions,
    BuiltinOptions_ReadVariableOptions,
    BuiltinOptions_AssignVariableOptions,
    BuiltinOptions_RandomOptions,
    BuiltinOptions_BucketizeOptions,
    BuiltinOptions_GeluOptions,
    BuiltinOptions_DynamicUpdateSliceOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[119] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    "MatrixDiagOptions",
    "QuantizeOptions",
    "MatrixSetDiagOptions",
    "HardSwishOptions",
    "IfOptions",
    "WhileOptions",
    "DepthToSpaceOptions",
    "NonMaxSuppressionV4Options",
    "NonMaxSuppressionV5Options",
    "ScatterNdOptions",
    "SelectV2Options",
    "DensifyOptions",
    "SegmentSumOptions",
    "BatchMatMulOptions",
    "CumsumOptions",
    "CallOnceOptions",
    "BroadcastToOptions",
    "Rfft2dOptions",
    "Conv3DOptions",
    "HashtableOptions",
    "HashtableFindOptions",
    "HashtableImportOptions",
    "HashtableSizeOptions",
    "VarHandleOptions",
    "ReadVariableOptions",
    "AssignVariableOptions",
    "RandomOptions",
    "BucketizeOptions",
    "GeluOptions",
    "DynamicUpdateSliceOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_DynamicUpdateSliceOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<tflite::L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<tflite::TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<tflite::PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<tflite::OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<tflite::FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<tflite::LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsTraits<tflite::UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsTraits<tflite::WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReverseSequenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MatrixDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template<> struct BuiltinOptionsTraits<tflite::QuantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::MatrixSetDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HardSwishOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template<> struct BuiltinOptionsTraits<tflite::IfOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template<> struct BuiltinOptionsTraits<tflite::WhileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DepthToSpaceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV4Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template<> struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV5Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template<> struct BuiltinOptionsTraits<tflite::ScatterNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SelectV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template<> struct BuiltinOptionsTraits<tflite::DensifyOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template<> struct BuiltinOptionsTraits<tflite::SegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BatchMatMulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CumsumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template<> struct BuiltinOptionsTraits<tflite::CallOnceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BroadcastToOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Rfft2dOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template<> struct BuiltinOptionsTraits<tflite::Conv3DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableFindOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableImportOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template<> struct BuiltinOptionsTraits<tflite::HashtableSizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::VarHandleOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template<> struct BuiltinOptionsTraits<tflite::ReadVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::AssignVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template<> struct BuiltinOptionsTraits<tflite::RandomOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template<> struct BuiltinOptionsTraits<tflite::BucketizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template<> struct BuiltinOptionsTraits<tflite::GeluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

template<> struct BuiltinOptionsTraits<tflite::DynamicUpdateSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DynamicUpdateSliceOptions;
};

struct BuiltinOptionsUnion {
  BuiltinOptions type;
  void *value;

  BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
  BuiltinOptionsUnion(BuiltinOptionsUnion&& u) noexcept :
    type(BuiltinOptions_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BuiltinOptionsUnion(const BuiltinOptionsUnion &) noexcept;
  BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u) noexcept
    { BuiltinOptionsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) noexcept
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BuiltinOptionsUnion() { Reset(); }

  void Reset();


  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = BuiltinOptionsTraits<typename RT::TableType>::enum_value;
    if (type != BuiltinOptions_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }


  static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::Conv2DOptionsT *AsConv2DOptions() {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  const tflite::Conv2DOptionsT *AsConv2DOptions() const {
    return type == BuiltinOptions_Conv2DOptions ?
      reinterpret_cast<const tflite::Conv2DOptionsT *>(value) : nullptr;
  }
  tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  const tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
    return type == BuiltinOptions_DepthwiseConv2DOptions ?
      reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value) : nullptr;
  }
  tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
    return type == BuiltinOptions_ConcatEmbeddingsOptions ?
      reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value) : nullptr;
  }
  tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  const tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() const {
    return type == BuiltinOptions_LSHProjectionOptions ?
      reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value) : nullptr;
  }
  tflite::Pool2DOptionsT *AsPool2DOptions() {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  const tflite::Pool2DOptionsT *AsPool2DOptions() const {
    return type == BuiltinOptions_Pool2DOptions ?
      reinterpret_cast<const tflite::Pool2DOptionsT *>(value) : nullptr;
  }
  tflite::SVDFOptionsT *AsSVDFOptions() {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<tflite::SVDFOptionsT *>(value) : nullptr;
  }
  const tflite::SVDFOptionsT *AsSVDFOptions() const {
    return type == BuiltinOptions_SVDFOptions ?
      reinterpret_cast<const tflite::SVDFOptionsT *>(value) : nullptr;
  }
  tflite::RNNOptionsT *AsRNNOptions() {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<tflite::RNNOptionsT *>(value) : nullptr;
  }
  const tflite::RNNOptionsT *AsRNNOptions() const {
    return type == BuiltinOptions_RNNOptions ?
      reinterpret_cast<const tflite::RNNOptionsT *>(value) : nullptr;
  }
  tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  const tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() const {
    return type == BuiltinOptions_FullyConnectedOptions ?
      reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value) : nullptr;
  }
  tflite::SoftmaxOptionsT *AsSoftmaxOptions() {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::SoftmaxOptionsT *AsSoftmaxOptions() const {
    return type == BuiltinOptions_SoftmaxOptions ?
      reinterpret_cast<const tflite::SoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::ConcatenationOptionsT *AsConcatenationOptions() {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  const tflite::ConcatenationOptionsT *AsConcatenationOptions() const {
    return type == BuiltinOptions_ConcatenationOptions ?
      reinterpret_cast<const tflite::ConcatenationOptionsT *>(value) : nullptr;
  }
  tflite::AddOptionsT *AsAddOptions() {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<tflite::AddOptionsT *>(value) : nullptr;
  }
  const tflite::AddOptionsT *AsAddOptions() const {
    return type == BuiltinOptions_AddOptions ?
      reinterpret_cast<const tflite::AddOptionsT *>(value) : nullptr;
  }
  tflite::L2NormOptionsT *AsL2NormOptions() {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<tflite::L2NormOptionsT *>(value) : nullptr;
  }
  const tflite::L2NormOptionsT *AsL2NormOptions() const {
    return type == BuiltinOptions_L2NormOptions ?
      reinterpret_cast<const tflite::L2NormOptionsT *>(value) : nullptr;
  }
  tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
    return type == BuiltinOptions_LocalResponseNormalizationOptions ?
      reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value) : nullptr;
  }
  tflite::LSTMOptionsT *AsLSTMOptions() {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<tflite::LSTMOptionsT *>(value) : nullptr;
  }
  const tflite::LSTMOptionsT *AsLSTMOptions() const {
    return type == BuiltinOptions_LSTMOptions ?
      reinterpret_cast<const tflite::LSTMOptionsT *>(value) : nullptr;
  }
  tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
    return type == BuiltinOptions_ResizeBilinearOptions ?
      reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value) : nullptr;
  }
  tflite::CallOptionsT *AsCallOptions() {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<tflite::CallOptionsT *>(value) : nullptr;
  }
  const tflite::CallOptionsT *AsCallOptions() const {
    return type == BuiltinOptions_CallOptions ?
      reinterpret_cast<const tflite::CallOptionsT *>(value) : nullptr;
  }
  tflite::ReshapeOptionsT *AsReshapeOptions() {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  const tflite::ReshapeOptionsT *AsReshapeOptions() const {
    return type == BuiltinOptions_ReshapeOptions ?
      reinterpret_cast<const tflite::ReshapeOptionsT *>(value) : nullptr;
  }
  tflite::SkipGramOptionsT *AsSkipGramOptions() {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  const tflite::SkipGramOptionsT *AsSkipGramOptions() const {
    return type == BuiltinOptions_SkipGramOptions ?
      reinterpret_cast<const tflite::SkipGramOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
    return type == BuiltinOptions_SpaceToDepthOptions ?
      reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value) : nullptr;
  }
  tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
    return type == BuiltinOptions_EmbeddingLookupSparseOptions ?
      reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value) : nullptr;
  }
  tflite::MulOptionsT *AsMulOptions() {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<tflite::MulOptionsT *>(value) : nullptr;
  }
  const tflite::MulOptionsT *AsMulOptions() const {
    return type == BuiltinOptions_MulOptions ?
      reinterpret_cast<const tflite::MulOptionsT *>(value) : nullptr;
  }
  tflite::PadOptionsT *AsPadOptions() {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<tflite::PadOptionsT *>(value) : nullptr;
  }
  const tflite::PadOptionsT *AsPadOptions() const {
    return type == BuiltinOptions_PadOptions ?
      reinterpret_cast<const tflite::PadOptionsT *>(value) : nullptr;
  }
  tflite::GatherOptionsT *AsGatherOptions() {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<tflite::GatherOptionsT *>(value) : nullptr;
  }
  const tflite::GatherOptionsT *AsGatherOptions() const {
    return type == BuiltinOptions_GatherOptions ?
      reinterpret_cast<const tflite::GatherOptionsT *>(value) : nullptr;
  }
  tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  const tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
    return type == BuiltinOptions_BatchToSpaceNDOptions ?
      reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value) : nullptr;
  }
  tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  const tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
    return type == BuiltinOptions_SpaceToBatchNDOptions ?
      reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value) : nullptr;
  }
  tflite::TransposeOptionsT *AsTransposeOptions() {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<tflite::TransposeOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeOptionsT *AsTransposeOptions() const {
    return type == BuiltinOptions_TransposeOptions ?
      reinterpret_cast<const tflite::TransposeOptionsT *>(value) : nullptr;
  }
  tflite::ReducerOptionsT *AsReducerOptions() {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<tflite::ReducerOptionsT *>(value) : nullptr;
  }
  const tflite::ReducerOptionsT *AsReducerOptions() const {
    return type == BuiltinOptions_ReducerOptions ?
      reinterpret_cast<const tflite::ReducerOptionsT *>(value) : nullptr;
  }
  tflite::SubOptionsT *AsSubOptions() {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<tflite::SubOptionsT *>(value) : nullptr;
  }
  const tflite::SubOptionsT *AsSubOptions() const {
    return type == BuiltinOptions_SubOptions ?
      reinterpret_cast<const tflite::SubOptionsT *>(value) : nullptr;
  }
  tflite::DivOptionsT *AsDivOptions() {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<tflite::DivOptionsT *>(value) : nullptr;
  }
  const tflite::DivOptionsT *AsDivOptions() const {
    return type == BuiltinOptions_DivOptions ?
      reinterpret_cast<const tflite::DivOptionsT *>(value) : nullptr;
  }
  tflite::SqueezeOptionsT *AsSqueezeOptions() {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  const tflite::SqueezeOptionsT *AsSqueezeOptions() const {
    return type == BuiltinOptions_SqueezeOptions ?
      reinterpret_cast<const tflite::SqueezeOptionsT *>(value) : nullptr;
  }
  tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() const {
    return type == BuiltinOptions_SequenceRNNOptions ?
      reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::StridedSliceOptionsT *AsStridedSliceOptions() {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  const tflite::StridedSliceOptionsT *AsStridedSliceOptions() const {
    return type == BuiltinOptions_StridedSliceOptions ?
      reinterpret_cast<const tflite::StridedSliceOptionsT *>(value) : nullptr;
  }
  tflite::ExpOptionsT *AsExpOptions() {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<tflite::ExpOptionsT *>(value) : nullptr;
  }
  const tflite::ExpOptionsT *AsExpOptions() const {
    return type == BuiltinOptions_ExpOptions ?
      reinterpret_cast<const tflite::ExpOptionsT *>(value) : nullptr;
  }
  tflite::TopKV2OptionsT *AsTopKV2Options() {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  const tflite::TopKV2OptionsT *AsTopKV2Options() const {
    return type == BuiltinOptions_TopKV2Options ?
      reinterpret_cast<const tflite::TopKV2OptionsT *>(value) : nullptr;
  }
  tflite::SplitOptionsT *AsSplitOptions() {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<tflite::SplitOptionsT *>(value) : nullptr;
  }
  const tflite::SplitOptionsT *AsSplitOptions() const {
    return type == BuiltinOptions_SplitOptions ?
      reinterpret_cast<const tflite::SplitOptionsT *>(value) : nullptr;
  }
  tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  const tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
    return type == BuiltinOptions_LogSoftmaxOptions ?
      reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value) : nullptr;
  }
  tflite::CastOptionsT *AsCastOptions() {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<tflite::CastOptionsT *>(value) : nullptr;
  }
  const tflite::CastOptionsT *AsCastOptions() const {
    return type == BuiltinOptions_CastOptions ?
      reinterpret_cast<const tflite::CastOptionsT *>(value) : nullptr;
  }
  tflite::DequantizeOptionsT *AsDequantizeOptions() {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  const tflite::DequantizeOptionsT *AsDequantizeOptions() const {
    return type == BuiltinOptions_DequantizeOptions ?
      reinterpret_cast<const tflite::DequantizeOptionsT *>(value) : nullptr;
  }
  tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  const tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
    return type == BuiltinOptions_MaximumMinimumOptions ?
      reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value) : nullptr;
  }
  tflite::ArgMaxOptionsT *AsArgMaxOptions() {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMaxOptionsT *AsArgMaxOptions() const {
    return type == BuiltinOptions_ArgMaxOptions ?
      reinterpret_cast<const tflite::ArgMaxOptionsT *>(value) : nullptr;
  }
  tflite::LessOptionsT *AsLessOptions() {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<tflite::LessOptionsT *>(value) : nullptr;
  }
  const tflite::LessOptionsT *AsLessOptions() const {
    return type == BuiltinOptions_LessOptions ?
      reinterpret_cast<const tflite::LessOptionsT *>(value) : nullptr;
  }
  tflite::NegOptionsT *AsNegOptions() {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<tflite::NegOptionsT *>(value) : nullptr;
  }
  const tflite::NegOptionsT *AsNegOptions() const {
    return type == BuiltinOptions_NegOptions ?
      reinterpret_cast<const tflite::NegOptionsT *>(value) : nullptr;
  }
  tflite::PadV2OptionsT *AsPadV2Options() {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<tflite::PadV2OptionsT *>(value) : nullptr;
  }
  const tflite::PadV2OptionsT *AsPadV2Options() const {
    return type == BuiltinOptions_PadV2Options ?
      reinterpret_cast<const tflite::PadV2OptionsT *>(value) : nullptr;
  }
  tflite::GreaterOptionsT *AsGreaterOptions() {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<tflite::GreaterOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterOptionsT *AsGreaterOptions() const {
    return type == BuiltinOptions_GreaterOptions ?
      reinterpret_cast<const tflite::GreaterOptionsT *>(value) : nullptr;
  }
  tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  const tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() const {
    return type == BuiltinOptions_GreaterEqualOptions ?
      reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value) : nullptr;
  }
  tflite::LessEqualOptionsT *AsLessEqualOptions() {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  const tflite::LessEqualOptionsT *AsLessEqualOptions() const {
    return type == BuiltinOptions_LessEqualOptions ?
      reinterpret_cast<const tflite::LessEqualOptionsT *>(value) : nullptr;
  }
  tflite::SelectOptionsT *AsSelectOptions() {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<tflite::SelectOptionsT *>(value) : nullptr;
  }
  const tflite::SelectOptionsT *AsSelectOptions() const {
    return type == BuiltinOptions_SelectOptions ?
      reinterpret_cast<const tflite::SelectOptionsT *>(value) : nullptr;
  }
  tflite::SliceOptionsT *AsSliceOptions() {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<tflite::SliceOptionsT *>(value) : nullptr;
  }
  const tflite::SliceOptionsT *AsSliceOptions() const {
    return type == BuiltinOptions_SliceOptions ?
      reinterpret_cast<const tflite::SliceOptionsT *>(value) : nullptr;
  }
  tflite::TransposeConvOptionsT *AsTransposeConvOptions() {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  const tflite::TransposeConvOptionsT *AsTransposeConvOptions() const {
    return type == BuiltinOptions_TransposeConvOptions ?
      reinterpret_cast<const tflite::TransposeConvOptionsT *>(value) : nullptr;
  }
  tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  const tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() const {
    return type == BuiltinOptions_SparseToDenseOptions ?
      reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value) : nullptr;
  }
  tflite::TileOptionsT *AsTileOptions() {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<tflite::TileOptionsT *>(value) : nullptr;
  }
  const tflite::TileOptionsT *AsTileOptions() const {
    return type == BuiltinOptions_TileOptions ?
      reinterpret_cast<const tflite::TileOptionsT *>(value) : nullptr;
  }
  tflite::ExpandDimsOptionsT *AsExpandDimsOptions() {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  const tflite::ExpandDimsOptionsT *AsExpandDimsOptions() const {
    return type == BuiltinOptions_ExpandDimsOptions ?
      reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value) : nullptr;
  }
  tflite::EqualOptionsT *AsEqualOptions() {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<tflite::EqualOptionsT *>(value) : nullptr;
  }
  const tflite::EqualOptionsT *AsEqualOptions() const {
    return type == BuiltinOptions_EqualOptions ?
      reinterpret_cast<const tflite::EqualOptionsT *>(value) : nullptr;
  }
  tflite::NotEqualOptionsT *AsNotEqualOptions() {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  const tflite::NotEqualOptionsT *AsNotEqualOptions() const {
    return type == BuiltinOptions_NotEqualOptions ?
      reinterpret_cast<const tflite::NotEqualOptionsT *>(value) : nullptr;
  }
  tflite::ShapeOptionsT *AsShapeOptions() {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<tflite::ShapeOptionsT *>(value) : nullptr;
  }
  const tflite::ShapeOptionsT *AsShapeOptions() const {
    return type == BuiltinOptions_ShapeOptions ?
      reinterpret_cast<const tflite::ShapeOptionsT *>(value) : nullptr;
  }
  tflite::PowOptionsT *AsPowOptions() {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<tflite::PowOptionsT *>(value) : nullptr;
  }
  const tflite::PowOptionsT *AsPowOptions() const {
    return type == BuiltinOptions_PowOptions ?
      reinterpret_cast<const tflite::PowOptionsT *>(value) : nullptr;
  }
  tflite::ArgMinOptionsT *AsArgMinOptions() {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  const tflite::ArgMinOptionsT *AsArgMinOptions() const {
    return type == BuiltinOptions_ArgMinOptions ?
      reinterpret_cast<const tflite::ArgMinOptionsT *>(value) : nullptr;
  }
  tflite::FakeQuantOptionsT *AsFakeQuantOptions() {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  const tflite::FakeQuantOptionsT *AsFakeQuantOptions() const {
    return type == BuiltinOptions_FakeQuantOptions ?
      reinterpret_cast<const tflite::FakeQuantOptionsT *>(value) : nullptr;
  }
  tflite::PackOptionsT *AsPackOptions() {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<tflite::PackOptionsT *>(value) : nullptr;
  }
  const tflite::PackOptionsT *AsPackOptions() const {
    return type == BuiltinOptions_PackOptions ?
      reinterpret_cast<const tflite::PackOptionsT *>(value) : nullptr;
  }
  tflite::LogicalOrOptionsT *AsLogicalOrOptions() {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalOrOptionsT *AsLogicalOrOptions() const {
    return type == BuiltinOptions_LogicalOrOptions ?
      reinterpret_cast<const tflite::LogicalOrOptionsT *>(value) : nullptr;
  }
  tflite::OneHotOptionsT *AsOneHotOptions() {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<tflite::OneHotOptionsT *>(value) : nullptr;
  }
  const tflite::OneHotOptionsT *AsOneHotOptions() const {
    return type == BuiltinOptions_OneHotOptions ?
      reinterpret_cast<const tflite::OneHotOptionsT *>(value) : nullptr;
  }
  tflite::LogicalAndOptionsT *AsLogicalAndOptions() {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalAndOptionsT *AsLogicalAndOptions() const {
    return type == BuiltinOptions_LogicalAndOptions ?
      reinterpret_cast<const tflite::LogicalAndOptionsT *>(value) : nullptr;
  }
  tflite::LogicalNotOptionsT *AsLogicalNotOptions() {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  const tflite::LogicalNotOptionsT *AsLogicalNotOptions() const {
    return type == BuiltinOptions_LogicalNotOptions ?
      reinterpret_cast<const tflite::LogicalNotOptionsT *>(value) : nullptr;
  }
  tflite::UnpackOptionsT *AsUnpackOptions() {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<tflite::UnpackOptionsT *>(value) : nullptr;
  }
  const tflite::UnpackOptionsT *AsUnpackOptions() const {
    return type == BuiltinOptions_UnpackOptions ?
      reinterpret_cast<const tflite::UnpackOptionsT *>(value) : nullptr;
  }
  tflite::FloorDivOptionsT *AsFloorDivOptions() {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  const tflite::FloorDivOptionsT *AsFloorDivOptions() const {
    return type == BuiltinOptions_FloorDivOptions ?
      reinterpret_cast<const tflite::FloorDivOptionsT *>(value) : nullptr;
  }
  tflite::SquareOptionsT *AsSquareOptions() {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<tflite::SquareOptionsT *>(value) : nullptr;
  }
  const tflite::SquareOptionsT *AsSquareOptions() const {
    return type == BuiltinOptions_SquareOptions ?
      reinterpret_cast<const tflite::SquareOptionsT *>(value) : nullptr;
  }
  tflite::ZerosLikeOptionsT *AsZerosLikeOptions() {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  const tflite::ZerosLikeOptionsT *AsZerosLikeOptions() const {
    return type == BuiltinOptions_ZerosLikeOptions ?
      reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value) : nullptr;
  }
  tflite::FillOptionsT *AsFillOptions() {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<tflite::FillOptionsT *>(value) : nullptr;
  }
  const tflite::FillOptionsT *AsFillOptions() const {
    return type == BuiltinOptions_FillOptions ?
      reinterpret_cast<const tflite::FillOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const {
    return type == BuiltinOptions_BidirectionalSequenceRNNOptions ?
      reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value) : nullptr;
  }
  tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const {
    return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions ?
      reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value) : nullptr;
  }
  tflite::FloorModOptionsT *AsFloorModOptions() {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<tflite::FloorModOptionsT *>(value) : nullptr;
  }
  const tflite::FloorModOptionsT *AsFloorModOptions() const {
    return type == BuiltinOptions_FloorModOptions ?
      reinterpret_cast<const tflite::FloorModOptionsT *>(value) : nullptr;
  }
  tflite::RangeOptionsT *AsRangeOptions() {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<tflite::RangeOptionsT *>(value) : nullptr;
  }
  const tflite::RangeOptionsT *AsRangeOptions() const {
    return type == BuiltinOptions_RangeOptions ?
      reinterpret_cast<const tflite::RangeOptionsT *>(value) : nullptr;
  }
  tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const {
    return type == BuiltinOptions_ResizeNearestNeighborOptions ?
      reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value) : nullptr;
  }
  tflite::LeakyReluOptionsT *AsLeakyReluOptions() {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  const tflite::LeakyReluOptionsT *AsLeakyReluOptions() const {
    return type == BuiltinOptions_LeakyReluOptions ?
      reinterpret_cast<const tflite::LeakyReluOptionsT *>(value) : nullptr;
  }
  tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  const tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const {
    return type == BuiltinOptions_SquaredDifferenceOptions ?
      reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value) : nullptr;
  }
  tflite::MirrorPadOptionsT *AsMirrorPadOptions() {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  const tflite::MirrorPadOptionsT *AsMirrorPadOptions() const {
    return type == BuiltinOptions_MirrorPadOptions ?
      reinterpret_cast<const tflite::MirrorPadOptionsT *>(value) : nullptr;
  }
  tflite::AbsOptionsT *AsAbsOptions() {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<tflite::AbsOptionsT *>(value) : nullptr;
  }
  const tflite::AbsOptionsT *AsAbsOptions() const {
    return type == BuiltinOptions_AbsOptions ?
      reinterpret_cast<const tflite::AbsOptionsT *>(value) : nullptr;
  }
  tflite::SplitVOptionsT *AsSplitVOptions() {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<tflite::SplitVOptionsT *>(value) : nullptr;
  }
  const tflite::SplitVOptionsT *AsSplitVOptions() const {
    return type == BuiltinOptions_SplitVOptions ?
      reinterpret_cast<const tflite::SplitVOptionsT *>(value) : nullptr;
  }
  tflite::UniqueOptionsT *AsUniqueOptions() {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<tflite::UniqueOptionsT *>(value) : nullptr;
  }
  const tflite::UniqueOptionsT *AsUniqueOptions() const {
    return type == BuiltinOptions_UniqueOptions ?
      reinterpret_cast<const tflite::UniqueOptionsT *>(value) : nullptr;
  }
  tflite::ReverseV2OptionsT *AsReverseV2Options() {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<tflite::ReverseV2OptionsT *>(value) : nullptr;
  }
  const tflite::ReverseV2OptionsT *AsReverseV2Options() const {
    return type == BuiltinOptions_ReverseV2Options ?
      reinterpret_cast<const tflite::ReverseV2OptionsT *>(value) : nullptr;
  }
  tflite::AddNOptionsT *AsAddNOptions() {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<tflite::AddNOptionsT *>(value) : nullptr;
  }
  const tflite::AddNOptionsT *AsAddNOptions() const {
    return type == BuiltinOptions_AddNOptions ?
      reinterpret_cast<const tflite::AddNOptionsT *>(value) : nullptr;
  }
  tflite::GatherNdOptionsT *AsGatherNdOptions() {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<tflite::GatherNdOptionsT *>(value) : nullptr;
  }
  const tflite::GatherNdOptionsT *AsGatherNdOptions() const {
    return type == BuiltinOptions_GatherNdOptions ?
      reinterpret_cast<const tflite::GatherNdOptionsT *>(value) : nullptr;
  }
  tflite::CosOptionsT *AsCosOptions() {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<tflite::CosOptionsT *>(value) : nullptr;
  }
  const tflite::CosOptionsT *AsCosOptions() const {
    return type == BuiltinOptions_CosOptions ?
      reinterpret_cast<const tflite::CosOptionsT *>(value) : nullptr;
  }
  tflite::WhereOptionsT *AsWhereOptions() {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<tflite::WhereOptionsT *>(value) : nullptr;
  }
  const tflite::WhereOptionsT *AsWhereOptions() const {
    return type == BuiltinOptions_WhereOptions ?
      reinterpret_cast<const tflite::WhereOptionsT *>(value) : nullptr;
  }
  tflite::RankOptionsT *AsRankOptions() {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<tflite::RankOptionsT *>(value) : nullptr;
  }
  const tflite::RankOptionsT *AsRankOptions() const {
    return type == BuiltinOptions_RankOptions ?
      reinterpret_cast<const tflite::RankOptionsT *>(value) : nullptr;
  }
  tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value) : nullptr;
  }
  const tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() const {
    return type == BuiltinOptions_ReverseSequenceOptions ?
      reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value) : nullptr;
  }
  tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<tflite::MatrixDiagOptionsT *>(value) : nullptr;
  }
  const tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() const {
    return type == BuiltinOptions_MatrixDiagOptions ?
      reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value) : nullptr;
  }
  tflite::QuantizeOptionsT *AsQuantizeOptions() {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<tflite::QuantizeOptionsT *>(value) : nullptr;
  }
  const tflite::QuantizeOptionsT *AsQuantizeOptions() const {
    return type == BuiltinOptions_QuantizeOptions ?
      reinterpret_cast<const tflite::QuantizeOptionsT *>(value) : nullptr;
  }
  tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  const tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() const {
    return type == BuiltinOptions_MatrixSetDiagOptions ?
      reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value) : nullptr;
  }
  tflite::HardSwishOptionsT *AsHardSwishOptions() {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<tflite::HardSwishOptionsT *>(value) : nullptr;
  }
  const tflite::HardSwishOptionsT *AsHardSwishOptions() const {
    return type == BuiltinOptions_HardSwishOptions ?
      reinterpret_cast<const tflite::HardSwishOptionsT *>(value) : nullptr;
  }
  tflite::IfOptionsT *AsIfOptions() {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<tflite::IfOptionsT *>(value) : nullptr;
  }
  const tflite::IfOptionsT *AsIfOptions() const {
    return type == BuiltinOptions_IfOptions ?
      reinterpret_cast<const tflite::IfOptionsT *>(value) : nullptr;
  }
  tflite::WhileOptionsT *AsWhileOptions() {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<tflite::WhileOptionsT *>(value) : nullptr;
  }
  const tflite::WhileOptionsT *AsWhileOptions() const {
    return type == BuiltinOptions_WhileOptions ?
      reinterpret_cast<const tflite::WhileOptionsT *>(value) : nullptr;
  }
  tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value) : nullptr;
  }
  const tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() const {
    return type == BuiltinOptions_DepthToSpaceOptions ?
      reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value) : nullptr;
  }
  tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  const tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV4Options ?
      reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value) : nullptr;
  }
  tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  const tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() const {
    return type == BuiltinOptions_NonMaxSuppressionV5Options ?
      reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value) : nullptr;
  }
  tflite::ScatterNdOptionsT *AsScatterNdOptions() {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<tflite::ScatterNdOptionsT *>(value) : nullptr;
  }
  const tflite::ScatterNdOptionsT *AsScatterNdOptions() const {
    return type == BuiltinOptions_ScatterNdOptions ?
      reinterpret_cast<const tflite::ScatterNdOptionsT *>(value) : nullptr;
  }
  tflite::SelectV2OptionsT *AsSelectV2Options() {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<tflite::SelectV2OptionsT *>(value) : nullptr;
  }
  const tflite::SelectV2OptionsT *AsSelectV2Options() const {
    return type == BuiltinOptions_SelectV2Options ?
      reinterpret_cast<const tflite::SelectV2OptionsT *>(value) : nullptr;
  }
  tflite::DensifyOptionsT *AsDensifyOptions() {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<tflite::DensifyOptionsT *>(value) : nullptr;
  }
  const tflite::DensifyOptionsT *AsDensifyOptions() const {
    return type == BuiltinOptions_DensifyOptions ?
      reinterpret_cast<const tflite::DensifyOptionsT *>(value) : nullptr;
  }
  tflite::SegmentSumOptionsT *AsSegmentSumOptions() {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<tflite::SegmentSumOptionsT *>(value) : nullptr;
  }
  const tflite::SegmentSumOptionsT *AsSegmentSumOptions() const {
    return type == BuiltinOptions_SegmentSumOptions ?
      reinterpret_cast<const tflite::SegmentSumOptionsT *>(value) : nullptr;
  }
  tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<tflite::BatchMatMulOptionsT *>(value) : nullptr;
  }
  const tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() const {
    return type == BuiltinOptions_BatchMatMulOptions ?
      reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value) : nullptr;
  }
  tflite::CumsumOptionsT *AsCumsumOptions() {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<tflite::CumsumOptionsT *>(value) : nullptr;
  }
  const tflite::CumsumOptionsT *AsCumsumOptions() const {
    return type == BuiltinOptions_CumsumOptions ?
      reinterpret_cast<const tflite::CumsumOptionsT *>(value) : nullptr;
  }
  tflite::CallOnceOptionsT *AsCallOnceOptions() {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<tflite::CallOnceOptionsT *>(value) : nullptr;
  }
  const tflite::CallOnceOptionsT *AsCallOnceOptions() const {
    return type == BuiltinOptions_CallOnceOptions ?
      reinterpret_cast<const tflite::CallOnceOptionsT *>(value) : nullptr;
  }
  tflite::BroadcastToOptionsT *AsBroadcastToOptions() {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<tflite::BroadcastToOptionsT *>(value) : nullptr;
  }
  const tflite::BroadcastToOptionsT *AsBroadcastToOptions() const {
    return type == BuiltinOptions_BroadcastToOptions ?
      reinterpret_cast<const tflite::BroadcastToOptionsT *>(value) : nullptr;
  }
  tflite::Rfft2dOptionsT *AsRfft2dOptions() {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<tflite::Rfft2dOptionsT *>(value) : nullptr;
  }
  const tflite::Rfft2dOptionsT *AsRfft2dOptions() const {
    return type == BuiltinOptions_Rfft2dOptions ?
      reinterpret_cast<const tflite::Rfft2dOptionsT *>(value) : nullptr;
  }
  tflite::Conv3DOptionsT *AsConv3DOptions() {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<tflite::Conv3DOptionsT *>(value) : nullptr;
  }
  const tflite::Conv3DOptionsT *AsConv3DOptions() const {
    return type == BuiltinOptions_Conv3DOptions ?
      reinterpret_cast<const tflite::Conv3DOptionsT *>(value) : nullptr;
  }
  tflite::HashtableOptionsT *AsHashtableOptions() {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<tflite::HashtableOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableOptionsT *AsHashtableOptions() const {
    return type == BuiltinOptions_HashtableOptions ?
      reinterpret_cast<const tflite::HashtableOptionsT *>(value) : nullptr;
  }
  tflite::HashtableFindOptionsT *AsHashtableFindOptions() {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<tflite::HashtableFindOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableFindOptionsT *AsHashtableFindOptions() const {
    return type == BuiltinOptions_HashtableFindOptions ?
      reinterpret_cast<const tflite::HashtableFindOptionsT *>(value) : nullptr;
  }
  tflite::HashtableImportOptionsT *AsHashtableImportOptions() {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<tflite::HashtableImportOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableImportOptionsT *AsHashtableImportOptions() const {
    return type == BuiltinOptions_HashtableImportOptions ?
      reinterpret_cast<const tflite::HashtableImportOptionsT *>(value) : nullptr;
  }
  tflite::HashtableSizeOptionsT *AsHashtableSizeOptions() {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<tflite::HashtableSizeOptionsT *>(value) : nullptr;
  }
  const tflite::HashtableSizeOptionsT *AsHashtableSizeOptions() const {
    return type == BuiltinOptions_HashtableSizeOptions ?
      reinterpret_cast<const tflite::HashtableSizeOptionsT *>(value) : nullptr;
  }
  tflite::VarHandleOptionsT *AsVarHandleOptions() {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<tflite::VarHandleOptionsT *>(value) : nullptr;
  }
  const tflite::VarHandleOptionsT *AsVarHandleOptions() const {
    return type == BuiltinOptions_VarHandleOptions ?
      reinterpret_cast<const tflite::VarHandleOptionsT *>(value) : nullptr;
  }
  tflite::ReadVariableOptionsT *AsReadVariableOptions() {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<tflite::ReadVariableOptionsT *>(value) : nullptr;
  }
  const tflite::ReadVariableOptionsT *AsReadVariableOptions() const {
    return type == BuiltinOptions_ReadVariableOptions ?
      reinterpret_cast<const tflite::ReadVariableOptionsT *>(value) : nullptr;
  }
  tflite::AssignVariableOptionsT *AsAssignVariableOptions() {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<tflite::AssignVariableOptionsT *>(value) : nullptr;
  }
  const tflite::AssignVariableOptionsT *AsAssignVariableOptions() const {
    return type == BuiltinOptions_AssignVariableOptions ?
      reinterpret_cast<const tflite::AssignVariableOptionsT *>(value) : nullptr;
  }
  tflite::RandomOptionsT *AsRandomOptions() {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<tflite::RandomOptionsT *>(value) : nullptr;
  }
  const tflite::RandomOptionsT *AsRandomOptions() const {
    return type == BuiltinOptions_RandomOptions ?
      reinterpret_cast<const tflite::RandomOptionsT *>(value) : nullptr;
  }
  tflite::BucketizeOptionsT *AsBucketizeOptions() {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<tflite::BucketizeOptionsT *>(value) : nullptr;
  }
  const tflite::BucketizeOptionsT *AsBucketizeOptions() const {
    return type == BuiltinOptions_BucketizeOptions ?
      reinterpret_cast<const tflite::BucketizeOptionsT *>(value) : nullptr;
  }
  tflite::GeluOptionsT *AsGeluOptions() {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<tflite::GeluOptionsT *>(value) : nullptr;
  }
  const tflite::GeluOptionsT *AsGeluOptions() const {
    return type == BuiltinOptions_GeluOptions ?
      reinterpret_cast<const tflite::GeluOptionsT *>(value) : nullptr;
  }
  tflite::DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
  const tflite::DynamicUpdateSliceOptionsT *AsDynamicUpdateSliceOptions() const {
    return type == BuiltinOptions_DynamicUpdateSliceOptions ?
      reinterpret_cast<const tflite::DynamicUpdateSliceOptionsT *>(value) : nullptr;
  }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[3] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[7] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[3] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  if (flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[3] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[4] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[3] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[2] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantizationT : public flatbuffers::NativeTable {
  typedef CustomQuantization TableType;
  std::vector<uint8_t> custom;
  CustomQuantizationT() {
  }
};

struct CustomQuantization final : private flatbuffers::Table {
  typedef CustomQuantizationT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
  CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  if (custom) { _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16); }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      custom__);
}

flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public flatbuffers::NativeTable {
  typedef QuantizationParameters TableType;
  std::vector<float> min;
  std::vector<float> max;
  std::vector<float> scale;
  std::vector<int64_t> zero_point;
  tflite::QuantizationDetailsUnion details;
  int32_t quantized_dimension;
  QuantizationParametersT()
      : quantized_dimension(0) {
  }
};

struct QuantizationParameters final : private flatbuffers::Table {
  typedef QuantizationParametersT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  tflite::QuantizationDetails details_type() const {
    return static_cast<tflite::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const tflite::CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == tflite::QuantizationDetails_CustomQuantization ? static_cast<const tflite::CustomQuantization *>(details()) : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) &&
           verifier.EndTable();
  }
  QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizationParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::CustomQuantization *QuantizationParameters::details_as<tflite::CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(tflite::QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point = nullptr,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return tflite::CreateQuantizationParameters(
      _fbb,
      min__,
      max__,
      scale__,
      zero_point__,
      details_type,
      details,
      quantized_dimension);
}

flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32VectorT : public flatbuffers::NativeTable {
  typedef Int32Vector TableType;
  std::vector<int32_t> values;
  Int32VectorT() {
  }
};

struct Int32Vector final : private flatbuffers::Table {
  typedef Int32VectorT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Int32VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Int32Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32VectorBuilder &operator=(const Int32VectorBuilder &);
  flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return tflite::CreateInt32Vector(
      _fbb,
      values__);
}

flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint16VectorT : public flatbuffers::NativeTable {
  typedef Uint16Vector TableType;
  std::vector<uint16_t> values;
  Uint16VectorT() {
  }
};

struct Uint16Vector final : private flatbuffers::Table {
  typedef Uint16VectorT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint16_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint16VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint16Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint16VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint16VectorBuilder &operator=(const Uint16VectorBuilder &);
  flatbuffers::Offset<Uint16Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *values = nullptr) {
  if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4); }
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return tflite::CreateUint16Vector(
      _fbb,
      values__);
}

flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint8VectorT : public flatbuffers::NativeTable {
  typedef Uint8Vector TableType;
  std::vector<uint8_t> values;
  Uint8VectorT() {
  }
};

struct Uint8Vector final : private flatbuffers::Table {
  typedef Uint8VectorT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  Uint8VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Uint8Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint8VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint8VectorBuilder &operator=(const Uint8VectorBuilder &);
  flatbuffers::Offset<Uint8Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *values = nullptr) {
  if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4); }
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return tflite::CreateUint8Vector(
      _fbb,
      values__);
}

flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DimensionMetadataT : public flatbuffers::NativeTable {
  typedef DimensionMetadata TableType;
  tflite::DimensionType format;
  int32_t dense_size;
  tflite::SparseIndexVectorUnion array_segments;
  tflite::SparseIndexVectorUnion array_indices;
  DimensionMetadataT()
      : format(tflite::DimensionType_DENSE),
        dense_size(0) {
  }
};

struct DimensionMetadata final : private flatbuffers::Table {
  typedef DimensionMetadataT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  tflite::DimensionType format() const {
    return static_cast<tflite::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const {
    return GetField<int32_t>(VT_DENSE_SIZE, 0);
  }
  tflite::SparseIndexVector array_segments_type() const {
    return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void *array_segments() const {
    return GetPointer<const void *>(VT_ARRAY_SEGMENTS);
  }
  template<typename T> const T *array_segments_as() const;
  const tflite::Int32Vector *array_segments_as_Int32Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Int32Vector ? static_cast<const tflite::Int32Vector *>(array_segments()) : nullptr;
  }
  const tflite::Uint16Vector *array_segments_as_Uint16Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint16Vector ? static_cast<const tflite::Uint16Vector *>(array_segments()) : nullptr;
  }
  const tflite::Uint8Vector *array_segments_as_Uint8Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint8Vector ? static_cast<const tflite::Uint8Vector *>(array_segments()) : nullptr;
  }
  tflite::SparseIndexVector array_indices_type() const {
    return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void *array_indices() const {
    return GetPointer<const void *>(VT_ARRAY_INDICES);
  }
  template<typename T> const T *array_indices_as() const;
  const tflite::Int32Vector *array_indices_as_Int32Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Int32Vector ? static_cast<const tflite::Int32Vector *>(array_indices()) : nullptr;
  }
  const tflite::Uint16Vector *array_indices_as_Uint16Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint16Vector ? static_cast<const tflite::Uint16Vector *>(array_indices()) : nullptr;
  }
  const tflite::Uint8Vector *array_indices_as_Uint8Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint8Vector ? static_cast<const tflite::Uint8Vector *>(array_indices()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
  DimensionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DimensionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::Int32Vector *DimensionMetadata::array_segments_as<tflite::Int32Vector>() const {
  return array_segments_as_Int32Vector();
}

template<> inline const tflite::Uint16Vector *DimensionMetadata::array_segments_as<tflite::Uint16Vector>() const {
  return array_segments_as_Uint16Vector();
}

template<> inline const tflite::Uint8Vector *DimensionMetadata::array_segments_as<tflite::Uint8Vector>() const {
  return array_segments_as_Uint8Vector();
}

template<> inline const tflite::Int32Vector *DimensionMetadata::array_indices_as<tflite::Int32Vector>() const {
  return array_indices_as_Int32Vector();
}

template<> inline const tflite::Uint16Vector *DimensionMetadata::array_indices_as<tflite::Uint16Vector>() const {
  return array_indices_as_Uint16Vector();
}

template<> inline const tflite::Uint8Vector *DimensionMetadata::array_indices_as<tflite::Uint8Vector>() const {
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(tflite::DimensionType format) {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size) {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(tflite::SparseIndexVector array_segments_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(flatbuffers::Offset<void> array_segments) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(tflite::SparseIndexVector array_indices_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(flatbuffers::Offset<void> array_indices) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionMetadataBuilder &operator=(const DimensionMetadataBuilder &);
  flatbuffers::Offset<DimensionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::DimensionType format = tflite::DimensionType_DENSE,
    int32_t dense_size = 0,
    tflite::SparseIndexVector array_segments_type = tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_segments = 0,
    tflite::SparseIndexVector array_indices_type = tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_indices = 0) {
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparsityParametersT : public flatbuffers::NativeTable {
  typedef SparsityParameters TableType;
  std::vector<int32_t> traversal_order;
  std::vector<int32_t> block_map;
  std::vector<std::unique_ptr<tflite::DimensionMetadataT>> dim_metadata;
  SparsityParametersT() {
  }
};

struct SparsityParameters final : private flatbuffers::Table {
  typedef SparsityParametersT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const flatbuffers::Vector<int32_t> *traversal_order() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
  }
  const flatbuffers::Vector<int32_t> *block_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *>(VT_DIM_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) &&
           VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) &&
           VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) &&
           verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
  SparsityParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparsityParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparsityParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata) {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparsityParametersBuilder &operator=(const SparsityParametersBuilder &);
  flatbuffers::Offset<SparsityParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata = 0) {
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *traversal_order = nullptr,
    const std::vector<int32_t> *block_map = nullptr,
    const std::vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata = nullptr) {
  auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ = dim_metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>>(*dim_metadata) : 0;
  return tflite::CreateSparsityParameters(
      _fbb,
      traversal_order__,
      block_map__,
      dim_metadata__);
}

flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
  typedef Tensor TableType;
  std::vector<int32_t> shape;
  tflite::TensorType type;
  uint32_t buffer;
  std::string name;
  std::unique_ptr<tflite::QuantizationParametersT> quantization;
  bool is_variable;
  std::unique_ptr<tflite::SparsityParametersT> sparsity;
  std::vector<int32_t> shape_signature;
  TensorT()
      : type(tflite::TensorType_FLOAT32),
        buffer(0),
        is_variable(false) {
  }
};

struct Tensor final : private flatbuffers::Table {
  typedef TensorT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18
  };
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  tflite::TensorType type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const tflite::QuantizationParameters *quantization() const {
    return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const {
    return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
  }
  const tflite::SparsityParameters *sparsity() const {
    return GetPointer<const tflite::SparsityParameters *>(VT_SPARSITY);
  }
  const flatbuffers::Vector<int32_t> *shape_signature() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           VerifyOffset(verifier, VT_SPARSITY) &&
           verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) &&
           verifier.VerifyVector(shape_signature()) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(tflite::TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(flatbuffers::Offset<tflite::SparsityParameters> sparsity) {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32,
    uint32_t buffer = 0,
    const char *name = nullptr,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    const std::vector<int32_t> *shape_signature = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  return tflite::CreateTensor(
      _fbb,
      shape__,
      type,
      buffer,
      name__,
      quantization,
      is_variable,
      sparsity,
      shape_signature__);
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable {
  typedef Conv2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  tflite::ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  Conv2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct Conv2DOptions final : private flatbuffers::Table {
  typedef Conv2DOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
  Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionsT : public flatbuffers::NativeTable {
  typedef Conv3DOptions TableType;
  tflite::Padding padding;
  int32_t stride_d;
  int32_t stride_w;
  int32_t stride_h;
  tflite::ActivationFunctionType fused_activation_function;
  int32_t dilation_d_factor;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  Conv3DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_d(0),
        stride_w(0),
        stride_h(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        dilation_d_factor(1),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct Conv3DOptions final : private flatbuffers::Table {
  typedef Conv3DOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const {
    return GetField<int32_t>(VT_STRIDE_D, 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const {
    return GetField<int32_t>(VT_DILATION_D_FACTOR, 1);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
  Conv3DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv3DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv3DOptionsBuilder &operator=(const Conv3DOptionsBuilder &);
  flatbuffers::Offset<Conv3DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_d = 0,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_d_factor = 1,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable {
  typedef Pool2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t filter_width;
  int32_t filter_height;
  tflite::ActivationFunctionType fused_activation_function;
  Pool2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        filter_width(0),
        filter_height(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct Pool2DOptions final : private flatbuffers::Table {
  typedef Pool2DOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(VT_FILTER_WIDTH, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {
  typedef DepthwiseConv2DOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  int32_t depth_multiplier;
  tflite::ActivationFunctionType fused_activation_function;
  int32_t dilation_w_factor;
  int32_t dilation_h_factor;
  DepthwiseConv2DOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0),
        depth_multiplier(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        dilation_w_factor(1),
        dilation_h_factor(1) {
  }
};

struct DepthwiseConv2DOptions final : private flatbuffers::Table {
  typedef DepthwiseConv2DOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
  DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {
  typedef ConcatEmbeddingsOptions TableType;
  int32_t num_channels;
  std::vector<int32_t> num_columns_per_channel;
  std::vector<int32_t> embedding_dim_per_channel;
  ConcatEmbeddingsOptionsT()
      : num_channels(0) {
  }
};

struct ConcatEmbeddingsOptions final : private flatbuffers::Table {
  typedef ConcatEmbeddingsOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const {
    return GetField<int32_t>(VT_NUM_CHANNELS, 0);
  }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
  ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
  auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ = embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      num_channels,
      num_columns_per_channel__,
      embedding_dim_per_channel__);
}

flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable {
  typedef LSHProjectionOptions TableType;
  tflite::LSHProjectionType type;
  LSHProjectionOptionsT()
      : type(tflite::LSHProjectionType_UNKNOWN) {
  }
};

struct LSHProjectionOptions final : private flatbuffers::Table {
  typedef LSHProjectionOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TYPE = 4
  };
  tflite::LSHProjectionType type() const {
    return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(tflite::LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable {
  typedef SVDFOptions TableType;
  int32_t rank;
  tflite::ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  SVDFOptionsT()
      : rank(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct SVDFOptions final : private flatbuffers::Table {
  typedef SVDFOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable {
  typedef RNNOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  RNNOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct RNNOptions final : private flatbuffers::Table {
  typedef RNNOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef SequenceRNNOptions TableType;
  bool time_major;
  tflite::ActivationFunctionType fused_activation_function;
  bool asymmetric_quantize_inputs;
  SequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        asymmetric_quantize_inputs(false) {
  }
};

struct SequenceRNNOptions final : private flatbuffers::Table {
  typedef SequenceRNNOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceRNNOptions TableType;
  bool time_major;
  tflite::ActivationFunctionType fused_activation_function;
  bool merge_outputs;
  bool asymmetric_quantize_inputs;
  BidirectionalSequenceRNNOptionsT()
      : time_major(false),
        fused_activation_function(tflite::ActivationFunctionType_NONE),
        merge_outputs(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct BidirectionalSequenceRNNOptions final : private flatbuffers::Table {
  typedef BidirectionalSequenceRNNOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool merge_outputs = false,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable {
  typedef FullyConnectedOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  tflite::FullyConnectedOptionsWeightsFormat weights_format;
  bool keep_num_dims;
  bool asymmetric_quantize_inputs;
  FullyConnectedOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        weights_format(tflite::FullyConnectedOptionsWeightsFormat_DEFAULT),
        keep_num_dims(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct FullyConnectedOptions final : private flatbuffers::Table {
  typedef FullyConnectedOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const {
    return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(tflite::FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false,
    bool asymmetric_quantize_inputs = false) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef SoftmaxOptions TableType;
  float beta;
  SoftmaxOptionsT()
      : beta(0.0f) {
  }
};

struct SoftmaxOptions final : private flatbuffers::Table {
  typedef SoftmaxOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable {
  typedef ConcatenationOptions TableType;
  int32_t axis;
  tflite::ActivationFunctionType fused_activation_function;
  ConcatenationOptionsT()
      : axis(0),
        fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct ConcatenationOptions final : private flatbuffers::Table {
  typedef ConcatenationOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable {
  typedef AddOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  bool pot_scale_int16;
  AddOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        pot_scale_int16(true) {
  }
};

struct AddOptions final : private flatbuffers::Table {
  typedef AddOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           verifier.EndTable();
  }
  AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder &operator=(const AddOptionsBuilder &);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable {
  typedef MulOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  MulOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct MulOptions final : private flatbuffers::Table {
  typedef MulOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder &operator=(const MulOptionsBuilder &);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable {
  typedef L2NormOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  L2NormOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct L2NormOptions final : private flatbuffers::Table {
  typedef L2NormOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {
  typedef LocalResponseNormalizationOptions TableType;
  int32_t radius;
  float bias;
  float alpha;
  float beta;
  LocalResponseNormalizationOptionsT()
      : radius(0),
        bias(0.0f),
        alpha(0.0f),
        beta(0.0f) {
  }
};

struct LocalResponseNormalizationOptions final : private flatbuffers::Table {
  typedef LocalResponseNormalizationOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable {
  typedef LSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  tflite::LSTMKernelType kernel_type;
  bool asymmetric_quantize_inputs;
  LSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        kernel_type(tflite::LSTMKernelType_FULL),
        asymmetric_quantize_inputs(false) {
  }
};

struct LSTMOptions final : private flatbuffers::Table {
  typedef LSTMOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  tflite::LSTMKernelType kernel_type() const {
    return static_cast<tflite::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(tflite::LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef UnidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool time_major;
  bool asymmetric_quantize_inputs;
  UnidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        time_major(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct UnidirectionalSequenceLSTMOptions final : private flatbuffers::Table {
  typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  UnidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false,
    bool asymmetric_quantize_inputs = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
  typedef BidirectionalSequenceLSTMOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  float cell_clip;
  float proj_clip;
  bool merge_outputs;
  bool time_major;
  bool asymmetric_quantize_inputs;
  BidirectionalSequenceLSTMOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        cell_clip(0.0f),
        proj_clip(0.0f),
        merge_outputs(false),
        time_major(true),
        asymmetric_quantize_inputs(false) {
  }
};

struct BidirectionalSequenceLSTMOptions final : private flatbuffers::Table {
  typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  BidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false,
    bool time_major = true,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {
  typedef ResizeBilinearOptions TableType;
  bool align_corners;
  bool half_pixel_centers;
  ResizeBilinearOptionsT()
      : align_corners(false),
        half_pixel_centers(false) {
  }
};

struct ResizeBilinearOptions final : private flatbuffers::Table {
  typedef ResizeBilinearOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           verifier.EndTable();
  }
  ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable {
  typedef ResizeNearestNeighborOptions TableType;
  bool align_corners;
  bool half_pixel_centers;
  ResizeNearestNeighborOptionsT()
      : align_corners(false),
        half_pixel_centers(false) {
  }
};

struct ResizeNearestNeighborOptions final : private flatbuffers::Table {
  typedef ResizeNearestNeighborOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           verifier.EndTable();
  }
  ResizeNearestNeighborOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable {
  typedef CallOptions TableType;
  uint32_t subgraph;
  CallOptionsT()
      : subgraph(0) {
  }
};

struct CallOptions final : private flatbuffers::Table {
  typedef CallOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const {
    return GetField<uint32_t>(VT_SUBGRAPH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH) &&
           verifier.EndTable();
  }
  CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder &operator=(const CallOptionsBuilder &);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable {
  typedef PadOptions TableType;
  PadOptionsT() {
  }
};

struct PadOptions final : private flatbuffers::Table {
  typedef PadOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder &operator=(const PadOptionsBuilder &);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable {
  typedef PadV2Options TableType;
  PadV2OptionsT() {
  }
};

struct PadV2Options final : private flatbuffers::Table {
  typedef PadV2OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable {
  typedef ReshapeOptions TableType;
  std::vector<int32_t> new_shape;
  ReshapeOptionsT() {
  }
};

struct ReshapeOptions final : private flatbuffers::Table {
  typedef ReshapeOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
  ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      new_shape__);
}

flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToBatchNDOptions TableType;
  SpaceToBatchNDOptionsT() {
  }
};

struct SpaceToBatchNDOptions final : private flatbuffers::Table {
  typedef SpaceToBatchNDOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {
  typedef BatchToSpaceNDOptions TableType;
  BatchToSpaceNDOptionsT() {
  }
};

struct BatchToSpaceNDOptions final : private flatbuffers::Table {
  typedef BatchToSpaceNDOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable {
  typedef SkipGramOptions TableType;
  int32_t ngram_size;
  int32_t max_skip_size;
  bool include_all_ngrams;
  SkipGramOptionsT()
      : ngram_size(0),
        max_skip_size(0),
        include_all_ngrams(false) {
  }
};

struct SkipGramOptions final : private flatbuffers::Table {
  typedef SkipGramOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const {
    return GetField<int32_t>(VT_NGRAM_SIZE, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) &&
           verifier.EndTable();
  }
  SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {
  typedef SpaceToDepthOptions TableType;
  int32_t block_size;
  SpaceToDepthOptionsT()
      : block_size(0) {
  }
};

struct SpaceToDepthOptions final : private flatbuffers::Table {
  typedef SpaceToDepthOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
  SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceOptionsT : public flatbuffers::NativeTable {
  typedef DepthToSpaceOptions TableType;
  int32_t block_size;
  DepthToSpaceOptionsT()
      : block_size(0) {
  }
};

struct DepthToSpaceOptions final : private flatbuffers::Table {
  typedef DepthToSpaceOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
  DepthToSpaceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthToSpaceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceOptionsBuilder &operator=(const DepthToSpaceOptionsBuilder &);
  flatbuffers::Offset<DepthToSpaceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable {
  typedef SubOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  bool pot_scale_int16;
  SubOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE),
        pot_scale_int16(true) {
  }
};

struct SubOptions final : private flatbuffers::Table {
  typedef SubOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           verifier.EndTable();
  }
  SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder &operator=(const SubOptionsBuilder &);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable {
  typedef DivOptions TableType;
  tflite::ActivationFunctionType fused_activation_function;
  DivOptionsT()
      : fused_activation_function(tflite::ActivationFunctionType_NONE) {
  }
};

struct DivOptions final : private flatbuffers::Table {
  typedef DivOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
  DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder &operator=(const DivOptionsBuilder &);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable {
  typedef TopKV2Options TableType;
  TopKV2OptionsT() {
  }
};

struct TopKV2Options final : private flatbuffers::Table {
  typedef TopKV2OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {
  typedef EmbeddingLookupSparseOptions TableType;
  tflite::CombinerType combiner;
  EmbeddingLookupSparseOptionsT()
      : combiner(tflite::CombinerType_SUM) {
  }
};

struct EmbeddingLookupSparseOptions final : private flatbuffers::Table {
  typedef EmbeddingLookupSparseOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_COMBINER = 4
  };
  tflite::CombinerType combiner() const {
    return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(tflite::CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::CombinerType combiner = tflite::CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable {
  typedef GatherOptions TableType;
  int32_t axis;
  int32_t batch_dims;
  GatherOptionsT()
      : axis(0),
        batch_dims(0) {
  }
};

struct GatherOptions final : private flatbuffers::Table {
  typedef GatherOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t batch_dims() const {
    return GetField<int32_t>(VT_BATCH_DIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS) &&
           verifier.EndTable();
  }
  GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batch_dims = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable {
  typedef TransposeOptions TableType;
  TransposeOptionsT() {
  }
};

struct TransposeOptions final : private flatbuffers::Table {
  typedef TransposeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable {
  typedef ExpOptions TableType;
  ExpOptionsT() {
  }
};

struct ExpOptions final : private flatbuffers::Table {
  typedef ExpOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosOptionsT : public flatbuffers::NativeTable {
  typedef CosOptions TableType;
  CosOptionsT() {
  }
};

struct CosOptions final : private flatbuffers::Table {
  typedef CosOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CosOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CosOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosOptionsBuilder &operator=(const CosOptionsBuilder &);
  flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable {
  typedef ReducerOptions TableType;
  bool keep_dims;
  ReducerOptionsT()
      : keep_dims(false) {
  }
};

struct ReducerOptions final : private flatbuffers::Table {
  typedef ReducerOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
  ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable {
  typedef SqueezeOptions TableType;
  std::vector<int32_t> squeeze_dims;
  SqueezeOptionsT() {
  }
};

struct SqueezeOptions final : private flatbuffers::Table {
  typedef SqueezeOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
  SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      squeeze_dims__);
}

flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable {
  typedef SplitOptions TableType;
  int32_t num_splits;
  SplitOptionsT()
      : num_splits(0) {
  }
};

struct SplitOptions final : private flatbuffers::Table {
  typedef SplitOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public flatbuffers::NativeTable {
  typedef SplitVOptions TableType;
  int32_t num_splits;
  SplitVOptionsT()
      : num_splits(0) {
  }
};

struct SplitVOptions final : private flatbuffers::Table {
  typedef SplitVOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
  SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitVOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable {
  typedef StridedSliceOptions TableType;
  int32_t begin_mask;
  int32_t end_mask;
  int32_t ellipsis_mask;
  int32_t new_axis_mask;
  int32_t shrink_axis_mask;
  StridedSliceOptionsT()
      : begin_mask(0),
        end_mask(0),
        ellipsis_mask(0),
        new_axis_mask(0),
        shrink_axis_mask(0) {
  }
};

struct StridedSliceOptions final : private flatbuffers::Table {
  typedef StridedSliceOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
  StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {
  typedef LogSoftmaxOptions TableType;
  LogSoftmaxOptionsT() {
  }
};

struct LogSoftmaxOptions final : private flatbuffers::Table {
  typedef LogSoftmaxOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable {
  typedef CastOptions TableType;
  tflite::TensorType in_data_type;
  tflite::TensorType out_data_type;
  CastOptionsT()
      : in_data_type(tflite::TensorType_FLOAT32),
        out_data_type(tflite::TensorType_FLOAT32) {
  }
};

struct CastOptions final : private flatbuffers::Table {
  typedef CastOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  tflite::TensorType in_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  tflite::TensorType out_data_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) &&
           verifier.EndTable();
  }
  CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(tflite::TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(tflite::TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder &operator=(const CastOptionsBuilder &);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable {
  typedef DequantizeOptions TableType;
  DequantizeOptionsT() {
  }
};

struct DequantizeOptions final : private flatbuffers::Table {
  typedef DequantizeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {
  typedef MaximumMinimumOptions TableType;
  MaximumMinimumOptionsT() {
  }
};

struct MaximumMinimumOptions final : private flatbuffers::Table {
  typedef MaximumMinimumOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable {
  typedef TileOptions TableType;
  TileOptionsT() {
  }
};

struct TileOptions final : private flatbuffers::Table {
  typedef TileOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder &operator=(const TileOptionsBuilder &);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable {
  typedef ArgMaxOptions TableType;
  tflite::TensorType output_type;
  ArgMaxOptionsT()
      : output_type(tflite::TensorType_FLOAT32) {
  }
};

struct ArgMaxOptions final : private flatbuffers::Table {
  typedef ArgMaxOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable {
  typedef ArgMinOptions TableType;
  tflite::TensorType output_type;
  ArgMinOptionsT()
      : output_type(tflite::TensorType_FLOAT32) {
  }
};

struct ArgMinOptions final : private flatbuffers::Table {
  typedef ArgMinOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
  ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable {
  typedef GreaterOptions TableType;
  GreaterOptionsT() {
  }
};

struct GreaterOptions final : private flatbuffers::Table {
  typedef GreaterOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable {
  typedef GreaterEqualOptions TableType;
  GreaterEqualOptionsT() {
  }
};

struct GreaterEqualOptions final : private flatbuffers::Table {
  typedef GreaterEqualOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable {
  typedef LessOptions TableType;
  LessOptionsT() {
  }
};

struct LessOptions final : private flatbuffers::Table {
  typedef LessOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder &operator=(const LessOptionsBuilder &);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable {
  typedef LessEqualOptions TableType;
  LessEqualOptionsT() {
  }
};

struct LessEqualOptions final : private flatbuffers::Table {
  typedef LessEqualOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable {
  typedef NegOptions TableType;
  NegOptionsT() {
  }
};

struct NegOptions final : private flatbuffers::Table {
  typedef NegOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder &operator=(const NegOptionsBuilder &);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable {
  typedef SelectOptions TableType;
  SelectOptionsT() {
  }
};

struct SelectOptions final : private flatbuffers::Table {
  typedef SelectOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable {
  typedef SliceOptions TableType;
  SliceOptionsT() {
  }
};

struct SliceOptions final : private flatbuffers::Table {
  typedef SliceOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable {
  typedef TransposeConvOptions TableType;
  tflite::Padding padding;
  int32_t stride_w;
  int32_t stride_h;
  TransposeConvOptionsT()
      : padding(tflite::Padding_SAME),
        stride_w(0),
        stride_h(0) {
  }
};

struct TransposeConvOptions final : private flatbuffers::Table {
  typedef TransposeConvOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           verifier.EndTable();
  }
  TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::Padding padding = tflite::Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_padding(padding);
  return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable {
  typedef ExpandDimsOptions TableType;
  ExpandDimsOptionsT() {
  }
};

struct ExpandDimsOptions final : private flatbuffers::Table {
  typedef ExpandDimsOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable {
  typedef SparseToDenseOptions TableType;
  bool validate_indices;
  SparseToDenseOptionsT()
      : validate_indices(false) {
  }
};

struct SparseToDenseOptions final : private flatbuffers::Table {
  typedef SparseToDenseOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
  SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable {
  typedef EqualOptions TableType;
  EqualOptionsT() {
  }
};

struct EqualOptions final : private flatbuffers::Table {
  typedef EqualOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable {
  typedef NotEqualOptions TableType;
  NotEqualOptionsT() {
  }
};

struct NotEqualOptions final : private flatbuffers::Table {
  typedef NotEqualOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable {
  typedef ShapeOptions TableType;
  tflite::TensorType out_type;
  ShapeOptionsT()
      : out_type(tflite::TensorType_FLOAT32) {
  }
};

struct ShapeOptions final : private flatbuffers::Table {
  typedef ShapeOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_OUT_TYPE = 4
  };
  tflite::TensorType out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE) &&
           verifier.EndTable();
  }
  ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(tflite::TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankOptionsT : public flatbuffers::NativeTable {
  typedef RankOptions TableType;
  RankOptionsT() {
  }
};

struct RankOptions final : private flatbuffers::Table {
  typedef RankOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RankOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankOptionsBuilder &operator=(const RankOptionsBuilder &);
  flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable {
  typedef PowOptions TableType;
  PowOptionsT() {
  }
};

struct PowOptions final : private flatbuffers::Table {
  typedef PowOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder &operator=(const PowOptionsBuilder &);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable {
  typedef FakeQuantOptions TableType;
  float min;
  float max;
  int32_t num_bits;
  bool narrow_range;
  FakeQuantOptionsT()
      : min(0.0f),
        max(0.0f),
        num_bits(0),
        narrow_range(false) {
  }
};

struct FakeQuantOptions final : private flatbuffers::Table {
  typedef FakeQuantOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
  FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable {
  typedef PackOptions TableType;
  int32_t values_count;
  int32_t axis;
  PackOptionsT()
      : values_count(0),
        axis(0) {
  }
};

struct PackOptions final : private flatbuffers::Table {
  typedef PackOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const {
    return GetField<int32_t>(VT_VALUES_COUNT, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder &operator=(const PackOptionsBuilder &);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable {
  typedef LogicalOrOptions TableType;
  LogicalOrOptionsT() {
  }
};

struct LogicalOrOptions final : private flatbuffers::Table {
  typedef LogicalOrOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable {
  typedef OneHotOptions TableType;
  int32_t axis;
  OneHotOptionsT()
      : axis(0) {
  }
};

struct OneHotOptions final : private flatbuffers::Table {
  typedef OneHotOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public flatbuffers::NativeTable {
  typedef AbsOptions TableType;
  AbsOptionsT() {
  }
};

struct AbsOptions final : private flatbuffers::Table {
  typedef AbsOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionsT : public flatbuffers::NativeTable {
  typedef HardSwishOptions TableType;
  HardSwishOptionsT() {
  }
};

struct HardSwishOptions final : private flatbuffers::Table {
  typedef HardSwishOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSwishOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSwishOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSwishOptionsBuilder &operator=(const HardSwishOptionsBuilder &);
  flatbuffers::Offset<HardSwishOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable {
  typedef LogicalAndOptions TableType;
  LogicalAndOptionsT() {
  }
};

struct LogicalAndOptions final : private flatbuffers::Table {
  typedef LogicalAndOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable {
  typedef LogicalNotOptions TableType;
  LogicalNotOptionsT() {
  }
};

struct LogicalNotOptions final : private flatbuffers::Table {
  typedef LogicalNotOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable {
  typedef UnpackOptions TableType;
  int32_t num;
  int32_t axis;
  UnpackOptionsT()
      : num(0),
        axis(0) {
  }
};

struct UnpackOptions final : private flatbuffers::Table {
  typedef UnpackOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable {
  typedef FloorDivOptions TableType;
  FloorDivOptionsT() {
  }
};

struct FloorDivOptions final : private flatbuffers::Table {
  typedef FloorDivOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable {
  typedef SquareOptions TableType;
  SquareOptionsT() {
  }
};

struct SquareOptions final : private flatbuffers::Table {
  typedef SquareOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable {
  typedef ZerosLikeOptions TableType;
  ZerosLikeOptionsT() {
  }
};

struct ZerosLikeOptions final : private flatbuffers::Table {
  typedef ZerosLikeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable {
  typedef FillOptions TableType;
  FillOptionsT() {
  }
};

struct FillOptions final : private flatbuffers::Table {
  typedef FillOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder &operator=(const FillOptionsBuilder &);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public flatbuffers::NativeTable {
  typedef FloorModOptions TableType;
  FloorModOptionsT() {
  }
};

struct FloorModOptions final : private flatbuffers::Table {
  typedef FloorModOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorModOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public flatbuffers::NativeTable {
  typedef RangeOptions TableType;
  RangeOptionsT() {
  }
};

struct RangeOptions final : private flatbuffers::Table {
  typedef RangeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RangeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public flatbuffers::NativeTable {
  typedef LeakyReluOptions TableType;
  float alpha;
  LeakyReluOptionsT()
      : alpha(0.0f) {
  }
};

struct LeakyReluOptions final : private flatbuffers::Table {
  typedef LeakyReluOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable {
  typedef SquaredDifferenceOptions TableType;
  SquaredDifferenceOptionsT() {
  }
};

struct SquaredDifferenceOptions final : private flatbuffers::Table {
  typedef SquaredDifferenceOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifferenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public flatbuffers::NativeTable {
  typedef MirrorPadOptions TableType;
  tflite::MirrorPadMode mode;
  MirrorPadOptionsT()
      : mode(tflite::MirrorPadMode_REFLECT) {
  }
};

struct MirrorPadOptions final : private flatbuffers::Table {
  typedef MirrorPadOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_MODE = 4
  };
  tflite::MirrorPadMode mode() const {
    return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MirrorPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(tflite::MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueOptionsT : public flatbuffers::NativeTable {
  typedef UniqueOptions TableType;
  tflite::TensorType idx_out_type;
  UniqueOptionsT()
      : idx_out_type(tflite::TensorType_INT32) {
  }
};

struct UniqueOptions final : private flatbuffers::Table {
  typedef UniqueOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_IDX_OUT_TYPE = 4
  };
  tflite::TensorType idx_out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) &&
           verifier.EndTable();
  }
  UniqueOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UniqueOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(tflite::TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueOptionsBuilder &operator=(const UniqueOptionsBuilder &);
  flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::TensorType idx_out_type = tflite::TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2OptionsT : public flatbuffers::NativeTable {
  typedef ReverseV2Options TableType;
  ReverseV2OptionsT() {
  }
};

struct ReverseV2Options final : private flatbuffers::Table {
  typedef ReverseV2OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReverseV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseV2OptionsBuilder &operator=(const ReverseV2OptionsBuilder &);
  flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNOptionsT : public flatbuffers::NativeTable {
  typedef AddNOptions TableType;
  AddNOptionsT() {
  }
};

struct AddNOptions final : private flatbuffers::Table {
  typedef AddNOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNOptionsBuilder &operator=(const AddNOptionsBuilder &);
  flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdOptionsT : public flatbuffers::NativeTable {
  typedef GatherNdOptions TableType;
  GatherNdOptionsT() {
  }
};

struct GatherNdOptions final : private flatbuffers::Table {
  typedef GatherNdOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GatherNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdOptionsBuilder &operator=(const GatherNdOptionsBuilder &);
  flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereOptionsT : public flatbuffers::NativeTable {
  typedef WhereOptions TableType;
  WhereOptionsT() {
  }
};

struct WhereOptions final : private flatbuffers::Table {
  typedef WhereOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WhereOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhereOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereOptionsBuilder &operator=(const WhereOptionsBuilder &);
  flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceOptionsT : public flatbuffers::NativeTable {
  typedef ReverseSequenceOptions TableType;
  int32_t seq_dim;
  int32_t batch_dim;
  ReverseSequenceOptionsT()
      : seq_dim(0),
        batch_dim(0) {
  }
};

struct ReverseSequenceOptions final : private flatbuffers::Table {
  typedef ReverseSequenceOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const {
    return GetField<int32_t>(VT_SEQ_DIM, 0);
  }
  int32_t batch_dim() const {
    return GetField<int32_t>(VT_BATCH_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM) &&
           verifier.EndTable();
  }
  ReverseSequenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceOptionsBuilder &operator=(const ReverseSequenceOptionsBuilder &);
  flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagOptionsT : public flatbuffers::NativeTable {
  typedef MatrixDiagOptions TableType;
  MatrixDiagOptionsT() {
  }
};

struct MatrixDiagOptions final : private flatbuffers::Table {
  typedef MatrixDiagOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagOptionsBuilder &operator=(const MatrixDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeOptionsT : public flatbuffers::NativeTable {
  typedef QuantizeOptions TableType;
  QuantizeOptionsT() {
  }
};

struct QuantizeOptions final : private flatbuffers::Table {
  typedef QuantizeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  QuantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeOptionsBuilder &operator=(const QuantizeOptionsBuilder &);
  flatbuffers::Offset<QuantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixSetDiagOptionsT : public flatbuffers::NativeTable {
  typedef MatrixSetDiagOptions TableType;
  MatrixSetDiagOptionsT() {
  }
};

struct MatrixSetDiagOptions final : private flatbuffers::Table {
  typedef MatrixSetDiagOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MatrixSetDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixSetDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixSetDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixSetDiagOptionsBuilder &operator=(const MatrixSetDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfOptionsT : public flatbuffers::NativeTable {
  typedef IfOptions TableType;
  int32_t then_subgraph_index;
  int32_t else_subgraph_index;
  IfOptionsT()
      : then_subgraph_index(0),
        else_subgraph_index(0) {
  }
};

struct IfOptions final : private flatbuffers::Table {
  typedef IfOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const {
    return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0);
  }
  int32_t else_subgraph_index() const {
    return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
  IfOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IfOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfOptionsBuilder &operator=(const IfOptionsBuilder &);
  flatbuffers::Offset<IfOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t then_subgraph_index = 0,
    int32_t else_subgraph_index = 0) {
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOnceOptionsT : public flatbuffers::NativeTable {
  typedef CallOnceOptions TableType;
  int32_t init_subgraph_index;
  CallOnceOptionsT()
      : init_subgraph_index(0) {
  }
};

struct CallOnceOptions final : private flatbuffers::Table {
  typedef CallOnceOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const {
    return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
  CallOnceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallOnceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOnceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index) {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOnceOptionsBuilder &operator=(const CallOnceOptionsBuilder &);
  flatbuffers::Offset<CallOnceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t init_subgraph_index = 0) {
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileOptionsT : public flatbuffers::NativeTable {
  typedef WhileOptions TableType;
  int32_t cond_subgraph_index;
  int32_t body_subgraph_index;
  WhileOptionsT()
      : cond_subgraph_index(0),
        body_subgraph_index(0) {
  }
};

struct WhileOptions final : private flatbuffers::Table {
  typedef WhileOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
  WhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileOptionsBuilder &operator=(const WhileOptionsBuilder &);
  flatbuffers::Offset<WhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV4OptionsT : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV4Options TableType;
  NonMaxSuppressionV4OptionsT() {
  }
};

struct NonMaxSuppressionV4Options final : private flatbuffers::Table {
  typedef NonMaxSuppressionV4OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV4OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV4OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV4OptionsBuilder &operator=(const NonMaxSuppressionV4OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV5OptionsT : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV5Options TableType;
  NonMaxSuppressionV5OptionsT() {
  }
};

struct NonMaxSuppressionV5Options final : private flatbuffers::Table {
  typedef NonMaxSuppressionV5OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV5OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV5OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV5OptionsBuilder &operator=(const NonMaxSuppressionV5OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdOptionsT : public flatbuffers::NativeTable {
  typedef ScatterNdOptions TableType;
  ScatterNdOptionsT() {
  }
};

struct ScatterNdOptions final : private flatbuffers::Table {
  typedef ScatterNdOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNdOptionsBuilder &operator=(const ScatterNdOptionsBuilder &);
  flatbuffers::Offset<ScatterNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectV2OptionsT : public flatbuffers::NativeTable {
  typedef SelectV2Options TableType;
  SelectV2OptionsT() {
  }
};

struct SelectV2Options final : private flatbuffers::Table {
  typedef SelectV2OptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectV2OptionsBuilder &operator=(const SelectV2OptionsBuilder &);
  flatbuffers::Offset<SelectV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DensifyOptionsT : public flatbuffers::NativeTable {
  typedef DensifyOptions TableType;
  DensifyOptionsT() {
  }
};

struct DensifyOptions final : private flatbuffers::Table {
  typedef DensifyOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DensifyOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DensifyOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DensifyOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DensifyOptionsBuilder &operator=(const DensifyOptionsBuilder &);
  flatbuffers::Offset<DensifyOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SegmentSumOptionsT : public flatbuffers::NativeTable {
  typedef SegmentSumOptions TableType;
  SegmentSumOptionsT() {
  }
};

struct SegmentSumOptions final : private flatbuffers::Table {
  typedef SegmentSumOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SegmentSumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SegmentSumOptionsBuilder &operator=(const SegmentSumOptionsBuilder &);
  flatbuffers::Offset<SegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulOptionsT : public flatbuffers::NativeTable {
  typedef BatchMatMulOptions TableType;
  bool adj_x;
  bool adj_y;
  bool asymmetric_quantize_inputs;
  BatchMatMulOptionsT()
      : adj_x(false),
        adj_y(false),
        asymmetric_quantize_inputs(false) {
  }
};

struct BatchMatMulOptions final : private flatbuffers::Table {
  typedef BatchMatMulOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_ADJ_X = 4,
    VT_ADJ_Y = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adj_x() const {
    return GetField<uint8_t>(VT_ADJ_X, 0) != 0;
  }
  bool adj_y() const {
    return GetField<uint8_t>(VT_ADJ_Y, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_X) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_Y) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
  BatchMatMulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchMatMulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adj_x(bool adj_x) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X, static_cast<uint8_t>(adj_x), 0);
  }
  void add_adj_y(bool adj_y) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_Y, static_cast<uint8_t>(adj_y), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulOptionsBuilder &operator=(const BatchMatMulOptionsBuilder &);
  flatbuffers::Offset<BatchMatMulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool adj_x = false,
    bool adj_y = false,
    bool asymmetric_quantize_inputs = false) {
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adj_y(adj_y);
  builder_.add_adj_x(adj_x);
  return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumsumOptionsT : public flatbuffers::NativeTable {
  typedef CumsumOptions TableType;
  bool exclusive;
  bool reverse;
  CumsumOptionsT()
      : exclusive(false),
        reverse(false) {
  }
};

struct CumsumOptions final : private flatbuffers::Table {
  typedef CumsumOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
  CumsumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumsumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumsumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CumsumOptionsBuilder &operator=(const CumsumOptionsBuilder &);
  flatbuffers::Offset<CumsumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToOptionsT : public flatbuffers::NativeTable {
  typedef BroadcastToOptions TableType;
  BroadcastToOptionsT() {
  }
};

struct BroadcastToOptions final : private flatbuffers::Table {
  typedef BroadcastToOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BroadcastToOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastToOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToOptionsBuilder &operator=(const BroadcastToOptionsBuilder &);
  flatbuffers::Offset<BroadcastToOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Rfft2dOptionsT : public flatbuffers::NativeTable {
  typedef Rfft2dOptions TableType;
  Rfft2dOptionsT() {
  }
};

struct Rfft2dOptions final : private flatbuffers::Table {
  typedef Rfft2dOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Rfft2dOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rfft2dOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Rfft2dOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Rfft2dOptionsBuilder &operator=(const Rfft2dOptionsBuilder &);
  flatbuffers::Offset<Rfft2dOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableOptionsT : public flatbuffers::NativeTable {
  typedef HashtableOptions TableType;
  int32_t table_id;
  tflite::TensorType key_dtype;
  tflite::TensorType value_dtype;
  HashtableOptionsT()
      : table_id(0),
        key_dtype(tflite::TensorType_FLOAT32),
        value_dtype(tflite::TensorType_FLOAT32) {
  }
};

struct HashtableOptions final : private flatbuffers::Table {
  typedef HashtableOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const {
    return GetField<int32_t>(VT_TABLE_ID, 0);
  }
  tflite::TensorType key_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  tflite::TensorType value_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TABLE_ID) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE) &&
           verifier.EndTable();
  }
  HashtableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id) {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(tflite::TensorType key_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(tflite::TensorType value_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableOptionsBuilder &operator=(const HashtableOptionsBuilder &);
  flatbuffers::Offset<HashtableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t table_id = 0,
    tflite::TensorType key_dtype = tflite::TensorType_FLOAT32,
    tflite::TensorType value_dtype = tflite::TensorType_FLOAT32) {
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableFindOptionsT : public flatbuffers::NativeTable {
  typedef HashtableFindOptions TableType;
  HashtableFindOptionsT() {
  }
};

struct HashtableFindOptions final : private flatbuffers::Table {
  typedef HashtableFindOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableFindOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableFindOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableFindOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableFindOptionsBuilder &operator=(const HashtableFindOptionsBuilder &);
  flatbuffers::Offset<HashtableFindOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableImportOptionsT : public flatbuffers::NativeTable {
  typedef HashtableImportOptions TableType;
  HashtableImportOptionsT() {
  }
};

struct HashtableImportOptions final : private flatbuffers::Table {
  typedef HashtableImportOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableImportOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableImportOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableImportOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableImportOptionsBuilder &operator=(const HashtableImportOptionsBuilder &);
  flatbuffers::Offset<HashtableImportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableSizeOptionsT : public flatbuffers::NativeTable {
  typedef HashtableSizeOptions TableType;
  HashtableSizeOptionsT() {
  }
};

struct HashtableSizeOptions final : private flatbuffers::Table {
  typedef HashtableSizeOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableSizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableSizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableSizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableSizeOptionsBuilder &operator=(const HashtableSizeOptionsBuilder &);
  flatbuffers::Offset<HashtableSizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarHandleOptionsT : public flatbuffers::NativeTable {
  typedef VarHandleOptions TableType;
  std::string container;
  std::string shared_name;
  VarHandleOptionsT() {
  }
};

struct VarHandleOptions final : private flatbuffers::Table {
  typedef VarHandleOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_CONTAINER = 4,
    VT_SHARED_NAME = 6
  };
  const flatbuffers::String *container() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTAINER);
  }
  const flatbuffers::String *shared_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SHARED_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) &&
           VerifyOffset(verifier, VT_SHARED_NAME) &&
           verifier.VerifyString(shared_name()) &&
           verifier.EndTable();
  }
  VarHandleOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarHandleOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarHandleOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_container(flatbuffers::Offset<flatbuffers::String> container) {
    fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);
  }
  void add_shared_name(flatbuffers::Offset<flatbuffers::String> shared_name) {
    fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  explicit VarHandleOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarHandleOptionsBuilder &operator=(const VarHandleOptionsBuilder &);
  flatbuffers::Offset<VarHandleOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> container = 0,
    flatbuffers::Offset<flatbuffers::String> shared_name = 0) {
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *container = nullptr,
    const char *shared_name = nullptr) {
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto shared_name__ = shared_name ? _fbb.CreateString(shared_name) : 0;
  return tflite::CreateVarHandleOptions(
      _fbb,
      container__,
      shared_name__);
}

flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadVariableOptionsT : public flatbuffers::NativeTable {
  typedef ReadVariableOptions TableType;
  ReadVariableOptionsT() {
  }
};

struct ReadVariableOptions final : private flatbuffers::Table {
  typedef ReadVariableOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReadVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReadVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadVariableOptionsBuilder &operator=(const ReadVariableOptionsBuilder &);
  flatbuffers::Offset<ReadVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignVariableOptionsT : public flatbuffers::NativeTable {
  typedef AssignVariableOptions TableType;
  AssignVariableOptionsT() {
  }
};

struct AssignVariableOptions final : private flatbuffers::Table {
  typedef AssignVariableOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssignVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignVariableOptionsBuilder &operator=(const AssignVariableOptionsBuilder &);
  flatbuffers::Offset<AssignVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomOptionsT : public flatbuffers::NativeTable {
  typedef RandomOptions TableType;
  int64_t seed;
  int64_t seed2;
  RandomOptionsT()
      : seed(0),
        seed2(0) {
  }
};

struct RandomOptions final : private flatbuffers::Table {
  typedef RandomOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) &&
           verifier.EndTable();
  }
  RandomOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED2, seed2, 0);
  }
  explicit RandomOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomOptionsBuilder &operator=(const RandomOptionsBuilder &);
  flatbuffers::Offset<RandomOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BucketizeOptionsT : public flatbuffers::NativeTable {
  typedef BucketizeOptions TableType;
  std::vector<float> boundaries;
  BucketizeOptionsT() {
  }
};

struct BucketizeOptions final : private flatbuffers::Table {
  typedef BucketizeOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_BOUNDARIES = 4
  };
  const flatbuffers::Vector<float> *boundaries() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOUNDARIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOUNDARIES) &&
           verifier.VerifyVector(boundaries()) &&
           verifier.EndTable();
  }
  BucketizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BucketizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BucketizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boundaries(flatbuffers::Offset<flatbuffers::Vector<float>> boundaries) {
    fbb_.AddOffset(BucketizeOptions::VT_BOUNDARIES, boundaries);
  }
  explicit BucketizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BucketizeOptionsBuilder &operator=(const BucketizeOptionsBuilder &);
  flatbuffers::Offset<BucketizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BucketizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> boundaries = 0) {
  BucketizeOptionsBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  return builder_.Finish();
}

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *boundaries = nullptr) {
  auto boundaries__ = boundaries ? _fbb.CreateVector<float>(*boundaries) : 0;
  return tflite::CreateBucketizeOptions(
      _fbb,
      boundaries__);
}

flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeluOptionsT : public flatbuffers::NativeTable {
  typedef GeluOptions TableType;
  bool approximate;
  GeluOptionsT()
      : approximate(false) {
  }
};

struct GeluOptions final : private flatbuffers::Table {
  typedef GeluOptionsT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_APPROXIMATE = 4
  };
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
  GeluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GeluOptions::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeluOptionsBuilder &operator=(const GeluOptionsBuilder &);
  flatbuffers::Offset<GeluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GeluOptionsBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DynamicUpdateSliceOptionsT : public flatbuffers::NativeTable {
  typedef DynamicUpdateSliceOptions TableType;
  DynamicUpdateSliceOptionsT() {
  }
};

struct DynamicUpdateSliceOptions final : private flatbuffers::Table {
  typedef DynamicUpdateSliceOptionsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DynamicUpdateSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DynamicUpdateSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DynamicUpdateSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DynamicUpdateSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DynamicUpdateSliceOptionsBuilder &operator=(const DynamicUpdateSliceOptionsBuilder &);
  flatbuffers::Offset<DynamicUpdateSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DynamicUpdateSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DynamicUpdateSliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable {
  typedef OperatorCode TableType;
  int8_t deprecated_builtin_code;
  std::string custom_code;
  int32_t version;
  tflite::BuiltinOperator builtin_code;
  OperatorCodeT()
      : deprecated_builtin_code(0),
        version(1),
        builtin_code(tflite::BuiltinOperator_ADD) {
  }
};

struct OperatorCode final : private flatbuffers::Table {
  typedef OperatorCodeT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const {
    return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0);
  }
  const flatbuffers::String *custom_code() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  tflite::BuiltinOperator builtin_code() const {
    return static_cast<tflite::BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE) &&
           verifier.EndTable();
  }
  OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(tflite::BuiltinOperator builtin_code) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    const char *custom_code = nullptr,
    int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return tflite::CreateOperatorCode(
      _fbb,
      deprecated_builtin_code,
      custom_code__,
      version,
      builtin_code);
}

flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable {
  typedef Operator TableType;
  uint32_t opcode_index;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  tflite::BuiltinOptionsUnion builtin_options;
  std::vector<uint8_t> custom_options;
  tflite::CustomOptionsFormat custom_options_format;
  std::vector<bool> mutating_variable_inputs;
  std::vector<int32_t> intermediates;
  OperatorT()
      : opcode_index(0),
        custom_options_format(tflite::CustomOptionsFormat_FLEXBUFFERS) {
  }
};

struct Operator final : private flatbuffers::Table {
  typedef OperatorT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  tflite::BuiltinOptions builtin_options_type() const {
    return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
  }
  template<typename T> const T *builtin_options_as() const;
  const tflite::Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions ? static_cast<const tflite::Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const tflite::DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const tflite::ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions ? static_cast<const tflite::LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions ? static_cast<const tflite::Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions ? static_cast<const tflite::SVDFOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RNNOptions ? static_cast<const tflite::RNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FullyConnectedOptions ? static_cast<const tflite::FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions ? static_cast<const tflite::SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions ? static_cast<const tflite::ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddOptions ? static_cast<const tflite::AddOptions *>(builtin_options()) : nullptr;
  }
  const tflite::L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions ? static_cast<const tflite::L2NormOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const tflite::LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions ? static_cast<const tflite::LSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeBilinearOptions ? static_cast<const tflite::ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOptions ? static_cast<const tflite::CallOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions ? static_cast<const tflite::ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions ? static_cast<const tflite::SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions ? static_cast<const tflite::SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const tflite::EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MulOptions ? static_cast<const tflite::MulOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadOptions ? static_cast<const tflite::PadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherOptions ? static_cast<const tflite::GatherOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const tflite::BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const tflite::SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions ? static_cast<const tflite::TransposeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions ? static_cast<const tflite::ReducerOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SubOptions ? static_cast<const tflite::SubOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DivOptions ? static_cast<const tflite::DivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions ? static_cast<const tflite::SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions ? static_cast<const tflite::SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions ? static_cast<const tflite::StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpOptions ? static_cast<const tflite::ExpOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options ? static_cast<const tflite::TopKV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitOptions ? static_cast<const tflite::SplitOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions ? static_cast<const tflite::LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CastOptions ? static_cast<const tflite::CastOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions ? static_cast<const tflite::DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MaximumMinimumOptions ? static_cast<const tflite::MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions ? static_cast<const tflite::ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessOptions ? static_cast<const tflite::LessOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NegOptions ? static_cast<const tflite::NegOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadV2Options ? static_cast<const tflite::PadV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions ? static_cast<const tflite::GreaterOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions ? static_cast<const tflite::GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions ? static_cast<const tflite::LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectOptions ? static_cast<const tflite::SelectOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SliceOptions ? static_cast<const tflite::SliceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions ? static_cast<const tflite::TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions ? static_cast<const tflite::SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const tflite::TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TileOptions ? static_cast<const tflite::TileOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions ? static_cast<const tflite::ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EqualOptions ? static_cast<const tflite::EqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions ? static_cast<const tflite::NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions ? static_cast<const tflite::ShapeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PowOptions ? static_cast<const tflite::PowOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions ? static_cast<const tflite::ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions ? static_cast<const tflite::FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const tflite::PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PackOptions ? static_cast<const tflite::PackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions ? static_cast<const tflite::LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const tflite::OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions ? static_cast<const tflite::OneHotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions ? static_cast<const tflite::LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions ? static_cast<const tflite::LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions ? static_cast<const tflite::UnpackOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions ? static_cast<const tflite::FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquareOptions ? static_cast<const tflite::SquareOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions ? static_cast<const tflite::ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FillOptions ? static_cast<const tflite::FillOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const tflite::BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const tflite::BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const tflite::FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorModOptions ? static_cast<const tflite::FloorModOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RangeOptions ? static_cast<const tflite::RangeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const tflite::ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const tflite::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LeakyReluOptions ? static_cast<const tflite::LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquaredDifferenceOptions ? static_cast<const tflite::SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MirrorPadOptions ? static_cast<const tflite::MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AbsOptions ? static_cast<const tflite::AbsOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitVOptions ? static_cast<const tflite::SplitVOptions *>(builtin_options()) : nullptr;
  }
  const tflite::UniqueOptions *builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UniqueOptions ? static_cast<const tflite::UniqueOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReverseV2Options *builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReverseV2Options ? static_cast<const tflite::ReverseV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::AddNOptions *builtin_options_as_AddNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddNOptions ? static_cast<const tflite::AddNOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GatherNdOptions *builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherNdOptions ? static_cast<const tflite::GatherNdOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CosOptions *builtin_options_as_CosOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CosOptions ? static_cast<const tflite::CosOptions *>(builtin_options()) : nullptr;
  }
  const tflite::WhereOptions *builtin_options_as_WhereOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhereOptions ? static_cast<const tflite::WhereOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RankOptions *builtin_options_as_RankOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RankOptions ? static_cast<const tflite::RankOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReverseSequenceOptions ? static_cast<const tflite::ReverseSequenceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixDiagOptions ? static_cast<const tflite::MatrixDiagOptions *>(builtin_options()) : nullptr;
  }
  const tflite::QuantizeOptions *builtin_options_as_QuantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_QuantizeOptions ? static_cast<const tflite::QuantizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixSetDiagOptions ? static_cast<const tflite::MatrixSetDiagOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HardSwishOptions *builtin_options_as_HardSwishOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HardSwishOptions ? static_cast<const tflite::HardSwishOptions *>(builtin_options()) : nullptr;
  }
  const tflite::IfOptions *builtin_options_as_IfOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_IfOptions ? static_cast<const tflite::IfOptions *>(builtin_options()) : nullptr;
  }
  const tflite::WhileOptions *builtin_options_as_WhileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhileOptions ? static_cast<const tflite::WhileOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthToSpaceOptions ? static_cast<const tflite::DepthToSpaceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV4Options ? static_cast<const tflite::NonMaxSuppressionV4Options *>(builtin_options()) : nullptr;
  }
  const tflite::NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV5Options ? static_cast<const tflite::NonMaxSuppressionV5Options *>(builtin_options()) : nullptr;
  }
  const tflite::ScatterNdOptions *builtin_options_as_ScatterNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ScatterNdOptions ? static_cast<const tflite::ScatterNdOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SelectV2Options *builtin_options_as_SelectV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectV2Options ? static_cast<const tflite::SelectV2Options *>(builtin_options()) : nullptr;
  }
  const tflite::DensifyOptions *builtin_options_as_DensifyOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DensifyOptions ? static_cast<const tflite::DensifyOptions *>(builtin_options()) : nullptr;
  }
  const tflite::SegmentSumOptions *builtin_options_as_SegmentSumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SegmentSumOptions ? static_cast<const tflite::SegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchMatMulOptions ? static_cast<const tflite::BatchMatMulOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CumsumOptions *builtin_options_as_CumsumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CumsumOptions ? static_cast<const tflite::CumsumOptions *>(builtin_options()) : nullptr;
  }
  const tflite::CallOnceOptions *builtin_options_as_CallOnceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOnceOptions ? static_cast<const tflite::CallOnceOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BroadcastToOptions *builtin_options_as_BroadcastToOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BroadcastToOptions ? static_cast<const tflite::BroadcastToOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Rfft2dOptions *builtin_options_as_Rfft2dOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Rfft2dOptions ? static_cast<const tflite::Rfft2dOptions *>(builtin_options()) : nullptr;
  }
  const tflite::Conv3DOptions *builtin_options_as_Conv3DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv3DOptions ? static_cast<const tflite::Conv3DOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableOptions *builtin_options_as_HashtableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableOptions ? static_cast<const tflite::HashtableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableFindOptions *builtin_options_as_HashtableFindOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableFindOptions ? static_cast<const tflite::HashtableFindOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableImportOptions *builtin_options_as_HashtableImportOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableImportOptions ? static_cast<const tflite::HashtableImportOptions *>(builtin_options()) : nullptr;
  }
  const tflite::HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableSizeOptions ? static_cast<const tflite::HashtableSizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::VarHandleOptions *builtin_options_as_VarHandleOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_VarHandleOptions ? static_cast<const tflite::VarHandleOptions *>(builtin_options()) : nullptr;
  }
  const tflite::ReadVariableOptions *builtin_options_as_ReadVariableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReadVariableOptions ? static_cast<const tflite::ReadVariableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::AssignVariableOptions *builtin_options_as_AssignVariableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AssignVariableOptions ? static_cast<const tflite::AssignVariableOptions *>(builtin_options()) : nullptr;
  }
  const tflite::RandomOptions *builtin_options_as_RandomOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RandomOptions ? static_cast<const tflite::RandomOptions *>(builtin_options()) : nullptr;
  }
  const tflite::BucketizeOptions *builtin_options_as_BucketizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BucketizeOptions ? static_cast<const tflite::BucketizeOptions *>(builtin_options()) : nullptr;
  }
  const tflite::GeluOptions *builtin_options_as_GeluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GeluOptions ? static_cast<const tflite::GeluOptions *>(builtin_options()) : nullptr;
  }
  const tflite::DynamicUpdateSliceOptions *builtin_options_as_DynamicUpdateSliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DynamicUpdateSliceOptions ? static_cast<const tflite::DynamicUpdateSliceOptions *>(builtin_options()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  tflite::CustomOptionsFormat custom_options_format() const {
    return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *intermediates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) &&
           verifier.VerifyVector(intermediates()) &&
           verifier.EndTable();
  }
  OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const tflite::DepthwiseConv2DOptions *Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const tflite::ConcatEmbeddingsOptions *Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const tflite::LSHProjectionOptions *Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const tflite::Pool2DOptions *Operator::builtin_options_as<tflite::Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const tflite::SVDFOptions *Operator::builtin_options_as<tflite::SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const tflite::RNNOptions *Operator::builtin_options_as<tflite::RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const tflite::FullyConnectedOptions *Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const tflite::SoftmaxOptions *Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const tflite::ConcatenationOptions *Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const tflite::AddOptions *Operator::builtin_options_as<tflite::AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const tflite::L2NormOptions *Operator::builtin_options_as<tflite::L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const tflite::LocalResponseNormalizationOptions *Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const tflite::LSTMOptions *Operator::builtin_options_as<tflite::LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const tflite::ResizeBilinearOptions *Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const tflite::CallOptions *Operator::builtin_options_as<tflite::CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const tflite::ReshapeOptions *Operator::builtin_options_as<tflite::ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const tflite::SkipGramOptions *Operator::builtin_options_as<tflite::SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const tflite::SpaceToDepthOptions *Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const tflite::EmbeddingLookupSparseOptions *Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const tflite::MulOptions *Operator::builtin_options_as<tflite::MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const tflite::PadOptions *Operator::builtin_options_as<tflite::PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const tflite::GatherOptions *Operator::builtin_options_as<tflite::GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const tflite::BatchToSpaceNDOptions *Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const tflite::SpaceToBatchNDOptions *Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const tflite::TransposeOptions *Operator::builtin_options_as<tflite::TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const tflite::ReducerOptions *Operator::builtin_options_as<tflite::ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const tflite::SubOptions *Operator::builtin_options_as<tflite::SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const tflite::DivOptions *Operator::builtin_options_as<tflite::DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const tflite::SqueezeOptions *Operator::builtin_options_as<tflite::SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const tflite::SequenceRNNOptions *Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const tflite::StridedSliceOptions *Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const tflite::ExpOptions *Operator::builtin_options_as<tflite::ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const tflite::TopKV2Options *Operator::builtin_options_as<tflite::TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const tflite::SplitOptions *Operator::builtin_options_as<tflite::SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const tflite::LogSoftmaxOptions *Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const tflite::CastOptions *Operator::builtin_options_as<tflite::CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const tflite::DequantizeOptions *Operator::builtin_options_as<tflite::DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const tflite::MaximumMinimumOptions *Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const tflite::ArgMaxOptions *Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const tflite::LessOptions *Operator::builtin_options_as<tflite::LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const tflite::NegOptions *Operator::builtin_options_as<tflite::NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const tflite::PadV2Options *Operator::builtin_options_as<tflite::PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const tflite::GreaterOptions *Operator::builtin_options_as<tflite::GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const tflite::GreaterEqualOptions *Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const tflite::LessEqualOptions *Operator::builtin_options_as<tflite::LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const tflite::SelectOptions *Operator::builtin_options_as<tflite::SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const tflite::SliceOptions *Operator::builtin_options_as<tflite::SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const tflite::TransposeConvOptions *Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const tflite::SparseToDenseOptions *Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const tflite::TileOptions *Operator::builtin_options_as<tflite::TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const tflite::ExpandDimsOptions *Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const tflite::EqualOptions *Operator::builtin_options_as<tflite::EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const tflite::NotEqualOptions *Operator::builtin_options_as<tflite::NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const tflite::ShapeOptions *Operator::builtin_options_as<tflite::ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const tflite::PowOptions *Operator::builtin_options_as<tflite::PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const tflite::ArgMinOptions *Operator::builtin_options_as<tflite::ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const tflite::FakeQuantOptions *Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const tflite::PackOptions *Operator::builtin_options_as<tflite::PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const tflite::LogicalOrOptions *Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const tflite::OneHotOptions *Operator::builtin_options_as<tflite::OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const tflite::LogicalAndOptions *Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const tflite::LogicalNotOptions *Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const tflite::UnpackOptions *Operator::builtin_options_as<tflite::UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const tflite::FloorDivOptions *Operator::builtin_options_as<tflite::FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const tflite::SquareOptions *Operator::builtin_options_as<tflite::SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const tflite::ZerosLikeOptions *Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const tflite::FillOptions *Operator::builtin_options_as<tflite::FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const tflite::BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::BidirectionalSequenceRNNOptions *Operator::builtin_options_as<tflite::BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const tflite::UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<tflite::UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const tflite::FloorModOptions *Operator::builtin_options_as<tflite::FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const tflite::RangeOptions *Operator::builtin_options_as<tflite::RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const tflite::ResizeNearestNeighborOptions *Operator::builtin_options_as<tflite::ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const tflite::LeakyReluOptions *Operator::builtin_options_as<tflite::LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const tflite::SquaredDifferenceOptions *Operator::builtin_options_as<tflite::SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const tflite::MirrorPadOptions *Operator::builtin_options_as<tflite::MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const tflite::AbsOptions *Operator::builtin_options_as<tflite::AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const tflite::SplitVOptions *Operator::builtin_options_as<tflite::SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template<> inline const tflite::UniqueOptions *Operator::builtin_options_as<tflite::UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template<> inline const tflite::ReverseV2Options *Operator::builtin_options_as<tflite::ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template<> inline const tflite::AddNOptions *Operator::builtin_options_as<tflite::AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template<> inline const tflite::GatherNdOptions *Operator::builtin_options_as<tflite::GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template<> inline const tflite::CosOptions *Operator::builtin_options_as<tflite::CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template<> inline const tflite::WhereOptions *Operator::builtin_options_as<tflite::WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template<> inline const tflite::RankOptions *Operator::builtin_options_as<tflite::RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template<> inline const tflite::ReverseSequenceOptions *Operator::builtin_options_as<tflite::ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

template<> inline const tflite::MatrixDiagOptions *Operator::builtin_options_as<tflite::MatrixDiagOptions>() const {
  return builtin_options_as_MatrixDiagOptions();
}

template<> inline const tflite::QuantizeOptions *Operator::builtin_options_as<tflite::QuantizeOptions>() const {
  return builtin_options_as_QuantizeOptions();
}

template<> inline const tflite::MatrixSetDiagOptions *Operator::builtin_options_as<tflite::MatrixSetDiagOptions>() const {
  return builtin_options_as_MatrixSetDiagOptions();
}

template<> inline const tflite::HardSwishOptions *Operator::builtin_options_as<tflite::HardSwishOptions>() const {
  return builtin_options_as_HardSwishOptions();
}

template<> inline const tflite::IfOptions *Operator::builtin_options_as<tflite::IfOptions>() const {
  return builtin_options_as_IfOptions();
}

template<> inline const tflite::WhileOptions *Operator::builtin_options_as<tflite::WhileOptions>() const {
  return builtin_options_as_WhileOptions();
}

template<> inline const tflite::DepthToSpaceOptions *Operator::builtin_options_as<tflite::DepthToSpaceOptions>() const {
  return builtin_options_as_DepthToSpaceOptions();
}

template<> inline const tflite::NonMaxSuppressionV4Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV4Options>() const {
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template<> inline const tflite::NonMaxSuppressionV5Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV5Options>() const {
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template<> inline const tflite::ScatterNdOptions *Operator::builtin_options_as<tflite::ScatterNdOptions>() const {
  return builtin_options_as_ScatterNdOptions();
}

template<> inline const tflite::SelectV2Options *Operator::builtin_options_as<tflite::SelectV2Options>() const {
  return builtin_options_as_SelectV2Options();
}

template<> inline const tflite::DensifyOptions *Operator::builtin_options_as<tflite::DensifyOptions>() const {
  return builtin_options_as_DensifyOptions();
}

template<> inline const tflite::SegmentSumOptions *Operator::builtin_options_as<tflite::SegmentSumOptions>() const {
  return builtin_options_as_SegmentSumOptions();
}

template<> inline const tflite::BatchMatMulOptions *Operator::builtin_options_as<tflite::BatchMatMulOptions>() const {
  return builtin_options_as_BatchMatMulOptions();
}

template<> inline const tflite::CumsumOptions *Operator::builtin_options_as<tflite::CumsumOptions>() const {
  return builtin_options_as_CumsumOptions();
}

template<> inline const tflite::CallOnceOptions *Operator::builtin_options_as<tflite::CallOnceOptions>() const {
  return builtin_options_as_CallOnceOptions();
}

template<> inline const tflite::BroadcastToOptions *Operator::builtin_options_as<tflite::BroadcastToOptions>() const {
  return builtin_options_as_BroadcastToOptions();
}

template<> inline const tflite::Rfft2dOptions *Operator::builtin_options_as<tflite::Rfft2dOptions>() const {
  return builtin_options_as_Rfft2dOptions();
}

template<> inline const tflite::Conv3DOptions *Operator::builtin_options_as<tflite::Conv3DOptions>() const {
  return builtin_options_as_Conv3DOptions();
}

template<> inline const tflite::HashtableOptions *Operator::builtin_options_as<tflite::HashtableOptions>() const {
  return builtin_options_as_HashtableOptions();
}

template<> inline const tflite::HashtableFindOptions *Operator::builtin_options_as<tflite::HashtableFindOptions>() const {
  return builtin_options_as_HashtableFindOptions();
}

template<> inline const tflite::HashtableImportOptions *Operator::builtin_options_as<tflite::HashtableImportOptions>() const {
  return builtin_options_as_HashtableImportOptions();
}

template<> inline const tflite::HashtableSizeOptions *Operator::builtin_options_as<tflite::HashtableSizeOptions>() const {
  return builtin_options_as_HashtableSizeOptions();
}

template<> inline const tflite::VarHandleOptions *Operator::builtin_options_as<tflite::VarHandleOptions>() const {
  return builtin_options_as_VarHandleOptions();
}

template<> inline const tflite::ReadVariableOptions *Operator::builtin_options_as<tflite::ReadVariableOptions>() const {
  return builtin_options_as_ReadVariableOptions();
}

template<> inline const tflite::AssignVariableOptions *Operator::builtin_options_as<tflite::AssignVariableOptions>() const {
  return builtin_options_as_AssignVariableOptions();
}

template<> inline const tflite::RandomOptions *Operator::builtin_options_as<tflite::RandomOptions>() const {
  return builtin_options_as_RandomOptions();
}

template<> inline const tflite::BucketizeOptions *Operator::builtin_options_as<tflite::BucketizeOptions>() const {
  return builtin_options_as_BucketizeOptions();
}

template<> inline const tflite::GeluOptions *Operator::builtin_options_as<tflite::GeluOptions>() const {
  return builtin_options_as_GeluOptions();
}

template<> inline const tflite::DynamicUpdateSliceOptions *Operator::builtin_options_as<tflite::DynamicUpdateSliceOptions>() const {
  return builtin_options_as_DynamicUpdateSliceOptions();
}

struct OperatorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder &operator=(const OperatorBuilder &);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t> *custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
    const std::vector<int32_t> *intermediates = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ = mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return tflite::CreateOperator(
      _fbb,
      opcode_index,
      inputs__,
      outputs__,
      builtin_options_type,
      builtin_options,
      custom_options__,
      custom_options_format,
      mutating_variable_inputs__,
      intermediates__);
}

flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::vector<std::unique_ptr<tflite::TensorT>> tensors;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::unique_ptr<tflite::OperatorT>> operators;
  std::string name;
  SubGraphT() {
  }
};

struct SubGraph final : private flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Operator>> *operators = nullptr,
    const char *name = nullptr) {
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateSubGraph(
      _fbb,
      tensors__,
      inputs__,
      outputs__,
      operators__,
      name__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable {
  typedef Buffer TableType;
  std::vector<uint8_t> data;
  BufferT() {
  }
};

struct Buffer final : private flatbuffers::Table {
  typedef BufferT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::CreateBuffer(
      _fbb,
      data__);
}

flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  std::string name;
  uint32_t buffer;
  MetadataT()
      : buffer(0) {
  }
};

struct Metadata final : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataBuilder &operator=(const MetadataBuilder &);
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t buffer = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t buffer = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateMetadata(
      _fbb,
      name__,
      buffer);
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorMapT : public flatbuffers::NativeTable {
  typedef TensorMap TableType;
  std::string name;
  uint32_t tensor_index;
  TensorMapT()
      : tensor_index(0) {
  }
};

struct TensorMap final : private flatbuffers::Table {
  typedef TensorMapT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(VT_TENSOR_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX) &&
           verifier.EndTable();
  }
  TensorMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorMapBuilder &operator=(const TensorMapBuilder &);
  flatbuffers::Offset<TensorMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMap> CreateTensorMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t tensor_index = 0) {
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t tensor_index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateTensorMap(
      _fbb,
      name__,
      tensor_index);
}

flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignatureDefT : public flatbuffers::NativeTable {
  typedef SignatureDef TableType;
  std::vector<std::unique_ptr<tflite::TensorMapT>> inputs;
  std::vector<std::unique_ptr<tflite::TensorMapT>> outputs;
  std::string signature_key;
  uint32_t subgraph_index;
  SignatureDefT()
      : subgraph_index(0) {
  }
};

struct SignatureDef final : private flatbuffers::Table {
  typedef SignatureDefT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_SIGNATURE_KEY = 8,
    VT_SUBGRAPH_INDEX = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *>(VT_OUTPUTS);
  }
  const flatbuffers::String *signature_key() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE_KEY);
  }
  uint32_t subgraph_index() const {
    return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_SIGNATURE_KEY) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
  SignatureDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignatureDef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignatureDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> inputs) {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> outputs) {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_signature_key(flatbuffers::Offset<flatbuffers::String> signature_key) {
    fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index) {
    fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureDefBuilder &operator=(const SignatureDefBuilder &);
  flatbuffers::Offset<SignatureDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::String> signature_key = 0,
    uint32_t subgraph_index = 0) {
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<tflite::TensorMap>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::TensorMap>> *outputs = nullptr,
    const char *signature_key = nullptr,
    uint32_t subgraph_index = 0) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*outputs) : 0;
  auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;
  return tflite::CreateSignatureDef(
      _fbb,
      inputs__,
      outputs__,
      signature_key__,
      subgraph_index);
}

flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
  typedef Model TableType;
  uint32_t version;
  std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes;
  std::vector<std::unique_ptr<tflite::SubGraphT>> subgraphs;
  std::string description;
  std::vector<std::unique_ptr<tflite::BufferT>> buffers;
  std::vector<int32_t> metadata_buffer;
  std::vector<std::unique_ptr<tflite::MetadataT>> metadata;
  std::vector<std::unique_ptr<tflite::SignatureDefT>> signature_defs;
  ModelT()
      : version(0) {
  }
};

struct Model final : private flatbuffers::Table {
  typedef ModelT NativeTableType;
  enum FlatBuffersVTableOffset : flatbuffers::voffset_t {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *>(VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>> *signature_defs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>> *>(VT_SIGNATURE_DEFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) &&
           verifier.EndTable();
  }
  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata) {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>> signature_defs) {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>> signature_defs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Metadata>> *metadata = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SignatureDef>> *signature_defs = nullptr) {
  auto operator_codes__ = operator_codes ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>>(*metadata) : 0;
  auto signature_defs__ = signature_defs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SignatureDef>>(*signature_defs) : 0;
  return tflite::CreateModel(
      _fbb,
      version,
      operator_codes__,
      subgraphs__,
      description__,
      buffers__,
      metadata_buffer__,
      metadata__,
      signature_defs__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CustomQuantizationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom.begin()); } }
}

inline flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return tflite::CreateCustomQuantization(
      _fbb,
      _custom);
}

inline QuantizationParametersT *QuantizationParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizationParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } }
  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } }
  { auto _e = details_type(); _o->details.type = _e; }
  { auto _e = details(); if (_e) _o->details.value = tflite::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver); }
  { auto _e = quantized_dimension(); _o->quantized_dimension = _e; }
}

inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
  auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _zero_point = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
  auto _details_type = _o->details.type;
  auto _details = _o->details.Pack(_fbb);
  auto _quantized_dimension = _o->quantized_dimension;
  return tflite::CreateQuantizationParameters(
      _fbb,
      _min,
      _max,
      _scale,
      _zero_point,
      _details_type,
      _details,
      _quantized_dimension);
}

inline Int32VectorT *Int32Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Int32VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Int32Vector::UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Int32Vector> Int32Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt32Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Int32VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateInt32Vector(
      _fbb,
      _values);
}

inline Uint16VectorT *Uint16Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Uint16VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint16Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint16VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint16_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint16Vector(
      _fbb,
      _values);
}

inline Uint8VectorT *Uint8Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Uint8VectorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->values.begin()); } }
}

inline flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUint8Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint8VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint8_t), 4);
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return tflite::CreateUint8Vector(
      _fbb,
      _values);
}

inline DimensionMetadataT *DimensionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DimensionMetadataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = dense_size(); _o->dense_size = _e; }
  { auto _e = array_segments_type(); _o->array_segments.type = _e; }
  { auto _e = array_segments(); if (_e) _o->array_segments.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_segments_type(), _resolver); }
  { auto _e = array_indices_type(); _o->array_indices.type = _e; }
  { auto _e = array_indices(); if (_e) _o->array_indices.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver); }
}

inline flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDimensionMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DimensionMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _dense_size = _o->dense_size;
  auto _array_segments_type = _o->array_segments.type;
  auto _array_segments = _o->array_segments.Pack(_fbb);
  auto _array_indices_type = _o->array_indices.type;
  auto _array_indices = _o->array_indices.Pack(_fbb);
  return tflite::CreateDimensionMetadata(
      _fbb,
      _format,
      _dense_size,
      _array_segments_type,
      _array_segments,
      _array_indices_type,
      _array_indices);
}

inline SparsityParametersT *SparsityParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SparsityParametersT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SparsityParameters::UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = traversal_order(); if (_e) { _o->traversal_order.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traversal_order[_i] = _e->Get(_i); } } }
  { auto _e = block_map(); if (_e) { _o->block_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_map[_i] = _e->Get(_i); } } }
  { auto _e = dim_metadata(); if (_e) { _o->dim_metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim_metadata[_i] = std::unique_ptr<tflite::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparsityParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparsityParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;
  auto _block_map = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;
  auto _dim_metadata = _o->dim_metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>> (_o->dim_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateSparsityParameters(
      _fbb,
      _traversal_order,
      _block_map,
      _dim_metadata);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = buffer(); _o->buffer = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = quantization(); if (_e) _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver)); }
  { auto _e = is_variable(); _o->is_variable = _e; }
  { auto _e = sparsity(); if (_e) _o->sparsity = std::unique_ptr<tflite::SparsityParametersT>(_e->UnPack(_resolver)); }
  { auto _e = shape_signature(); if (_e) { _o->shape_signature.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape_signature[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _type = _o->type;
  auto _buffer = _o->buffer;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
  auto _is_variable = _o->is_variable;
  auto _sparsity = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;
  auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;
  return tflite::CreateTensor(
      _fbb,
      _shape,
      _type,
      _buffer,
      _name,
      _quantization,
      _is_variable,
      _sparsity,
      _shape_signature);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline Conv3DOptionsT *Conv3DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv3DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_d(); _o->stride_d = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_d_factor(); _o->dilation_d_factor = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline flatbuffers::Offset<Conv3DOptions> Conv3DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv3DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_d = _o->stride_d;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_d_factor = _o->dilation_d_factor;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateConv3DOptions(
      _fbb,
      _padding,
      _stride_d,
      _stride_w,
      _stride_h,
      _fused_activation_function,
      _dilation_d_factor,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = filter_width(); _o->filter_width = _e; }
  { auto _e = filter_height(); _o->filter_height = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _filter_width = _o->filter_width;
  auto _filter_height = _o->filter_height;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreatePool2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _filter_width,
      _filter_height,
      _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthwiseConv2DOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
  { auto _e = depth_multiplier(); _o->depth_multiplier = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = dilation_w_factor(); _o->dilation_w_factor = _e; }
  { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  auto _depth_multiplier = _o->depth_multiplier;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _dilation_w_factor = _o->dilation_w_factor;
  auto _dilation_h_factor = _o->dilation_h_factor;
  return tflite::CreateDepthwiseConv2DOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h,
      _depth_multiplier,
      _fused_activation_function,
      _dilation_w_factor,
      _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConcatEmbeddingsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_channels(); _o->num_channels = _e; }
  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } }
  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_channels = _o->num_channels;
  auto _num_columns_per_channel = _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
  auto _embedding_dim_per_channel = _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      _num_channels,
      _num_columns_per_channel,
      _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSHProjectionOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return tflite::CreateLSHProjectionOptions(
      _fbb,
      _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SVDFOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rank(); _o->rank = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rank = _o->rank;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSVDFOptions(
      _fbb,
      _rank,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateRNNOptions(
      _fbb,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SequenceRNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BidirectionalSequenceRNNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _time_major = _o->time_major;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _merge_outputs = _o->merge_outputs;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceRNNOptions(
      _fbb,
      _time_major,
      _fused_activation_function,
      _merge_outputs,
      _asymmetric_quantize_inputs);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FullyConnectedOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = weights_format(); _o->weights_format = _e; }
  { auto _e = keep_num_dims(); _o->keep_num_dims = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _weights_format = _o->weights_format;
  auto _keep_num_dims = _o->keep_num_dims;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateFullyConnectedOptions(
      _fbb,
      _fused_activation_function,
      _weights_format,
      _keep_num_dims,
      _asymmetric_quantize_inputs);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftmaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return tflite::CreateSoftmaxOptions(
      _fbb,
      _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConcatenationOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateConcatenationOptions(
      _fbb,
      _axis,
      _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }
}

inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateAddOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MulOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateMulOptions(
      _fbb,
      _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new L2NormOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateL2NormOptions(
      _fbb,
      _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LocalResponseNormalizationOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radius = _o->radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return tflite::CreateLocalResponseNormalizationOptions(
      _fbb,
      _radius,
      _bias,
      _alpha,
      _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = kernel_type(); _o->kernel_type = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _kernel_type = _o->kernel_type;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _kernel_type,
      _asymmetric_quantize_inputs);
}

inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnidirectionalSequenceLSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateUnidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _time_major,
      _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BidirectionalSequenceLSTMOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = cell_clip(); _o->cell_clip = _e; }
  { auto _e = proj_clip(); _o->proj_clip = _e; }
  { auto _e = merge_outputs(); _o->merge_outputs = _e; }
  { auto _e = time_major(); _o->time_major = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _cell_clip = _o->cell_clip;
  auto _proj_clip = _o->proj_clip;
  auto _merge_outputs = _o->merge_outputs;
  auto _time_major = _o->time_major;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBidirectionalSequenceLSTMOptions(
      _fbb,
      _fused_activation_function,
      _cell_clip,
      _proj_clip,
      _merge_outputs,
      _time_major,
      _asymmetric_quantize_inputs);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeBilinearOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }
}

inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeBilinearOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeNearestNeighborOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = align_corners(); _o->align_corners = _e; }
  { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _align_corners = _o->align_corners;
  auto _half_pixel_centers = _o->half_pixel_centers;
  return tflite::CreateResizeNearestNeighborOptions(
      _fbb,
      _align_corners,
      _half_pixel_centers);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subgraph(); _o->subgraph = _e; }
}

inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subgraph = _o->subgraph;
  return tflite::CreateCallOptions(
      _fbb,
      _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PadOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadOptions(
      _fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PadV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePadV2Options(
      _fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
  return tflite::CreateReshapeOptions(
      _fbb,
      _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceToBatchNDOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSpaceToBatchNDOptions(
      _fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchToSpaceNDOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBatchToSpaceNDOptions(
      _fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SkipGramOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ngram_size(); _o->ngram_size = _e; }
  { auto _e = max_skip_size(); _o->max_skip_size = _e; }
  { auto _e = include_all_ngrams(); _o->include_all_ngrams = _e; }
}

inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ngram_size = _o->ngram_size;
  auto _max_skip_size = _o->max_skip_size;
  auto _include_all_ngrams = _o->include_all_ngrams;
  return tflite::CreateSkipGramOptions(
      _fbb,
      _ngram_size,
      _max_skip_size,
      _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceToDepthOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
}

inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateSpaceToDepthOptions(
      _fbb,
      _block_size);
}

inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthToSpaceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
}

inline flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  return tflite::CreateDepthToSpaceOptions(
      _fbb,
      _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
  { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }
}

inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  auto _pot_scale_int16 = _o->pot_scale_int16;
  return tflite::CreateSubOptions(
      _fbb,
      _fused_activation_function,
      _pot_scale_int16);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DivOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }
}

inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fused_activation_function = _o->fused_activation_function;
  return tflite::CreateDivOptions(
      _fbb,
      _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopKV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTopKV2Options(
      _fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EmbeddingLookupSparseOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = combiner(); _o->combiner = _e; }
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _combiner = _o->combiner;
  return tflite::CreateEmbeddingLookupSparseOptions(
      _fbb,
      _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = batch_dims(); _o->batch_dims = _e; }
}

inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _batch_dims = _o->batch_dims;
  return tflite::CreateGatherOptions(
      _fbb,
      _axis,
      _batch_dims);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTransposeOptions(
      _fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpOptions(
      _fbb);
}

inline CosOptionsT *CosOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CosOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CosOptions::UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CosOptions> CosOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCosOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateCosOptions(
      _fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReducerOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; }
}

inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  return tflite::CreateReducerOptions(
      _fbb,
      _keep_dims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SqueezeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(
      _fbb,
      _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SplitOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitOptions(
      _fbb,
      _num_splits);
}

inline SplitVOptionsT *SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SplitVOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_splits(); _o->num_splits = _e; }
}

inline flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_splits = _o->num_splits;
  return tflite::CreateSplitVOptions(
      _fbb,
      _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StridedSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; }
  { auto _e = end_mask(); _o->end_mask = _e; }
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
}

inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  return tflite::CreateStridedSliceOptions(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogSoftmaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogSoftmaxOptions(
      _fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CastOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_data_type(); _o->in_data_type = _e; }
  { auto _e = out_data_type(); _o->out_data_type = _e; }
}

inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_data_type = _o->in_data_type;
  auto _out_data_type = _o->out_data_type;
  return tflite::CreateCastOptions(
      _fbb,
      _in_data_type,
      _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DequantizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDequantizeOptions(
      _fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MaximumMinimumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMaximumMinimumOptions(
      _fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TileOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateTileOptions(
      _fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMaxOptions(
      _fbb,
      _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMinOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_type(); _o->output_type = _e; }
}

inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_type = _o->output_type;
  return tflite::CreateArgMinOptions(
      _fbb,
      _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterOptions(
      _fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGreaterEqualOptions(
      _fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessOptions(
      _fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLessEqualOptions(
      _fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NegOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNegOptions(
      _fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectOptions(
      _fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSliceOptions(
      _fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeConvOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padding(); _o->padding = _e; }
  { auto _e = stride_w(); _o->stride_w = _e; }
  { auto _e = stride_h(); _o->stride_h = _e; }
}

inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padding = _o->padding;
  auto _stride_w = _o->stride_w;
  auto _stride_h = _o->stride_h;
  return tflite::CreateTransposeConvOptions(
      _fbb,
      _padding,
      _stride_w,
      _stride_h);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpandDimsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateExpandDimsOptions(
      _fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SparseToDenseOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = validate_indices(); _o->validate_indices = _e; }
}

inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _validate_indices = _o->validate_indices;
  return tflite::CreateSparseToDenseOptions(
      _fbb,
      _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateEqualOptions(
      _fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NotEqualOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNotEqualOptions(
      _fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShapeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_type(); _o->out_type = _e; }
}

inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_type = _o->out_type;
  return tflite::CreateShapeOptions(
      _fbb,
      _out_type);
}

inline RankOptionsT *RankOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RankOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RankOptions::UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RankOptions> RankOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRankOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRankOptions(
      _fbb);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PowOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreatePowOptions(
      _fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FakeQuantOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = num_bits(); _o->num_bits = _e; }
  { auto _e = narrow_range(); _o->narrow_range = _e; }
}

inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return tflite::CreateFakeQuantOptions(
      _fbb,
      _min,
      _max,
      _num_bits,
      _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PackOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values_count(); _o->values_count = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values_count = _o->values_count;
  auto _axis = _o->axis;
  return tflite::CreatePackOptions(
      _fbb,
      _values_count,
      _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalOrOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalOrOptions(
      _fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OneHotOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return tflite::CreateOneHotOptions(
      _fbb,
      _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AbsOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOptions> AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAbsOptions(
      _fbb);
}

inline HardSwishOptionsT *HardSwishOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HardSwishOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSwishOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHardSwishOptions(
      _fbb);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalAndOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalAndOptions(
      _fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogicalNotOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateLogicalNotOptions(
      _fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnpackOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return tflite::CreateUnpackOptions(
      _fbb,
      _num,
      _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloorDivOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorDivOptions(
      _fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SquareOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquareOptions(
      _fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ZerosLikeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateZerosLikeOptions(
      _fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FillOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFillOptions(
      _fbb);
}

inline FloorModOptionsT *FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloorModOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateFloorModOptions(
      _fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RangeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RangeOptions> RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRangeOptions(
      _fbb);
}

inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LeakyReluOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return tflite::CreateLeakyReluOptions(
      _fbb,
      _alpha);
}

inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SquaredDifferenceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSquaredDifferenceOptions(
      _fbb);
}

inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MirrorPadOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return tflite::CreateMirrorPadOptions(
      _fbb,
      _mode);
}

inline UniqueOptionsT *UniqueOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UniqueOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx_out_type(); _o->idx_out_type = _e; }
}

inline flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx_out_type = _o->idx_out_type;
  return tflite::CreateUniqueOptions(
      _fbb,
      _idx_out_type);
}

inline ReverseV2OptionsT *ReverseV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReverseV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReverseV2Options(
      _fbb);
}

inline AddNOptionsT *AddNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddNOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddNOptions> AddNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAddNOptions(
      _fbb);
}

inline GatherNdOptionsT *GatherNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherNdOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateGatherNdOptions(
      _fbb);
}

inline WhereOptionsT *WhereOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WhereOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<WhereOptions> WhereOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhereOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateWhereOptions(
      _fbb);
}

inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReverseSequenceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq_dim(); _o->seq_dim = _e; }
  { auto _e = batch_dim(); _o->batch_dim = _e; }
}

inline flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq_dim = _o->seq_dim;
  auto _batch_dim = _o->batch_dim;
  return tflite::CreateReverseSequenceOptions(
      _fbb,
      _seq_dim,
      _batch_dim);
}

inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatrixDiagOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixDiagOptions(
      _fbb);
}

inline QuantizeOptionsT *QuantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateQuantizeOptions(
      _fbb);
}

inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatrixSetDiagOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixSetDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateMatrixSetDiagOptions(
      _fbb);
}

inline IfOptionsT *IfOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IfOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IfOptions::UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = then_subgraph_index(); _o->then_subgraph_index = _e; }
  { auto _e = else_subgraph_index(); _o->else_subgraph_index = _e; }
}

inline flatbuffers::Offset<IfOptions> IfOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIfOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IfOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _then_subgraph_index = _o->then_subgraph_index;
  auto _else_subgraph_index = _o->else_subgraph_index;
  return tflite::CreateIfOptions(
      _fbb,
      _then_subgraph_index,
      _else_subgraph_index);
}

inline CallOnceOptionsT *CallOnceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallOnceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = init_subgraph_index(); _o->init_subgraph_index = _e; }
}

inline flatbuffers::Offset<CallOnceOptions> CallOnceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallOnceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOnceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _init_subgraph_index = _o->init_subgraph_index;
  return tflite::CreateCallOnceOptions(
      _fbb,
      _init_subgraph_index);
}

inline WhileOptionsT *WhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WhileOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; }
  { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }
}

inline flatbuffers::Offset<WhileOptions> WhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_subgraph_index = _o->cond_subgraph_index;
  auto _body_subgraph_index = _o->body_subgraph_index;
  return tflite::CreateWhileOptions(
      _fbb,
      _cond_subgraph_index,
      _body_subgraph_index);
}

inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV4OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV4OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV4Options(
      _fbb);
}

inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV5OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV5OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateNonMaxSuppressionV5Options(
      _fbb);
}

inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScatterNdOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateScatterNdOptions(
      _fbb);
}

inline SelectV2OptionsT *SelectV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectV2OptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSelectV2Options(
      _fbb);
}

inline DensifyOptionsT *DensifyOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DensifyOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDensifyOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DensifyOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDensifyOptions(
      _fbb);
}

inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SegmentSumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSegmentSumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SegmentSumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateSegmentSumOptions(
      _fbb);
}

inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchMatMulOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = adj_x(); _o->adj_x = _e; }
  { auto _e = adj_y(); _o->adj_y = _e; }
  { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }
}

inline flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchMatMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _adj_x = _o->adj_x;
  auto _adj_y = _o->adj_y;
  auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
  return tflite::CreateBatchMatMulOptions(
      _fbb,
      _adj_x,
      _adj_y,
      _asymmetric_quantize_inputs);
}

inline CumsumOptionsT *CumsumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CumsumOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; }
  { auto _e = reverse(); _o->reverse = _e; }
}

inline flatbuffers::Offset<CumsumOptions> CumsumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumsumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumsumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return tflite::CreateCumsumOptions(
      _fbb,
      _exclusive,
      _reverse);
}

inline BroadcastToOptionsT *BroadcastToOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BroadcastToOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BroadcastToOptions> BroadcastToOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastToOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateBroadcastToOptions(
      _fbb);
}

inline Rfft2dOptionsT *Rfft2dOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Rfft2dOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rfft2dOptions> Rfft2dOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRfft2dOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Rfft2dOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateRfft2dOptions(
      _fbb);
}

inline HashtableOptionsT *HashtableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = table_id(); _o->table_id = _e; }
  { auto _e = key_dtype(); _o->key_dtype = _e; }
  { auto _e = value_dtype(); _o->value_dtype = _e; }
}

inline flatbuffers::Offset<HashtableOptions> HashtableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _table_id = _o->table_id;
  auto _key_dtype = _o->key_dtype;
  auto _value_dtype = _o->value_dtype;
  return tflite::CreateHashtableOptions(
      _fbb,
      _table_id,
      _key_dtype,
      _value_dtype);
}

inline HashtableFindOptionsT *HashtableFindOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableFindOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableFindOptions> HashtableFindOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableFindOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableFindOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableFindOptions(
      _fbb);
}

inline HashtableImportOptionsT *HashtableImportOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableImportOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableImportOptions> HashtableImportOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableImportOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableImportOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableImportOptions(
      _fbb);
}

inline HashtableSizeOptionsT *HashtableSizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HashtableSizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableSizeOptions> HashtableSizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableSizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableSizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateHashtableSizeOptions(
      _fbb);
}

inline VarHandleOptionsT *VarHandleOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VarHandleOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = container(); if (_e) _o->container = _e->str(); }
  { auto _e = shared_name(); if (_e) _o->shared_name = _e->str(); }
}

inline flatbuffers::Offset<VarHandleOptions> VarHandleOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarHandleOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarHandleOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _container = _o->container.empty() ? 0 : _fbb.CreateString(_o->container);
  auto _shared_name = _o->shared_name.empty() ? 0 : _fbb.CreateString(_o->shared_name);
  return tflite::CreateVarHandleOptions(
      _fbb,
      _container,
      _shared_name);
}

inline ReadVariableOptionsT *ReadVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReadVariableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReadVariableOptions> ReadVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReadVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateReadVariableOptions(
      _fbb);
}

inline AssignVariableOptionsT *AssignVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AssignVariableOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AssignVariableOptions> AssignVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssignVariableOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateAssignVariableOptions(
      _fbb);
}

inline RandomOptionsT *RandomOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RandomOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RandomOptions::UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; }
  { auto _e = seed2(); _o->seed2 = _e; }
}

inline flatbuffers::Offset<RandomOptions> RandomOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return tflite::CreateRandomOptions(
      _fbb,
      _seed,
      _seed2);
}

inline BucketizeOptionsT *BucketizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BucketizeOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BucketizeOptions::UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boundaries(); if (_e) { _o->boundaries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundaries[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BucketizeOptions> BucketizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBucketizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BucketizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boundaries = _o->boundaries.size() ? _fbb.CreateVector(_o->boundaries) : 0;
  return tflite::CreateBucketizeOptions(
      _fbb,
      _boundaries);
}

inline GeluOptionsT *GeluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeluOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GeluOptions::UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = approximate(); _o->approximate = _e; }
}

inline flatbuffers::Offset<GeluOptions> GeluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _approximate = _o->approximate;
  return tflite::CreateGeluOptions(
      _fbb,
      _approximate);
}

inline DynamicUpdateSliceOptionsT *DynamicUpdateSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DynamicUpdateSliceOptionsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DynamicUpdateSliceOptions::UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DynamicUpdateSliceOptions> DynamicUpdateSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDynamicUpdateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DynamicUpdateSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return tflite::CreateDynamicUpdateSliceOptions(
      _fbb);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OperatorCodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deprecated_builtin_code(); _o->deprecated_builtin_code = _e; }
  { auto _e = custom_code(); if (_e) _o->custom_code = _e->str(); }
  { auto _e = version(); _o->version = _e; }
  { auto _e = builtin_code(); _o->builtin_code = _e; }
}

inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deprecated_builtin_code = _o->deprecated_builtin_code;
  auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
  auto _version = _o->version;
  auto _builtin_code = _o->builtin_code;
  return tflite::CreateOperatorCode(
      _fbb,
      _deprecated_builtin_code,
      _custom_code,
      _version,
      _builtin_code);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OperatorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opcode_index(); _o->opcode_index = _e; }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = builtin_options_type(); _o->builtin_options.type = _e; }
  { auto _e = builtin_options(); if (_e) _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver); }
  { auto _e = custom_options(); if (_e) { _o->custom_options.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom_options.begin()); } }
  { auto _e = custom_options_format(); _o->custom_options_format = _e; }
  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } }
  { auto _e = intermediates(); if (_e) { _o->intermediates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intermediates[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opcode_index = _o->opcode_index;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _builtin_options_type = _o->builtin_options.type;
  auto _builtin_options = _o->builtin_options.Pack(_fbb);
  auto _custom_options = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
  auto _custom_options_format = _o->custom_options_format;
  auto _mutating_variable_inputs = _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
  auto _intermediates = _o->intermediates.size() ? _fbb.CreateVector(_o->intermediates) : 0;
  return tflite::CreateOperator(
      _fbb,
      _opcode_index,
      _inputs,
      _outputs,
      _builtin_options_type,
      _builtin_options,
      _custom_options,
      _custom_options_format,
      _mutating_variable_inputs,
      _intermediates);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubGraphT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return tflite::CreateSubGraph(
      _fbb,
      _tensors,
      _inputs,
      _outputs,
      _operators,
      _name);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BufferT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::CreateBuffer(
      _fbb,
      _data);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MetadataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = buffer(); _o->buffer = _e; }
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buffer = _o->buffer;
  return tflite::CreateMetadata(
      _fbb,
      _name,
      _buffer);
}

inline TensorMapT *TensorMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorMap::UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tensor_index(); _o->tensor_index = _e; }
}

inline flatbuffers::Offset<TensorMap> TensorMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tensor_index = _o->tensor_index;
  return tflite::CreateTensorMap(
      _fbb,
      _name,
      _tensor_index);
}

inline SignatureDefT *SignatureDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SignatureDefT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SignatureDef::UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = signature_key(); if (_e) _o->signature_key = _e->str(); }
  { auto _e = subgraph_index(); _o->subgraph_index = _e; }
}

inline flatbuffers::Offset<SignatureDef> SignatureDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignatureDef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignatureDefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_key = _o->signature_key.empty() ? 0 : _fbb.CreateString(_o->signature_key);
  auto _subgraph_index = _o->subgraph_index;
  return tflite::CreateSignatureDef(
      _fbb,
      _inputs,
      _outputs,
      _signature_key,
      _subgraph_index);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } }
  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata[_i] = std::unique_ptr<tflite::MetadataT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = signature_defs(); if (_e) { _o->signature_defs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signature_defs[_i] = std::unique_ptr<tflite::SignatureDefT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
  auto _metadata = _o->metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>> (_o->metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signature_defs = _o->signature_defs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SignatureDef>> (_o->signature_defs.size(), [](size_t i, _VectorArgs *__va) { return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::CreateModel(
      _fbb,
      _version,
      _operator_codes,
      _subgraphs,
      _description,
      _buffers,
      _metadata_buffer,
      _metadata,
      _signature_defs);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier, values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantizationT *>(value);
      return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u) noexcept : type(u.type), value(nullptr) {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      value = new tflite::CustomQuantizationT(*reinterpret_cast<tflite::CustomQuantizationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void QuantizationDetailsUnion::Reset() {
  switch (type) {
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<tflite::CustomQuantizationT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = QuantizationDetails_NONE;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {
  switch (type) {
    case SparseIndexVector_NONE: {
      return true;
    }
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySparseIndexVector(
        verifier, values->Get(i), types->GetEnum<SparseIndexVector>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32VectorT *>(value);
      return CreateInt32Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16VectorT *>(value);
      return CreateUint16Vector(_fbb, ptr, _rehasher).Union();
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8VectorT *>(value);
      return CreateUint8Vector(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SparseIndexVectorUnion::SparseIndexVectorUnion(const SparseIndexVectorUnion &u) noexcept : type(u.type), value(nullptr) {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      value = new tflite::Int32VectorT(*reinterpret_cast<tflite::Int32VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      value = new tflite::Uint16VectorT(*reinterpret_cast<tflite::Uint16VectorT *>(u.value));
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      value = new tflite::Uint8VectorT(*reinterpret_cast<tflite::Uint8VectorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SparseIndexVectorUnion::Reset() {
  switch (type) {
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<tflite::Int32VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<tflite::Uint16VectorT *>(value);
      delete ptr;
      break;
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<tflite::Uint8VectorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SparseIndexVector_NONE;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier, values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptions *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptionsT *>(value);
      return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value);
      return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value);
      return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value);
      return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptionsT *>(value);
      return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptionsT *>(value);
      return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptionsT *>(value);
      return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value);
      return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptionsT *>(value);
      return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptionsT *>(value);
      return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptionsT *>(value);
      return CreateAddOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptionsT *>(value);
      return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value);
      return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptionsT *>(value);
      return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value);
      return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptionsT *>(value);
      return CreateCallOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptionsT *>(value);
      return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptionsT *>(value);
      return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value);
      return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value);
      return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptionsT *>(value);
      return CreateMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptionsT *>(value);
      return CreatePadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptionsT *>(value);
      return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value);
      return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value);
      return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptionsT *>(value);
      return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptionsT *>(value);
      return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptionsT *>(value);
      return CreateSubOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptionsT *>(value);
      return CreateDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptionsT *>(value);
      return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value);
      return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptionsT *>(value);
      return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptionsT *>(value);
      return CreateExpOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2OptionsT *>(value);
      return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptionsT *>(value);
      return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value);
      return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptionsT *>(value);
      return CreateCastOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptionsT *>(value);
      return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value);
      return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptionsT *>(value);
      return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptionsT *>(value);
      return CreateLessOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptionsT *>(value);
      return CreateNegOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2OptionsT *>(value);
      return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptionsT *>(value);
      return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value);
      return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptionsT *>(value);
      return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptionsT *>(value);
      return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptionsT *>(value);
      return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptionsT *>(value);
      return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value);
      return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptionsT *>(value);
      return CreateTileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value);
      return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptionsT *>(value);
      return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptionsT *>(value);
      return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptionsT *>(value);
      return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptionsT *>(value);
      return CreatePowOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptionsT *>(value);
      return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptionsT *>(value);
      return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptionsT *>(value);
      return CreatePackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptionsT *>(value);
      return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptionsT *>(value);
      return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptionsT *>(value);
      return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptionsT *>(value);
      return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptionsT *>(value);
      return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptionsT *>(value);
      return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptionsT *>(value);
      return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value);
      return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptionsT *>(value);
      return CreateFillOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value);
      return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptionsT *>(value);
      return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptionsT *>(value);
      return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value);
      return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptionsT *>(value);
      return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value);
      return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptionsT *>(value);
      return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptionsT *>(value);
      return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptionsT *>(value);
      return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptionsT *>(value);
      return CreateUniqueOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2OptionsT *>(value);
      return CreateReverseV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptionsT *>(value);
      return CreateAddNOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptionsT *>(value);
      return CreateGatherNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptionsT *>(value);
      return CreateCosOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptionsT *>(value);
      return CreateWhereOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptionsT *>(value);
      return CreateRankOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value);
      return CreateReverseSequenceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value);
      return CreateMatrixDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptionsT *>(value);
      return CreateQuantizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value);
      return CreateMatrixSetDiagOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptionsT *>(value);
      return CreateHardSwishOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptionsT *>(value);
      return CreateIfOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptionsT *>(value);
      return CreateWhileOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value);
      return CreateDepthToSpaceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value);
      return CreateNonMaxSuppressionV4Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value);
      return CreateNonMaxSuppressionV5Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptionsT *>(value);
      return CreateScatterNdOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2OptionsT *>(value);
      return CreateSelectV2Options(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptionsT *>(value);
      return CreateDensifyOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptionsT *>(value);
      return CreateSegmentSumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value);
      return CreateBatchMatMulOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptionsT *>(value);
      return CreateCumsumOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptionsT *>(value);
      return CreateCallOnceOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptionsT *>(value);
      return CreateBroadcastToOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptionsT *>(value);
      return CreateRfft2dOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptionsT *>(value);
      return CreateConv3DOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptionsT *>(value);
      return CreateHashtableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptionsT *>(value);
      return CreateHashtableFindOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptionsT *>(value);
      return CreateHashtableImportOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptionsT *>(value);
      return CreateHashtableSizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptionsT *>(value);
      return CreateVarHandleOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptionsT *>(value);
      return CreateReadVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptionsT *>(value);
      return CreateAssignVariableOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptionsT *>(value);
      return CreateRandomOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptionsT *>(value);
      return CreateBucketizeOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptionsT *>(value);
      return CreateGeluOptions(_fbb, ptr, _rehasher).Union();
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::DynamicUpdateSliceOptionsT *>(value);
      return CreateDynamicUpdateSliceOptions(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) noexcept : type(u.type), value(nullptr) {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      value = new tflite::Conv2DOptionsT(*reinterpret_cast<tflite::Conv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      value = new tflite::DepthwiseConv2DOptionsT(*reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      value = new tflite::ConcatEmbeddingsOptionsT(*reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      value = new tflite::LSHProjectionOptionsT(*reinterpret_cast<tflite::LSHProjectionOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      value = new tflite::Pool2DOptionsT(*reinterpret_cast<tflite::Pool2DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      value = new tflite::SVDFOptionsT(*reinterpret_cast<tflite::SVDFOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RNNOptions: {
      value = new tflite::RNNOptionsT(*reinterpret_cast<tflite::RNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      value = new tflite::FullyConnectedOptionsT(*reinterpret_cast<tflite::FullyConnectedOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      value = new tflite::SoftmaxOptionsT(*reinterpret_cast<tflite::SoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      value = new tflite::ConcatenationOptionsT(*reinterpret_cast<tflite::ConcatenationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddOptions: {
      value = new tflite::AddOptionsT(*reinterpret_cast<tflite::AddOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      value = new tflite::L2NormOptionsT(*reinterpret_cast<tflite::L2NormOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      value = new tflite::LocalResponseNormalizationOptionsT(*reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      value = new tflite::LSTMOptionsT(*reinterpret_cast<tflite::LSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      value = new tflite::ResizeBilinearOptionsT(*reinterpret_cast<tflite::ResizeBilinearOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOptions: {
      value = new tflite::CallOptionsT(*reinterpret_cast<tflite::CallOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      value = new tflite::ReshapeOptionsT(*reinterpret_cast<tflite::ReshapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      value = new tflite::SkipGramOptionsT(*reinterpret_cast<tflite::SkipGramOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      value = new tflite::SpaceToDepthOptionsT(*reinterpret_cast<tflite::SpaceToDepthOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      value = new tflite::EmbeddingLookupSparseOptionsT(*reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MulOptions: {
      value = new tflite::MulOptionsT(*reinterpret_cast<tflite::MulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadOptions: {
      value = new tflite::PadOptionsT(*reinterpret_cast<tflite::PadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherOptions: {
      value = new tflite::GatherOptionsT(*reinterpret_cast<tflite::GatherOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      value = new tflite::BatchToSpaceNDOptionsT(*reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      value = new tflite::SpaceToBatchNDOptionsT(*reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      value = new tflite::TransposeOptionsT(*reinterpret_cast<tflite::TransposeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      value = new tflite::ReducerOptionsT(*reinterpret_cast<tflite::ReducerOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SubOptions: {
      value = new tflite::SubOptionsT(*reinterpret_cast<tflite::SubOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DivOptions: {
      value = new tflite::DivOptionsT(*reinterpret_cast<tflite::DivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      value = new tflite::SqueezeOptionsT(*reinterpret_cast<tflite::SqueezeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      value = new tflite::SequenceRNNOptionsT(*reinterpret_cast<tflite::SequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      value = new tflite::StridedSliceOptionsT(*reinterpret_cast<tflite::StridedSliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpOptions: {
      value = new tflite::ExpOptionsT(*reinterpret_cast<tflite::ExpOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      value = new tflite::TopKV2OptionsT(*reinterpret_cast<tflite::TopKV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitOptions: {
      value = new tflite::SplitOptionsT(*reinterpret_cast<tflite::SplitOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      value = new tflite::LogSoftmaxOptionsT(*reinterpret_cast<tflite::LogSoftmaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CastOptions: {
      value = new tflite::CastOptionsT(*reinterpret_cast<tflite::CastOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      value = new tflite::DequantizeOptionsT(*reinterpret_cast<tflite::DequantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      value = new tflite::MaximumMinimumOptionsT(*reinterpret_cast<tflite::MaximumMinimumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      value = new tflite::ArgMaxOptionsT(*reinterpret_cast<tflite::ArgMaxOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessOptions: {
      value = new tflite::LessOptionsT(*reinterpret_cast<tflite::LessOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NegOptions: {
      value = new tflite::NegOptionsT(*reinterpret_cast<tflite::NegOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PadV2Options: {
      value = new tflite::PadV2OptionsT(*reinterpret_cast<tflite::PadV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      value = new tflite::GreaterOptionsT(*reinterpret_cast<tflite::GreaterOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      value = new tflite::GreaterEqualOptionsT(*reinterpret_cast<tflite::GreaterEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      value = new tflite::LessEqualOptionsT(*reinterpret_cast<tflite::LessEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectOptions: {
      value = new tflite::SelectOptionsT(*reinterpret_cast<tflite::SelectOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SliceOptions: {
      value = new tflite::SliceOptionsT(*reinterpret_cast<tflite::SliceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      value = new tflite::TransposeConvOptionsT(*reinterpret_cast<tflite::TransposeConvOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      value = new tflite::SparseToDenseOptionsT(*reinterpret_cast<tflite::SparseToDenseOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_TileOptions: {
      value = new tflite::TileOptionsT(*reinterpret_cast<tflite::TileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      value = new tflite::ExpandDimsOptionsT(*reinterpret_cast<tflite::ExpandDimsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_EqualOptions: {
      value = new tflite::EqualOptionsT(*reinterpret_cast<tflite::EqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      value = new tflite::NotEqualOptionsT(*reinterpret_cast<tflite::NotEqualOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      value = new tflite::ShapeOptionsT(*reinterpret_cast<tflite::ShapeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PowOptions: {
      value = new tflite::PowOptionsT(*reinterpret_cast<tflite::PowOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      value = new tflite::ArgMinOptionsT(*reinterpret_cast<tflite::ArgMinOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      value = new tflite::FakeQuantOptionsT(*reinterpret_cast<tflite::FakeQuantOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_PackOptions: {
      value = new tflite::PackOptionsT(*reinterpret_cast<tflite::PackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      value = new tflite::LogicalOrOptionsT(*reinterpret_cast<tflite::LogicalOrOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      value = new tflite::OneHotOptionsT(*reinterpret_cast<tflite::OneHotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      value = new tflite::LogicalAndOptionsT(*reinterpret_cast<tflite::LogicalAndOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      value = new tflite::LogicalNotOptionsT(*reinterpret_cast<tflite::LogicalNotOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      value = new tflite::UnpackOptionsT(*reinterpret_cast<tflite::UnpackOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      value = new tflite::FloorDivOptionsT(*reinterpret_cast<tflite::FloorDivOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquareOptions: {
      value = new tflite::SquareOptionsT(*reinterpret_cast<tflite::SquareOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      value = new tflite::ZerosLikeOptionsT(*reinterpret_cast<tflite::ZerosLikeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FillOptions: {
      value = new tflite::FillOptionsT(*reinterpret_cast<tflite::FillOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      value = new tflite::BidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      value = new tflite::BidirectionalSequenceRNNOptionsT(*reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      value = new tflite::UnidirectionalSequenceLSTMOptionsT(*reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      value = new tflite::FloorModOptionsT(*reinterpret_cast<tflite::FloorModOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RangeOptions: {
      value = new tflite::RangeOptionsT(*reinterpret_cast<tflite::RangeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      value = new tflite::ResizeNearestNeighborOptionsT(*reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      value = new tflite::LeakyReluOptionsT(*reinterpret_cast<tflite::LeakyReluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      value = new tflite::SquaredDifferenceOptionsT(*reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      value = new tflite::MirrorPadOptionsT(*reinterpret_cast<tflite::MirrorPadOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AbsOptions: {
      value = new tflite::AbsOptionsT(*reinterpret_cast<tflite::AbsOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      value = new tflite::SplitVOptionsT(*reinterpret_cast<tflite::SplitVOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      value = new tflite::UniqueOptionsT(*reinterpret_cast<tflite::UniqueOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      value = new tflite::ReverseV2OptionsT(*reinterpret_cast<tflite::ReverseV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AddNOptions: {
      value = new tflite::AddNOptionsT(*reinterpret_cast<tflite::AddNOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      value = new tflite::GatherNdOptionsT(*reinterpret_cast<tflite::GatherNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CosOptions: {
      value = new tflite::CosOptionsT(*reinterpret_cast<tflite::CosOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhereOptions: {
      value = new tflite::WhereOptionsT(*reinterpret_cast<tflite::WhereOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RankOptions: {
      value = new tflite::RankOptionsT(*reinterpret_cast<tflite::RankOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      value = new tflite::ReverseSequenceOptionsT(*reinterpret_cast<tflite::ReverseSequenceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      value = new tflite::MatrixDiagOptionsT(*reinterpret_cast<tflite::MatrixDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      value = new tflite::QuantizeOptionsT(*reinterpret_cast<tflite::QuantizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      value = new tflite::MatrixSetDiagOptionsT(*reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      value = new tflite::HardSwishOptionsT(*reinterpret_cast<tflite::HardSwishOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_IfOptions: {
      value = new tflite::IfOptionsT(*reinterpret_cast<tflite::IfOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_WhileOptions: {
      value = new tflite::WhileOptionsT(*reinterpret_cast<tflite::WhileOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      value = new tflite::DepthToSpaceOptionsT(*reinterpret_cast<tflite::DepthToSpaceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      value = new tflite::NonMaxSuppressionV4OptionsT(*reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      value = new tflite::NonMaxSuppressionV5OptionsT(*reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      value = new tflite::ScatterNdOptionsT(*reinterpret_cast<tflite::ScatterNdOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      value = new tflite::SelectV2OptionsT(*reinterpret_cast<tflite::SelectV2OptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      value = new tflite::DensifyOptionsT(*reinterpret_cast<tflite::DensifyOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      value = new tflite::SegmentSumOptionsT(*reinterpret_cast<tflite::SegmentSumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      value = new tflite::BatchMatMulOptionsT(*reinterpret_cast<tflite::BatchMatMulOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      value = new tflite::CumsumOptionsT(*reinterpret_cast<tflite::CumsumOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      value = new tflite::CallOnceOptionsT(*reinterpret_cast<tflite::CallOnceOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      value = new tflite::BroadcastToOptionsT(*reinterpret_cast<tflite::BroadcastToOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      value = new tflite::Rfft2dOptionsT(*reinterpret_cast<tflite::Rfft2dOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      value = new tflite::Conv3DOptionsT(*reinterpret_cast<tflite::Conv3DOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      value = new tflite::HashtableOptionsT(*reinterpret_cast<tflite::HashtableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      value = new tflite::HashtableFindOptionsT(*reinterpret_cast<tflite::HashtableFindOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      value = new tflite::HashtableImportOptionsT(*reinterpret_cast<tflite::HashtableImportOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      value = new tflite::HashtableSizeOptionsT(*reinterpret_cast<tflite::HashtableSizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      value = new tflite::VarHandleOptionsT(*reinterpret_cast<tflite::VarHandleOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      value = new tflite::ReadVariableOptionsT(*reinterpret_cast<tflite::ReadVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      value = new tflite::AssignVariableOptionsT(*reinterpret_cast<tflite::AssignVariableOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_RandomOptions: {
      value = new tflite::RandomOptionsT(*reinterpret_cast<tflite::RandomOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      value = new tflite::BucketizeOptionsT(*reinterpret_cast<tflite::BucketizeOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_GeluOptions: {
      value = new tflite::GeluOptionsT(*reinterpret_cast<tflite::GeluOptionsT *>(u.value));
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      value = new tflite::DynamicUpdateSliceOptionsT(*reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BuiltinOptionsUnion::Reset() {
  switch (type) {
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<tflite::Conv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<tflite::LSHProjectionOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<tflite::Pool2DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<tflite::SVDFOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<tflite::RNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<tflite::FullyConnectedOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::SoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<tflite::ConcatenationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<tflite::AddOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<tflite::L2NormOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<tflite::LSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<tflite::CallOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<tflite::ReshapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<tflite::SkipGramOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<tflite::MulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<tflite::PadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<tflite::GatherOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<tflite::ReducerOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<tflite::SubOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<tflite::DivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<tflite::SqueezeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::SequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<tflite::StridedSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<tflite::ExpOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<tflite::TopKV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<tflite::SplitOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<tflite::CastOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<tflite::DequantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMaxOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<tflite::LessOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<tflite::NegOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<tflite::PadV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<tflite::GreaterEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<tflite::LessEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<tflite::SelectOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<tflite::SliceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<tflite::TransposeConvOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<tflite::SparseToDenseOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<tflite::TileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<tflite::ExpandDimsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<tflite::EqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<tflite::NotEqualOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<tflite::ShapeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<tflite::PowOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<tflite::ArgMinOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<tflite::FakeQuantOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<tflite::PackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalOrOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<tflite::OneHotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalAndOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<tflite::LogicalNotOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<tflite::UnpackOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<tflite::FloorDivOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<tflite::SquareOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<tflite::ZerosLikeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<tflite::FillOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<tflite::FloorModOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<tflite::RangeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<tflite::LeakyReluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<tflite::MirrorPadOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<tflite::AbsOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<tflite::SplitVOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<tflite::UniqueOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<tflite::ReverseV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<tflite::AddNOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<tflite::GatherNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<tflite::CosOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<tflite::WhereOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<tflite::RankOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<tflite::MatrixDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<tflite::QuantizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<tflite::HardSwishOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<tflite::IfOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<tflite::WhileOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<tflite::ScatterNdOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<tflite::SelectV2OptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<tflite::DensifyOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<tflite::SegmentSumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<tflite::BatchMatMulOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<tflite::CumsumOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<tflite::CallOnceOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<tflite::BroadcastToOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<tflite::Rfft2dOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<tflite::Conv3DOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableFindOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableImportOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<tflite::HashtableSizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<tflite::VarHandleOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<tflite::ReadVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<tflite::AssignVariableOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<tflite::RandomOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<tflite::BucketizeOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<tflite::GeluOptionsT *>(value);
      delete ptr;
      break;
    }
    case BuiltinOptions_DynamicUpdateSliceOptions: {
      auto ptr = reinterpret_cast<tflite::DynamicUpdateSliceOptionsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BuiltinOptions_NONE;
}

inline const tflite::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "tflite";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<tflite::ModelT> UnPackModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}
# 29 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h" 2

namespace tflite {


class BuiltinDataAllocator {
 public:
  virtual void* Allocate(size_t size, size_t alignment_hint) = 0;
  virtual void Deallocate(void* data) = 0;





  template <typename T>
  T* AllocatePOD() {


    static_assert(std::is_pod<T>::value, "Builtin data structure must be POD.");
    void* allocated_memory = this->Allocate(sizeof(T), alignof(T));
    return new (allocated_memory) T();
  }

  virtual ~BuiltinDataAllocator() {}
};
# 63 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/flatbuffer_conversions.h"
TfLiteStatus ParseOpData(const Operator* op, BuiltinOperator op_type,
                         ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);



TfLiteStatus ConvertTensorType(TensorType tensor_type, TfLiteType* type,
                               ErrorReporter* error_reporter);

TfLiteStatus ParseAbs(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseAdd(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseAddN(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseArgMax(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseArgMin(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseAssignVariable(const Operator* op,
                                 ErrorReporter* error_reporter,
                                 BuiltinDataAllocator* allocator,
                                 void** builtin_data);

TfLiteStatus ParseBatchMatMul(const Operator* op, ErrorReporter* error_reporter,
                              BuiltinDataAllocator* allocator,
                              void** builtin_data);

TfLiteStatus ParseBatchToSpaceNd(const Operator* op,
                                 ErrorReporter* error_reporter,
                                 BuiltinDataAllocator* allocator,
                                 void** builtin_data);

TfLiteStatus ParseCallOnce(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseCeil(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseCast(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseConcatenation(const Operator* op,
                                ErrorReporter* error_reporter,
                                BuiltinDataAllocator* allocator,
                                void** builtin_data);

TfLiteStatus ParseConv2D(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseCos(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseCumsum(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseDepthToSpace(const Operator* op,
                               ErrorReporter* error_reporter,
                               BuiltinDataAllocator* allocator,
                               void** builtin_data);

TfLiteStatus ParseDepthwiseConv2D(const Operator* op,
                                  ErrorReporter* error_reporter,
                                  BuiltinDataAllocator* allocator,
                                  void** builtin_data);

TfLiteStatus ParseDequantize(const Operator* op, ErrorReporter* error_reporter,
                             BuiltinDataAllocator* allocator,
                             void** builtin_data);

TfLiteStatus ParseDiv(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseElu(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseEqual(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseExp(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseExpandDims(const Operator* op, ErrorReporter* error_reporter,
                             BuiltinDataAllocator* allocator,
                             void** builtin_data);

TfLiteStatus ParseFill(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseFloor(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseFloorDiv(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseFloorMod(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseFullyConnected(const Operator* op,
                                 ErrorReporter* error_reporter,
                                 BuiltinDataAllocator* allocator,
                                 void** builtin_data);

TfLiteStatus ParseGather(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseGatherNd(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseGreater(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseGreaterEqual(const Operator* op,
                               ErrorReporter* error_reporter,
                               BuiltinDataAllocator* allocator,
                               void** builtin_data);

TfLiteStatus ParseHardSwish(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseIf(const Operator* op, ErrorReporter* error_reporter,
                     BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseL2Normalization(const Operator* op,
                                  ErrorReporter* error_reporter,
                                  BuiltinDataAllocator* allocator,
                                  void** builtin_data);

TfLiteStatus ParseLeakyRelu(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseLess(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseLessEqual(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseLog(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseLogicalAnd(const Operator* op, ErrorReporter* error_reporter,
                             BuiltinDataAllocator* allocator,
                             void** builtin_data);

TfLiteStatus ParseLogicalNot(const Operator* op, ErrorReporter* error_reporter,
                             BuiltinDataAllocator* allocator,
                             void** builtin_data);

TfLiteStatus ParseLogicalOr(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseLogistic(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseLogSoftmax(const Operator* op, ErrorReporter* error_reporter,
                             BuiltinDataAllocator* allocator,
                             void** builtin_data);

TfLiteStatus ParseLSTM(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseMaximum(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseMinimum(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseMirrorPad(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseMul(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseNeg(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseNotEqual(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParsePack(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParsePad(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParsePadV2(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParsePool(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParsePow(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParsePrelu(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseQuantize(const Operator* op, ErrorReporter* error_reporter,
                           BuiltinDataAllocator* allocator,
                           void** builtin_data);

TfLiteStatus ParseReadVariable(const Operator* op,
                               ErrorReporter* error_reporter,
                               BuiltinDataAllocator* allocator,
                               void** builtin_data);

TfLiteStatus ParseReducer(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseRelu(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseRelu6(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseReshape(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseResizeBilinear(const Operator* op,
                                 ErrorReporter* error_reporter,
                                 BuiltinDataAllocator* allocator,
                                 void** builtin_data);

TfLiteStatus ParseResizeNearestNeighbor(const Operator* op,
                                        ErrorReporter* error_reporter,
                                        BuiltinDataAllocator* allocator,
                                        void** builtin_data);

TfLiteStatus ParseRound(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseRsqrt(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseShape(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSin(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSlice(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSoftmax(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSpaceToBatchNd(const Operator* op,
                                 ErrorReporter* error_reporter,
                                 BuiltinDataAllocator* allocator,
                                 void** builtin_data);

TfLiteStatus ParseSpaceToDepth(const Operator* op,
                               ErrorReporter* error_reporter,
                               BuiltinDataAllocator* allocator,
                               void** builtin_data);

TfLiteStatus ParseSplit(const Operator* op, ErrorReporter* error_reporter,
                        BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSplitV(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSqueeze(const Operator* op, ErrorReporter* error_reporter,
                          BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSqrt(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSquare(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseStridedSlice(const Operator* op,
                               ErrorReporter* error_reporter,
                               BuiltinDataAllocator* allocator,
                               void** builtin_data);

TfLiteStatus ParseSub(const Operator* op, ErrorReporter* error_reporter,
                      BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseSvdf(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseTanh(const Operator* op, ErrorReporter* error_reporter,
                       BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseTranspose(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseTransposeConv(const Operator* op,
                                ErrorReporter* error_reporter,
                                BuiltinDataAllocator* allocator,
                                void** builtin_data);

TfLiteStatus ParseUnpack(const Operator* op, ErrorReporter* error_reporter,
                         BuiltinDataAllocator* allocator, void** builtin_data);

TfLiteStatus ParseUnidirectionalSequenceLSTM(const Operator* op,
                                             ErrorReporter* error_reporter,
                                             BuiltinDataAllocator* allocator,
                                             void** builtin_data);

TfLiteStatus ParseVarHandle(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

TfLiteStatus ParseZerosLike(const Operator* op, ErrorReporter* error_reporter,
                            BuiltinDataAllocator* allocator,
                            void** builtin_data);

}
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/compatibility.h" 1
# 20 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/compatibility.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/op_macros.h" 1
# 18 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/op_macros.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/debug_log.h" 1
# 19 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/debug_log.h"
extern "C" {





void DebugLog(const char* s);


}
# 19 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/op_macros.h" 2
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/compatibility.h" 2
# 25 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2

# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/compatibility.h" 1
# 27 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/conv.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/conv.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/builtin_op_data.h" 1
# 23 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/builtin_op_data.h"
extern "C" {
# 33 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/builtin_op_data.h"
typedef struct {
  char dummy;
} EmptyStructPlaceholder;





typedef enum {
  kTfLitePaddingUnknown = 0,
  kTfLitePaddingSame,
  kTfLitePaddingValid,
} TfLitePadding;

typedef enum {
  kTfLiteMirrorPaddingUnknown = 0,
  kTfLiteMirrorPaddingReflect,
  kTfLiteMirrorPaddingSymmetric,
} TfLiteMirrorPaddingMode;


typedef struct {
  int width;
  int height;
  int width_offset;
  int height_offset;
} TfLitePaddingValues;

typedef struct {
  TfLiteMirrorPaddingMode mode;
} TfLiteMirrorPaddingParams;


typedef enum {
  kTfLiteActNone = 0,
  kTfLiteActRelu,
  kTfLiteActReluN1To1,
  kTfLiteActRelu6,
  kTfLiteActTanh,
  kTfLiteActSignBit,
  kTfLiteActSigmoid,
} TfLiteFusedActivation;

typedef struct {

  TfLitePadding padding;
  int stride_width;
  int stride_height;
  TfLiteFusedActivation activation;



  int dilation_width_factor;
  int dilation_height_factor;
} TfLiteConvParams;

typedef struct {
  TfLitePadding padding;
  int stride_width;
  int stride_height;
  int stride_depth;
  int dilation_width_factor;
  int dilation_height_factor;
  int dilation_depth_factor;
  TfLiteFusedActivation activation;
} TfLiteConv3DParams;

typedef TfLiteConv3DParams TfLiteConv3DTransposeParams;

typedef struct {
  TfLitePadding padding;
  int stride_width;
  int stride_height;
  int filter_width;
  int filter_height;
  TfLiteFusedActivation activation;
  struct {
    TfLitePaddingValues padding;
  } computed;
} TfLitePoolParams;

typedef struct {

  TfLitePadding padding;
  int stride_width;
  int stride_height;
# 129 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/c/builtin_op_data.h"
  int depth_multiplier;
  TfLiteFusedActivation activation;

  int dilation_width_factor;
  int dilation_height_factor;
} TfLiteDepthwiseConvParams;

typedef struct {
  int rank;
  TfLiteFusedActivation activation;


  bool asymmetric_quantize_inputs;
} TfLiteSVDFParams;

typedef struct {
  TfLiteFusedActivation activation;


  bool asymmetric_quantize_inputs;
} TfLiteRNNParams;

typedef struct {
  bool time_major;
  TfLiteFusedActivation activation;


  bool asymmetric_quantize_inputs;
} TfLiteSequenceRNNParams;

typedef struct {
  bool time_major;
  TfLiteFusedActivation activation;
  bool merge_outputs;


  bool asymmetric_quantize_inputs;
} TfLiteBidirectionalSequenceRNNParams;

typedef enum {
  kTfLiteFullyConnectedWeightsFormatDefault = 0,
  kTfLiteFullyConnectedWeightsFormatShuffled4x16Int8 = 1,
} TfLiteFullyConnectedWeightsFormat;

typedef struct {

  TfLiteFusedActivation activation;


  TfLiteFullyConnectedWeightsFormat weights_format;





  bool keep_num_dims;




  bool asymmetric_quantize_inputs;
} TfLiteFullyConnectedParams;

typedef enum {
  kTfLiteLshProjectionUnknown = 0,
  kTfLiteLshProjectionSparse = 1,
  kTfLiteLshProjectionDense = 2,
} TfLiteLSHProjectionType;

typedef struct {
  TfLiteLSHProjectionType type;
} TfLiteLSHProjectionParams;

typedef struct {
  float beta;
} TfLiteSoftmaxParams;

typedef struct {
  int axis;
  TfLiteFusedActivation activation;
} TfLiteConcatenationParams;

typedef struct {
  TfLiteFusedActivation activation;

  bool pot_scale_int16;
} TfLiteAddParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteSpaceToBatchNDParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteBatchToSpaceNDParams;

typedef struct {
  bool adj_x;
  bool adj_y;



  bool asymmetric_quantize_inputs;
} TfLiteBatchMatMulParams;

typedef struct {
  TfLiteFusedActivation activation;
} TfLiteMulParams;

typedef struct {
  TfLiteFusedActivation activation;

  bool pot_scale_int16;
} TfLiteSubParams;

typedef struct {
  TfLiteFusedActivation activation;
} TfLiteDivParams;

typedef struct {
  TfLiteFusedActivation activation;
} TfLiteL2NormParams;

typedef struct {
  int radius;
  float bias;
  float alpha;
  float beta;
} TfLiteLocalResponseNormParams;

typedef enum {
  kTfLiteLSTMFullKernel = 0,
  kTfLiteLSTMBasicKernel
} TfLiteLSTMKernelType;

typedef struct {

  TfLiteFusedActivation activation;
  float cell_clip;
  float proj_clip;



  TfLiteLSTMKernelType kernel_type;


  bool asymmetric_quantize_inputs;
} TfLiteLSTMParams;

typedef struct {

  TfLiteFusedActivation activation;
  float cell_clip;
  float proj_clip;


  bool time_major;


  bool asymmetric_quantize_inputs;
} TfLiteUnidirectionalSequenceLSTMParams;

typedef struct {


  TfLiteFusedActivation activation;
  float cell_clip;
  float proj_clip;


  bool merge_outputs;



  bool time_major;



  bool asymmetric_quantize_inputs;
} TfLiteBidirectionalSequenceLSTMParams;

typedef struct {
  bool align_corners;



  bool half_pixel_centers;
} TfLiteResizeBilinearParams;

typedef struct {
  bool align_corners;
  bool half_pixel_centers;
} TfLiteResizeNearestNeighborParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLitePadParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLitePadV2Params;

typedef struct {



  int shape[8];
  int num_dimensions;
} TfLiteReshapeParams;

typedef struct {
  int ngram_size;
  int max_skip_size;
  bool include_all_ngrams;
} TfLiteSkipGramParams;

typedef struct {
  int block_size;
} TfLiteSpaceToDepthParams;

typedef struct {
  int block_size;
} TfLiteDepthToSpaceParams;

typedef struct {
  TfLiteType in_data_type;
  TfLiteType out_data_type;
} TfLiteCastParams;

typedef enum {
  kTfLiteCombinerTypeSum = 0,
  kTfLiteCombinerTypeMean = 1,
  kTfLiteCombinerTypeSqrtn = 2,
} TfLiteCombinerType;

typedef struct {
  TfLiteCombinerType combiner;
} TfLiteEmbeddingLookupSparseParams;

typedef struct {
  int axis;
  int batch_dims;
} TfLiteGatherParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteTransposeParams;

typedef struct {
  bool keep_dims;
} TfLiteReducerParams;

typedef struct {
  int num_splits;
} TfLiteSplitParams;

typedef struct {
  int num_splits;
} TfLiteSplitVParams;

typedef struct {


  int squeeze_dims[8];
  int num_squeeze_dims;
} TfLiteSqueezeParams;

typedef struct {
  int begin_mask;
  int end_mask;
  int ellipsis_mask;
  int new_axis_mask;
  int shrink_axis_mask;
} TfLiteStridedSliceParams;

typedef struct {
  TfLiteType output_type;
} TfLiteArgMaxParams;

typedef struct {
  TfLiteType output_type;
} TfLiteArgMinParams;

typedef struct {
  TfLitePadding padding;
  int stride_width;
  int stride_height;
} TfLiteTransposeConvParams;

typedef struct {
  bool validate_indices;
} TfLiteSparseToDenseParams;

typedef struct {
  TfLiteType out_type;
} TfLiteShapeParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteRankParams;

typedef struct {

  float min;
  float max;
  int num_bits;


  bool narrow_range;
} TfLiteFakeQuantParams;

typedef struct {
  int values_count;
  int axis;
} TfLitePackParams;

typedef struct {
  int axis;
} TfLiteOneHotParams;

typedef struct {
  int num;
  int axis;
} TfLiteUnpackParams;

typedef struct {
  float alpha;
} TfLiteLeakyReluParams;

typedef struct {
  TfLiteType index_out_type;
} TfLiteUniqueParams;

typedef struct {
  int seq_dim;
  int batch_dim;
} TfLiteReverseSequenceParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteMatrixDiagParams;

typedef struct {
  EmptyStructPlaceholder placeholder;
} TfLiteMatrixSetDiagParams;

typedef struct {
  int then_subgraph_index;
  int else_subgraph_index;
} TfLiteIfParams;

typedef struct {
  int cond_subgraph_index;
  int body_subgraph_index;
} TfLiteWhileParams;

typedef struct {
  bool exclusive;
  bool reverse;
} TfLiteCumsumParams;

typedef struct {
  int init_subgraph_index;
} TfLiteCallOnceParams;

typedef struct {
  int table_id;
  TfLiteType key_dtype;
  TfLiteType value_dtype;
} TfLiteHashtableParams;

typedef struct {
  const char* container;
  const char* shared_name;
} TfLiteVarHandleParams;

typedef struct {
  int seed;
  int seed2;
} TfLiteRandomParams;

typedef struct {
  int num_boundaries;


  const float* boundaries;
} TfLiteBucketizeParams;

typedef struct {
  bool approximate;
} TfLiteGeluParams;


}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/conv.h" 2

# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h" 1
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/runtime_shape.h" 1
# 18 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/runtime_shape.h"
namespace tflite {

template <int N>
struct Dims {
  int sizes[N];
  int strides[N];
};

class RuntimeShape {
 public:
  RuntimeShape& operator=(RuntimeShape const&) = delete;

  RuntimeShape() : size_(0) {}

  explicit RuntimeShape(int dimensions_count) : size_(dimensions_count) {}

  RuntimeShape(int shape_size, int32_t value) : size_(shape_size) {
    for (int i = 0; i < shape_size; ++i) {
      SetDim(i, value);
    }
  }

  RuntimeShape(int dimensions_count, const int32_t* dims_data)
      : size_(dimensions_count) {
    ReplaceWith(dimensions_count, dims_data);
  }

  bool operator==(const RuntimeShape& comp) const {
    return this->size_ == comp.size_ &&
           std::memcmp(DimsData(), comp.DimsData(), size_ * sizeof(int32_t)) ==
               0;
  }

  ~RuntimeShape() {}

  int32_t DimensionsCount() const { return size_; }
  int32_t Dims(int i) const {
    ((i) >= (0)) ? (void)0 : abort();
    ((i) < (size_)) ? (void)0 : abort();
    return dims_[i];
  }
  void SetDim(int i, int32_t val) {
    ((i) >= (0)) ? (void)0 : abort();
    ((i) < (size_)) ? (void)0 : abort();
    dims_[i] = val;
  }

  static RuntimeShape ExtendedShape(int new_shape_size,
                                    const RuntimeShape& shape) {
    return RuntimeShape(new_shape_size, shape, 1);
  }
  int32_t* DimsData() { return dims_; }
  const int32_t* DimsData() const { return dims_; }
  const int32_t* DimsDataUpTo5D() const { return dims_; }

  void ReplaceWith(int dimensions_count, const int32_t* dims_data) {
    size_ = dimensions_count;
    int32_t* dst_dims = DimsData();
    std::memcpy(dst_dims, dims_data, dimensions_count * sizeof(int32_t));
  }



  int FlatSize() const {
    int buffer_size = 1;
    const int* dims_data = reinterpret_cast<const int*>(DimsData());
    for (int i = 0; i < size_; i++) {
      buffer_size *= dims_data[i];
    }
    return buffer_size;
  }

 private:



  RuntimeShape(int new_shape_size, const RuntimeShape& shape, int pad_value)
      : size_(new_shape_size) {


    ((new_shape_size) >= (shape.DimensionsCount())) ? (void)0 : abort();
    const int size_increase = new_shape_size - shape.DimensionsCount();
    for (int i = 0; i < size_increase; ++i) {
      SetDim(i, pad_value);
    }
    std::memcpy(DimsData() + size_increase, shape.DimsData(),
                sizeof(int32_t) * shape.DimensionsCount());
  }


  static constexpr int kMaxSize = 5;
  int32_t size_;
  union {
    int32_t dims_[kMaxSize];
  };
};






inline int Offset(const RuntimeShape& shape, int i0, int i1, int i2, int i3) {
  ((shape.DimensionsCount()) == (4)) ? (void)0 : abort();
  const int* dims_data = reinterpret_cast<const int*>(shape.DimsData());
  ((dims_data[0] == 0 && i0 == 0) || (i0 >= 0 && i0 < dims_data[0])) ? (void)0 : abort();

  ((dims_data[1] == 0 && i1 == 0) || (i1 >= 0 && i1 < dims_data[1])) ? (void)0 : abort();

  ((dims_data[2] == 0 && i2 == 0) || (i2 >= 0 && i2 < dims_data[2])) ? (void)0 : abort();

  ((dims_data[3] == 0 && i3 == 0) || (i3 >= 0 && i3 < dims_data[3])) ? (void)0 : abort();

  return ((i0 * dims_data[1] + i1) * dims_data[2] + i2) * dims_data[3] + i3;
}

inline int Offset(const RuntimeShape& shape, int i0, int i1, int i2, int i3,
                  int i4) {
  ((shape.DimensionsCount()) == (5)) ? (void)0 : abort();
  const int* dims_data = reinterpret_cast<const int*>(shape.DimsData());
  ((dims_data[0] == 0 && i0 == 0) || (i0 >= 0 && i0 < dims_data[0])) ? (void)0 : abort();

  ((dims_data[1] == 0 && i1 == 0) || (i1 >= 0 && i1 < dims_data[1])) ? (void)0 : abort();

  ((dims_data[2] == 0 && i2 == 0) || (i2 >= 0 && i2 < dims_data[2])) ? (void)0 : abort();

  ((dims_data[3] == 0 && i3 == 0) || (i3 >= 0 && i3 < dims_data[3])) ? (void)0 : abort();

  ((dims_data[4] == 0 && i4 == 0) || (i4 >= 0 && i4 < dims_data[4])) ? (void)0 : abort();

  return (((i0 * dims_data[1] + i1) * dims_data[2] + i2) * dims_data[3] + i3) *
             dims_data[4] +
         i4;
}

}
# 25 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h" 2

namespace tflite {

enum class FusedActivationFunctionType : uint8_t {
  kNone,
  kRelu6,
  kRelu1,
  kRelu
};
enum class PaddingType : uint8_t { kNone, kSame, kValid };

struct PaddingValues {
  int16_t width;
  int16_t height;



  int16_t width_offset;

  int16_t height_offset;
};

struct Padding3DValues {
  int16_t width;
  int16_t height;
  int16_t depth;



  int16_t width_offset;

  int16_t height_offset;

  int16_t depth_offset;
};




enum class FullyConnectedWeightsFormat : uint8_t {


  kDefault,
# 119 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h"
  kShuffled4x16Int8,
};
# 133 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h"
struct QuantizationParams {
  int32_t zero_point = 0;
  double scale = 0.0;
};

inline bool operator==(const QuantizationParams& qp1,
                       const QuantizationParams& qp2) {
  return qp1.zero_point == qp2.zero_point && qp1.scale == qp2.scale;
}
# 151 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h"
struct PerChannelQuantizationParams {


  const float* scale;
  const int32_t* zero_point;
  int32_t quantized_dimension;
};


inline bool NextIndex(const int num_dims, const int* dims, int* current) {
  if (num_dims == 0) {
    return false;
  }
  (dims != nullptr) ? (void)0 : abort();
  (current != nullptr) ? (void)0 : abort();
  int carry = 1;
  for (int idx = num_dims - 1; idx >= 0; --idx) {
    int current_val = current[idx] + carry;
    ((dims[idx]) >= (current_val)) ? (void)0 : abort();
    if (dims[idx] == current_val) {
      current[idx] = 0;
    } else {
      current[idx] = current_val;
      carry = 0;
      break;
    }
  }
  return (carry == 0);
}







inline size_t ReducedOutputOffset(const int num_dims, const int* dims,
                                  const int* index, const int num_axis,
                                  const int* axis) {
  if (num_dims == 0) {
    return 0;
  }
  (dims != nullptr) ? (void)0 : abort();
  (index != nullptr) ? (void)0 : abort();
  size_t offset = 0;
  for (int idx = 0; idx < num_dims; ++idx) {

    bool is_axis = false;
    if (axis != nullptr) {
      for (int axis_idx = 0; axis_idx < num_axis; ++axis_idx) {
        if (idx == axis[axis_idx]) {
          is_axis = true;
          break;
        }
      }
    }
    if (!is_axis) {
      offset = offset * static_cast<size_t>(dims[idx]) +
               static_cast<size_t>(index[idx]);
    }
  }
  return offset;
}






inline int Offset(const Dims<4>& dims, int i0, int i1, int i2, int i3) {
  ((i0 == 0 && dims.sizes[0] == 0) || (i0 >= 0 && i0 < dims.sizes[0])) ? (void)0 : abort();

  ((i1 == 0 && dims.sizes[1] == 0) || (i1 >= 0 && i1 < dims.sizes[1])) ? (void)0 : abort();

  ((i2 == 0 && dims.sizes[2] == 0) || (i2 >= 0 && i2 < dims.sizes[2])) ? (void)0 : abort();

  ((i3 == 0 && dims.sizes[3] == 0) || (i3 >= 0 && i3 < dims.sizes[3])) ? (void)0 : abort();

  return i0 * dims.strides[0] + i1 * dims.strides[1] + i2 * dims.strides[2] +
         i3 * dims.strides[3];
}

inline int Offset(const Dims<4>& dims, int* index) {
  return Offset(dims, index[0], index[1], index[2], index[3]);
}





template <int N>
int ArraySize(const Dims<N>& array, int index) {
  (index >= 0 && index < N) ? (void)0 : abort();
  return array.sizes[index];
}


template <typename ArrayType1, typename ArrayType2>
int MatchingArraySize(const ArrayType1& array1, int index1,
                      const ArrayType2& array2, int index2) {
  ((ArraySize(array1, index1)) == (ArraySize(array2, index2))) ? (void)0 : abort();
  return ArraySize(array1, index1);
}

template <typename ArrayType1, typename ArrayType2, typename... Args>
int MatchingArraySize(const ArrayType1& array1, int index1,
                      const ArrayType2& array2, int index2, Args... args) {
  ((ArraySize(array1, index1)) == (ArraySize(array2, index2))) ? (void)0 : abort();
  return MatchingArraySize(array1, index1, args...);
}


inline int MatchingDim(const RuntimeShape& shape1, int index1,
                       const RuntimeShape& shape2, int index2) {
  ((shape1.Dims(index1)) == (shape2.Dims(index2))) ? (void)0 : abort();
  return std::min(shape1.Dims(index1), shape2.Dims(index2));
}

template <typename... Args>
int MatchingDim(const RuntimeShape& shape1, int index1,
                const RuntimeShape& shape2, int index2, Args... args) {
  ((shape1.Dims(index1)) == (shape2.Dims(index2))) ? (void)0 : abort();
  return MatchingDim(shape1, index1, args...);
}


template <int N>
inline int FlatSize(const Dims<N>& dims) {
  int flat_size = 1;
  for (int i = 0; i < N; ++i) {
    flat_size *= dims.sizes[i];
  }
  return flat_size;
}

__attribute__((deprecated("Prefer FlatSize.")))
inline int RequiredBufferSizeForDims(const Dims<4>& dims) {
  return FlatSize(dims);
}

inline int MatchingElementsSize(const RuntimeShape& shape,
                                const RuntimeShape& check_shape_0) {
  const int size_1 = shape.FlatSize();
  const int size_2 = check_shape_0.FlatSize();
  ((size_1) == (size_2)) ? (void)0 : abort();
  return size_1;
}

inline int MatchingElementsSize(const RuntimeShape& shape,
                                const RuntimeShape& check_shape_0,
                                const RuntimeShape& check_shape_1) {
  const int size_1 = shape.FlatSize();
  const int size_2 = check_shape_0.FlatSize();
  const int size_3 = check_shape_1.FlatSize();
  ((size_1) == (size_2)) ? (void)0 : abort();
  ((size_2) == (size_3)) ? (void)0 : abort();
  return size_1;
}



inline int MatchingFlatSize(const RuntimeShape& shape,
                            const RuntimeShape& check_shape_0) {
  ((shape.DimensionsCount()) == (check_shape_0.DimensionsCount())) ? (void)0 : abort();
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
  }
  return shape.FlatSize();
}

inline int MatchingFlatSize(const RuntimeShape& shape,
                            const RuntimeShape& check_shape_0,
                            const RuntimeShape& check_shape_1) {
  ((shape.DimensionsCount()) == (check_shape_0.DimensionsCount())) ? (void)0 : abort();
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(shape, check_shape_1);
}

inline int MatchingFlatSize(const RuntimeShape& shape,
                            const RuntimeShape& check_shape_0,
                            const RuntimeShape& check_shape_1,
                            const RuntimeShape& check_shape_2) {
  ((shape.DimensionsCount()) == (check_shape_0.DimensionsCount())) ? (void)0 : abort();
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(shape, check_shape_1, check_shape_2);
}

inline int MatchingFlatSize(const RuntimeShape& shape,
                            const RuntimeShape& check_shape_0,
                            const RuntimeShape& check_shape_1,
                            const RuntimeShape& check_shape_2,
                            const RuntimeShape& check_shape_3) {
  ((shape.DimensionsCount()) == (check_shape_0.DimensionsCount())) ? (void)0 : abort();
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(shape, check_shape_1, check_shape_2, check_shape_3);
}



template <int N>
inline int MatchingFlatSize(const Dims<N>& dims, const Dims<N>& check_dims_0) {
  for (int i = 0; i < N; ++i) {
    ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
  }
  return FlatSize(dims);
}

template <int N>
inline int MatchingFlatSize(const Dims<N>& dims, const Dims<N>& check_dims_0,
                            const Dims<N>& check_dims_1) {
  for (int i = 0; i < N; ++i) {
    ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(dims, check_dims_1);
}

template <int N>
inline int MatchingFlatSize(const Dims<N>& dims, const Dims<N>& check_dims_0,
                            const Dims<N>& check_dims_1,
                            const Dims<N>& check_dims_2) {
  for (int i = 0; i < N; ++i) {
    ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(dims, check_dims_1, check_dims_2);
}

template <int N>
inline int MatchingFlatSize(const Dims<N>& dims, const Dims<N>& check_dims_0,
                            const Dims<N>& check_dims_1,
                            const Dims<N>& check_dims_2,
                            const Dims<N>& check_dims_3) {
  for (int i = 0; i < N; ++i) {
    ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
  }
  return MatchingFlatSize(dims, check_dims_1, check_dims_2, check_dims_3);
}


inline int MatchingExtendedShapeFlatSize(const RuntimeShape& shape,
                                         const RuntimeShape& check_shape_0) {
  const int shape_dims = shape.DimensionsCount();
  const int check_shape_0_dims = check_shape_0.DimensionsCount();
  const int min_dims = std::min(shape_dims, check_shape_0_dims);

  for (int i = 0; i < min_dims; ++i) {
    ((shape.Dims(shape_dims - 1 - i)) == (check_shape_0.Dims(check_shape_0_dims - 1 - i))) ? (void)0 : abort();

  }
  for (int i = min_dims; i < shape_dims; ++i) {
    ((shape.Dims(shape_dims - 1 - i)) == (1)) ? (void)0 : abort();
  }
  for (int i = min_dims; i < check_shape_0_dims; ++i) {
    ((check_shape_0.Dims(check_shape_0_dims - 1 - i)) == (1)) ? (void)0 : abort();
  }
  return shape.FlatSize();
}

inline int MatchingExtendedShapeFlatSize(const RuntimeShape& shape,
                                         const RuntimeShape& check_shape_0,
                                         const RuntimeShape& check_shape_1) {
  const int flat_size = MatchingExtendedShapeFlatSize(shape, check_shape_0);
  ((MatchingExtendedShapeFlatSize(shape, check_shape_1)) == (flat_size)) ? (void)0 : abort();

  return flat_size;
}

inline int MatchingExtendedShapeFlatSize(const RuntimeShape& shape,
                                         const RuntimeShape& check_shape_0,
                                         const RuntimeShape& check_shape_1,
                                         const RuntimeShape& check_shape_2) {
  const int flat_size = MatchingExtendedShapeFlatSize(shape, check_shape_0);
  ((MatchingExtendedShapeFlatSize(shape, check_shape_1, check_shape_2)) == (flat_size)) ? (void)0 : abort();


  return flat_size;
}

inline int MatchingExtendedShapeFlatSize(const RuntimeShape& shape,
                                         const RuntimeShape& check_shape_0,
                                         const RuntimeShape& check_shape_1,
                                         const RuntimeShape& check_shape_2,
                                         const RuntimeShape& check_shape_3) {
  const int flat_size = MatchingExtendedShapeFlatSize(shape, check_shape_0);
  ((MatchingExtendedShapeFlatSize(shape, check_shape_1, check_shape_2, check_shape_3)) == (flat_size)) ? (void)0 : abort();


  return flat_size;
}




template <int N>
inline int FlatSizeSkipDim(const Dims<N>& dims, int skip_dim) {
  (skip_dim >= 0 && skip_dim < N) ? (void)0 : abort();
  int flat_size = 1;
  for (int i = 0; i < N; ++i) {
    flat_size *= (i == skip_dim) ? 1 : dims.sizes[i];
  }
  return flat_size;
}


template <int N>
inline int MatchingFlatSizeSkipDim(const Dims<N>& dims, int skip_dim,
                                   const Dims<N>& check_dims_0) {
  for (int i = 0; i < N; ++i) {
    if (i != skip_dim) {
      ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
    }
  }
  return FlatSizeSkipDim(dims, skip_dim);
}

template <int N>
inline int MatchingFlatSizeSkipDim(const Dims<N>& dims, int skip_dim,
                                   const Dims<N>& check_dims_0,
                                   const Dims<N>& check_dims_1) {
  for (int i = 0; i < N; ++i) {
    if (i != skip_dim) {
      ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(dims, skip_dim, check_dims_1);
}

template <int N>
inline int MatchingFlatSizeSkipDim(const Dims<N>& dims, int skip_dim,
                                   const Dims<N>& check_dims_0,
                                   const Dims<N>& check_dims_1,
                                   const Dims<N>& check_dims_2) {
  for (int i = 0; i < N; ++i) {
    if (i != skip_dim) {
      ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(dims, skip_dim, check_dims_1, check_dims_2);
}

template <int N>
inline int MatchingFlatSizeSkipDim(const Dims<N>& dims, int skip_dim,
                                   const Dims<N>& check_dims_0,
                                   const Dims<N>& check_dims_1,
                                   const Dims<N>& check_dims_2,
                                   const Dims<N>& check_dims_3) {
  for (int i = 0; i < N; ++i) {
    if (i != skip_dim) {
      ((ArraySize(dims, i)) == (ArraySize(check_dims_0, i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(dims, skip_dim, check_dims_1, check_dims_2,
                                 check_dims_3);
}




inline int FlatSizeSkipDim(const RuntimeShape& shape, int skip_dim) {
  const int dims_count = shape.DimensionsCount();
  (skip_dim >= 0 && skip_dim < dims_count) ? (void)0 : abort();
  const auto* dims_data = shape.DimsData();
  int flat_size = 1;
  for (int i = 0; i < dims_count; ++i) {
    flat_size *= (i == skip_dim) ? 1 : dims_data[i];
  }
  return flat_size;
}


inline int MatchingFlatSizeSkipDim(const RuntimeShape& shape, int skip_dim,
                                   const RuntimeShape& check_shape_0) {
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    if (i != skip_dim) {
      ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
    }
  }
  return FlatSizeSkipDim(shape, skip_dim);
}

inline int MatchingFlatSizeSkipDim(const RuntimeShape& shape, int skip_dim,
                                   const RuntimeShape& check_shape_0,
                                   const RuntimeShape& check_shape_1) {
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    if (i != skip_dim) {
      ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(shape, skip_dim, check_shape_1);
}

inline int MatchingFlatSizeSkipDim(const RuntimeShape& shape, int skip_dim,
                                   const RuntimeShape& check_shape_0,
                                   const RuntimeShape& check_shape_1,
                                   const RuntimeShape& check_shape_2) {
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    if (i != skip_dim) {
      ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(shape, skip_dim, check_shape_1, check_shape_2);
}

inline int MatchingFlatSizeSkipDim(const RuntimeShape& shape, int skip_dim,
                                   const RuntimeShape& check_shape_0,
                                   const RuntimeShape& check_shape_1,
                                   const RuntimeShape& check_shape_2,
                                   const RuntimeShape& check_shape_3) {
  const int dims_count = shape.DimensionsCount();
  for (int i = 0; i < dims_count; ++i) {
    if (i != skip_dim) {
      ((shape.Dims(i)) == (check_shape_0.Dims(i))) ? (void)0 : abort();
    }
  }
  return MatchingFlatSizeSkipDim(shape, skip_dim, check_shape_1, check_shape_2,
                                 check_shape_3);
}

template <int N>
bool IsPackedWithoutStrides(const Dims<N>& dims) {
  int expected_stride = 1;
  for (int d = 0; d < N; d++) {
    if (dims.strides[d] != expected_stride) return false;
    expected_stride *= dims.sizes[d];
  }
  return true;
}

template <int N>
void ComputeStrides(Dims<N>* dims) {
  dims->strides[0] = 1;
  for (int d = 1; d < N; d++) {
    dims->strides[d] = dims->strides[d - 1] * dims->sizes[d - 1];
  }
}

enum class BroadcastableOpCategory : uint8_t {
  kNone,
  kNonBroadcast,
  kFirstInputBroadcastsFast,
  kSecondInputBroadcastsFast,
  kGenericBroadcast,
};

struct MinMax {
  float min;
  float max;
};
static_assert(sizeof(MinMax) == 8, "");

struct ActivationParams {
  FusedActivationFunctionType activation_type;

  int32_t quantized_activation_min;
  int32_t quantized_activation_max;
};

struct ReluParams : public ActivationParams {
  int32_t input_offset;
  int32_t output_offset;
  int32_t output_multiplier;
  int output_shift;
};



enum class ResizingCategory : uint8_t {
  kNone,
  kImageStyle,
  kGenericResize,
};


struct ArithmeticParams {

  BroadcastableOpCategory broadcast_category;

  int32_t input1_offset;
  int32_t input2_offset;
  int32_t output_offset;
  int32_t output_multiplier;
  int output_shift;

  int left_shift;
  int32_t input1_multiplier;
  int input1_shift;
  int32_t input2_multiplier;
  int input2_shift;



  int32_t quantized_activation_min;
  int32_t quantized_activation_max;

  float float_activation_min;
  float float_activation_max;

  int64_t int64_activation_min;
  int64_t int64_activation_max;
# 672 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/types.h"
  int broadcast_shape[5];
};

struct ConcatenationParams {
  int8_t axis;
  const int32_t* input_zeropoint;
  const float* input_scale;
  uint16_t inputs_count;
  int32_t output_zeropoint;
  float output_scale;
};

struct ComparisonParams {

  int left_shift;
  int32_t input1_offset;
  int32_t input1_multiplier;
  int input1_shift;
  int32_t input2_offset;
  int32_t input2_multiplier;
  int input2_shift;

  bool is_broadcast;
};

struct ConvParams {
  PaddingType padding_type;
  PaddingValues padding_values;

  int16_t stride_width;
  int16_t stride_height;
  int16_t dilation_width_factor;
  int16_t dilation_height_factor;


  int32_t input_offset;
  int32_t weights_offset;
  int32_t output_offset;
  int32_t output_multiplier;
  int output_shift;

  int32_t quantized_activation_min;
  int32_t quantized_activation_max;

  float float_activation_min;
  float float_activation_max;
};

struct Conv3DParams {
  Padding3DValues padding_values;
  int stride_width;
  int stride_height;
  int stride_depth;
  int dilation_width;
  int dilation_height;
  int dilation_depth;

  float float_activation_min;
  float float_activation_max;
};

typedef Conv3DParams Conv3DTransposeParams;

struct DepthToSpaceParams {
  int32_t block_size;
};

struct DepthwiseParams {
  PaddingType padding_type;
  PaddingValues padding_values;
  int16_t stride_width;
  int16_t stride_height;
  int16_t dilation_width_factor;
  int16_t dilation_height_factor;
  int16_t depth_multiplier;


  int32_t input_offset;
  int32_t weights_offset;
  int32_t output_offset;
  int32_t output_multiplier;
  int output_shift;

  int32_t quantized_activation_min;
  int32_t quantized_activation_max;

  float float_activation_min;
  float float_activation_max;
  const int32_t* output_multiplier_per_channel;
  const int32_t* output_shift_per_channel;
};

struct DequantizationParams {
  double scale;
  int32_t zero_point;
};

struct PerChannelDequantizationParams {
  const float* scale;
  const int32_t* zero_point;
  int32_t quantized_dimension;
};

struct FakeQuantParams {
  MinMax minmax;
  int32_t num_bits;
};

struct FullyConnectedParams {


  int32_t input_offset;
  int32_t weights_offset;
  int32_t output_offset;
  int32_t output_multiplier;
  int output_shift;

  int32_t quantized_activation_min;
  int32_t quantized_activation_max;

  float float_activation_min;
  float float_activation_max;

  bool lhs_cacheable;
  bool rhs_cacheable;
  FullyConnectedWeightsFormat weights_format;
};

struct GatherParams {
  int16_t axis;
  int16_t batch_dims;
};

struct L2NormalizationParams {

  int32_t input_zero_point;
};

struct LocalResponseNormalizationParams {
  int32_t range;
  double bias;
  double alpha;
  double beta;
};

struct HardSwishParams {

  int16_t input_zero_point;

  int16_t output_zero_point;




  int16_t reluish_multiplier_fixedpoint_int16;

  int reluish_multiplier_exponent;




  int16_t output_multiplier_fixedpoint_int16;

  int output_multiplier_exponent;
};

struct LogisticParams {

  int32_t input_zero_point;
  int32_t input_range_radius;
  int32_t input_multiplier;
  int input_left_shift;
};

struct LstmCellParams {
  int32_t weights_zero_point;
  int32_t accum_multiplier;
  int accum_shift;
  int state_integer_bits;
};

struct MeanParams {
  int8_t axis_count;
  int16_t axis[4];
};

struct PackParams {
  int8_t axis;
  const int32_t* input_zeropoint;
  const float* input_scale;
  uint16_t inputs_count;
  int32_t output_zeropoint;
  float output_scale;
};

struct PadParams {
  int8_t left_padding_count;
  int32_t left_padding[5];
  int8_t right_padding_count;
  int32_t right_padding[5];
  ResizingCategory resizing_category;
};

struct PreluParams {
  int32_t input_offset;
  int32_t alpha_offset;
  int32_t output_offset;
  int32_t output_multiplier_1;
  int output_shift_1;
  int32_t output_multiplier_2;
  int output_shift_2;
};

struct PoolParams {
  FusedActivationFunctionType activation;
  PaddingType padding_type;
  PaddingValues padding_values;
  int stride_height;
  int stride_width;
  int filter_height;
  int filter_width;

  int32_t quantized_activation_min;
  int32_t quantized_activation_max;

  float float_activation_min;
  float float_activation_max;
};

struct ReshapeParams {
  int8_t shape_count;
  int32_t shape[4];
};

struct ResizeBilinearParams {
  bool align_corners;



  bool half_pixel_centers;
};

struct ResizeNearestNeighborParams {
  bool align_corners;
  bool half_pixel_centers;
};

struct SliceParams {
  int8_t begin_count;
  int32_t begin[5];
  int8_t size_count;
  int32_t size[5];
};

struct SoftmaxParams {


  double beta;

  int32_t input_multiplier;
  int32_t input_left_shift;

  int32_t reverse_scaling_divisor;
  int32_t reverse_scaling_right_shift;
  int diff_min;
  int32_t zero_point;
  float scale;
  float* table;

  int16_t* exp_lut;

  int16_t* one_over_one_plus_x_lut;
  uint8_t* uint8_table1;
  uint8_t* uint8_table2;
};

struct SpaceToBatchParams {

  int32_t output_offset;
};

struct SpaceToDepthParams {
  int32_t block_size;
};

struct SplitParams {


  uint16_t num_split;
  int16_t axis;
};

struct SqueezeParams {
  int8_t squeeze_dims_count;
  int32_t squeeze_dims[4];
};

struct StridedSliceParams {
  int8_t start_indices_count;
  int32_t start_indices[5];
  int8_t stop_indices_count;
  int32_t stop_indices[5];
  int8_t strides_count;
  int32_t strides[5];

  int16_t begin_mask;
  int16_t ellipsis_mask;
  int16_t end_mask;
  int16_t new_axis_mask;
  int16_t shrink_axis_mask;
};

struct TanhParams {
  int32_t input_zero_point;
  int32_t input_range_radius;
  int32_t input_multiplier;
  int input_left_shift;
};

struct TransposeParams {
  int8_t perm_count;
  int32_t perm[5];
};

struct UnpackParams {
  uint16_t num_split;
  int16_t axis;
};

struct LeakyReluParams {
  float alpha;
  int32_t input_offset;
  int32_t output_offset;
  int32_t output_multiplier_alpha;
  int32_t output_shift_alpha;
  int32_t output_multiplier_identity;
  int32_t output_shift_identity;
};

template <typename P>
inline void SetActivationParams(float min, float max, P* params) {
  params->float_activation_min = min;
  params->float_activation_max = max;
}

template <typename P>
inline void SetActivationParams(int32_t min, int32_t max, P* params) {
  params->quantized_activation_min = min;
  params->quantized_activation_max = max;
}

template <typename P>
inline void SetActivationParams(int64_t min, int64_t max, P* params) {
  params->int64_activation_min = min;
  params->int64_activation_max = max;
}

template <typename P>
inline void GetActivationParams(const P& params, int32_t* min, int32_t* max) {
  *min = params.quantized_activation_min;
  *max = params.quantized_activation_max;
}

template <typename P>
inline void GetActivationParams(const P& params, float* min, float* max) {
  *min = params.float_activation_min;
  *max = params.float_activation_max;
}

template <typename P>
inline void GetActivationParams(const P& params, int64_t* min, int64_t* max) {
  *min = params.int64_activation_min;
  *max = params.int64_activation_max;
}


template <typename T>
struct is_small_integer
    : public std::integral_constant<bool,
                                    std::is_same<T, int8_t>::value ||
                                        std::is_same<T, uint8_t>::value ||
                                        std::is_same<T, int16_t>::value ||
                                        std::is_same<T, uint16_t>::value> {};


template <typename T>
struct is_int32_or_int64
    : public std::integral_constant<bool, std::is_same<T, int32_t>::value ||
                                              std::is_same<T, int64_t>::value> {
};

}
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/conv.h" 2

namespace tflite {

struct OpDataConv {
  TfLitePaddingValues padding;


  int32_t input_zero_point;
  int32_t filter_zero_point;
  int32_t output_zero_point;



  int32_t output_multiplier;
  int output_shift;


  int32_t* per_channel_output_multiplier;
  int32_t* per_channel_output_shift;



  int32_t output_activation_min;
  int32_t output_activation_max;
};

extern const int kConvInputTensor;
extern const int kConvWeightsTensor;
extern const int kConvBiasTensor;
extern const int kConvOutputTensor;
extern const int kConvQuantizedDimension;



ConvParams ConvParamsFloat(const TfLiteConvParams& params,
                           const OpDataConv& data);



ConvParams ConvParamsQuantized(const TfLiteConvParams& params,
                               const OpDataConv& data);

TfLiteStatus CalculateOpDataConv(TfLiteContext* context, TfLiteNode* node,
                                 const TfLiteConvParams& params, int width,
                                 int height, int filter_width,
                                 int filter_height, int out_width,
                                 int out_height, const TfLiteType data_type,
                                 OpDataConv* data);

TfLiteStatus ConvPrepare(TfLiteContext* context, TfLiteNode* node);




TfLiteRegistration Register_CONV_2D();






inline TfLiteRegistration Register_CONV_2D_INT8REF() {
  return Register_CONV_2D();
}


}
# 28 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/ethosu.h" 1
# 20 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/ethosu.h"
namespace tflite {

TfLiteRegistration* Register_ETHOSU();

const char* GetString_ETHOSU();

}
# 29 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/fully_connected.h" 1
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/fully_connected.h"
namespace tflite {

struct OpDataFullyConnected {


  int32_t output_multiplier;
  int output_shift;


  int32_t output_activation_min;
  int32_t output_activation_max;

  int input_quantized_index;

  int32_t input_zero_point;
  int32_t filter_zero_point;
  int32_t output_zero_point;
};

extern const int kFullyConnectedInputTensor;
extern const int kFullyConnectedWeightsTensor;
extern const int kFullyConnectedBiasTensor;
extern const int kFullyConnectedOutputTensor;



FullyConnectedParams FullyConnectedParamsFloat(
    TfLiteFusedActivation activation);



FullyConnectedParams FullyConnectedParamsQuantized(
    const OpDataFullyConnected& op_data);

TfLiteStatus CalculateOpDataFullyConnected(
    TfLiteContext* context, TfLiteFusedActivation activation,
    TfLiteType data_type, const TfLiteTensor* input, const TfLiteTensor* filter,
    const TfLiteTensor* bias, TfLiteTensor* output, OpDataFullyConnected* data);




TfLiteRegistration Register_FULLY_CONNECTED();
# 79 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/fully_connected.h"
inline TfLiteRegistration Register_FULLY_CONNECTED_INT8() {
  return Register_FULLY_CONNECTED();
}


}
# 30 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/micro_ops.h" 1
# 28 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/micro_ops.h"
namespace tflite {





TfLiteRegistration Register_ADD();
TfLiteRegistration Register_ADD_N();
TfLiteRegistration Register_ASSIGN_VARIABLE();
TfLiteRegistration Register_AVERAGE_POOL_2D();
TfLiteRegistration Register_BATCH_TO_SPACE_ND();
TfLiteRegistration Register_CALL_ONCE();
TfLiteRegistration Register_CAST();

TfLiteRegistration* Register_CIRCULAR_BUFFER();
TfLiteRegistration Register_CUMSUM();
TfLiteRegistration Register_DEPTH_TO_SPACE();
TfLiteRegistration Register_DEPTHWISE_CONV_2D();
TfLiteRegistration Register_DEQUANTIZE();
TfLiteRegistration Register_DIV();
TfLiteRegistration Register_ELU();
TfLiteRegistration Register_EXP();
TfLiteRegistration Register_EXPAND_DIMS();
TfLiteRegistration Register_FILL();
TfLiteRegistration Register_FLOOR_DIV();
TfLiteRegistration Register_FLOOR_MOD();
TfLiteRegistration Register_GATHER();
TfLiteRegistration Register_GATHER_ND();
TfLiteRegistration Register_HARD_SWISH();
TfLiteRegistration Register_IF();
TfLiteRegistration Register_L2_POOL_2D();
TfLiteRegistration Register_LEAKY_RELU();
TfLiteRegistration Register_LOG_SOFTMAX();
TfLiteRegistration Register_LOGICAL_AND();
TfLiteRegistration Register_LOGICAL_OR();
TfLiteRegistration Register_LOGISTIC();
TfLiteRegistration Register_MAX_POOL_2D();
TfLiteRegistration Register_MIRROR_PAD();
TfLiteRegistration Register_PRELU();
TfLiteRegistration Register_MUL();
TfLiteRegistration Register_QUANTIZE();
TfLiteRegistration Register_READ_VARIABLE();
TfLiteRegistration Register_RELU();
TfLiteRegistration Register_RELU6();
TfLiteRegistration Register_RESIZE_BILINEAR();
TfLiteRegistration Register_SHAPE();
TfLiteRegistration Register_SLICE();
TfLiteRegistration Register_SPACE_TO_BATCH_ND();
TfLiteRegistration Register_SPACE_TO_DEPTH();
TfLiteRegistration Register_SQUEEZE();
TfLiteRegistration Register_SUB();
TfLiteRegistration Register_SVDF();
TfLiteRegistration Register_TRANSPOSE();
TfLiteRegistration Register_TRANSPOSE_CONV();
TfLiteRegistration Register_VAR_HANDLE();
TfLiteRegistration Register_ZEROS_LIKE();

namespace ops {
namespace micro {

TfLiteRegistration Register_ABS();
TfLiteRegistration Register_ARG_MAX();
TfLiteRegistration Register_ARG_MIN();
TfLiteRegistration Register_CEIL();
TfLiteRegistration Register_CONCATENATION();
TfLiteRegistration Register_COS();
TfLiteRegistration Register_EQUAL();
TfLiteRegistration Register_FLOOR();
TfLiteRegistration Register_GREATER();
TfLiteRegistration Register_GREATER_EQUAL();
TfLiteRegistration Register_LESS();
TfLiteRegistration Register_LESS_EQUAL();
TfLiteRegistration Register_LOG();
TfLiteRegistration Register_LOGICAL_NOT();
TfLiteRegistration Register_MAXIMUM();
TfLiteRegistration Register_MEAN();
TfLiteRegistration Register_MINIMUM();
TfLiteRegistration Register_NEG();
TfLiteRegistration Register_NOT_EQUAL();
TfLiteRegistration Register_PACK();
TfLiteRegistration Register_PAD();
TfLiteRegistration Register_PADV2();
TfLiteRegistration Register_REDUCE_MAX();
TfLiteRegistration Register_RESHAPE();
TfLiteRegistration Register_RESIZE_NEAREST_NEIGHBOR();
TfLiteRegistration Register_ROUND();
TfLiteRegistration Register_RSQRT();
TfLiteRegistration Register_SIN();
TfLiteRegistration Register_SPLIT();
TfLiteRegistration Register_SPLIT_V();
TfLiteRegistration Register_SQRT();
TfLiteRegistration Register_SQUARE();
TfLiteRegistration Register_STRIDED_SLICE();
TfLiteRegistration Register_UNIDIRECTIONAL_SEQUENCE_LSTM();
TfLiteRegistration Register_UNPACK();
TfLiteRegistration Register_L2_NORMALIZATION();
TfLiteRegistration Register_TANH();

}
}
}
# 31 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/softmax.h" 1
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/kernels/softmax.h"
namespace tflite {

void* SoftmaxInit(TfLiteContext* context, const char* buffer, size_t length);

TfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node);




TfLiteRegistration Register_SOFTMAX();






inline TfLiteRegistration Register_SOFTMAX_INT8_INT16() {
  return Register_SOFTMAX();
}


}
# 32 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_op_resolver.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_op_resolver.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/op_resolver.h" 1
# 26 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/op_resolver.h"
namespace tflite {




class OpResolver {
 public:

  virtual const TfLiteRegistration* FindOp(tflite::BuiltinOperator op,
                                           int version) const = 0;

  virtual const TfLiteRegistration* FindOp(const char* op,
                                           int version) const = 0;

  using TfLiteDelegatePtrVector =
      std::vector<std::unique_ptr<TfLiteDelegate, void (*)(TfLiteDelegate*)>>;




  virtual TfLiteDelegatePtrVector GetDelegates(int num_threads) const {
    return {};
  }


  using TfLiteDelegateCreator =
      std::function<std::unique_ptr<TfLiteDelegate, void (*)(TfLiteDelegate*)>(
          int )>;
  using TfLiteDelegateCreators = std::vector<TfLiteDelegateCreator>;



  virtual TfLiteDelegateCreators GetDelegateCreators() const { return {}; }

  virtual ~OpResolver() {}

 private:
# 74 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/core/api/op_resolver.h"
  virtual bool MayContainUserDefinedOps() const { return true; }

  friend class OpResolverInternal;
};




TfLiteStatus GetRegistrationFromOpCode(const OperatorCode* opcode,
                                       const OpResolver& op_resolver,
                                       ErrorReporter* error_reporter,
                                       const TfLiteRegistration** registration);

}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_op_resolver.h" 2


namespace tflite {
# 35 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_op_resolver.h"
class MicroOpResolver : public OpResolver {
 public:
  typedef TfLiteStatus (*BuiltinParseFunction)(const Operator* op,
                                               ErrorReporter* error_reporter,
                                               BuiltinDataAllocator* allocator,
                                               void** builtin_data);




  virtual const TfLiteRegistration* FindOp(BuiltinOperator op) const = 0;



  virtual const TfLiteRegistration* FindOp(const char* op) const = 0;



  const TfLiteRegistration* FindOp(BuiltinOperator op,
                                   int version) const final {
    return FindOp(op);
  }



  const TfLiteRegistration* FindOp(const char* op, int version) const final {
    return FindOp(op);
  }



  virtual BuiltinParseFunction GetOpDataParser(BuiltinOperator op) const = 0;

  ~MicroOpResolver() override {}
};

}
# 33 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_mutable_op_resolver.h" 2


namespace tflite {
TfLiteRegistration* Register_DETECTION_POSTPROCESS();

template <unsigned int tOpCount>
class MicroMutableOpResolver : public MicroOpResolver {
 public:
  void operator delete(void* p) {}

  explicit MicroMutableOpResolver(ErrorReporter* error_reporter = nullptr)
      : error_reporter_(error_reporter) {}

  const TfLiteRegistration* FindOp(tflite::BuiltinOperator op) const override {
    if (op == BuiltinOperator_CUSTOM) return nullptr;

    for (unsigned int i = 0; i < registrations_len_; ++i) {
      const TfLiteRegistration& registration = registrations_[i];
      if (registration.builtin_code == op) {
        return &registration;
      }
    }
    return nullptr;
  }

  const TfLiteRegistration* FindOp(const char* op) const override {
    for (unsigned int i = 0; i < registrations_len_; ++i) {
      const TfLiteRegistration& registration = registrations_[i];
      if ((registration.builtin_code == BuiltinOperator_CUSTOM) &&
          (strcmp(registration.custom_name, op) == 0)) {
        return &registration;
      }
    }
    return nullptr;
  }

  MicroOpResolver::BuiltinParseFunction GetOpDataParser(
      BuiltinOperator op) const override {
    (num_buitin_ops_ <= tOpCount) ? (void)0 : abort();
    for (unsigned int i = 0; i < num_buitin_ops_; ++i) {
      if (builtin_codes_[i] == op) return builtin_parsers_[i];
    }
    return nullptr;
  }







  TfLiteStatus AddCustom(const char* name, TfLiteRegistration* registration) {
    if (registrations_len_ >= tOpCount) {
      if (error_reporter_) {
        do { static_cast<tflite::ErrorReporter*>(error_reporter_)->Report("Couldn't register custom op '%s', resolver size is too small (%d)", name, tOpCount); } while (false);



      }
      return kTfLiteError;
    }

    if (FindOp(name) != nullptr) {
      if (error_reporter_ != nullptr) {
        do { static_cast<tflite::ErrorReporter*>(error_reporter_)->Report("Calling AddCustom for the same op more than once " "is not supported (Op: %s).", name); } while (false);



      }
      return kTfLiteError;
    }

    TfLiteRegistration* new_registration = &registrations_[registrations_len_];
    registrations_len_ += 1;

    *new_registration = *registration;
    new_registration->builtin_code = BuiltinOperator_CUSTOM;
    new_registration->custom_name = name;
    return kTfLiteOk;
  }




  TfLiteStatus AddAbs() {
    return AddBuiltin(BuiltinOperator_ABS, tflite::ops::micro::Register_ABS(),
                      ParseAbs);
  }

  TfLiteStatus AddAdd() {
    return AddBuiltin(BuiltinOperator_ADD, tflite::Register_ADD(), ParseAdd);
  }

  TfLiteStatus AddAddN() {
    return AddBuiltin(BuiltinOperator_ADD_N, tflite::Register_ADD_N(),
                      ParseAddN);
  }

  TfLiteStatus AddArgMax() {
    return AddBuiltin(BuiltinOperator_ARG_MAX,
                      tflite::ops::micro::Register_ARG_MAX(), ParseArgMax);
  }

  TfLiteStatus AddArgMin() {
    return AddBuiltin(BuiltinOperator_ARG_MIN,
                      tflite::ops::micro::Register_ARG_MIN(), ParseArgMin);
  }

  TfLiteStatus AddAssignVariable() {
    return AddBuiltin(BuiltinOperator_ASSIGN_VARIABLE,
                      tflite::Register_ASSIGN_VARIABLE(), ParseAssignVariable);
  }

  TfLiteStatus AddAveragePool2D() {
    return AddBuiltin(BuiltinOperator_AVERAGE_POOL_2D,
                      tflite::Register_AVERAGE_POOL_2D(), ParsePool);
  }

  TfLiteStatus AddBatchToSpaceNd() {
    return AddBuiltin(BuiltinOperator_BATCH_TO_SPACE_ND,
                      Register_BATCH_TO_SPACE_ND(), ParseBatchToSpaceNd);
  }

  TfLiteStatus AddCallOnce() {
    return AddBuiltin(BuiltinOperator_CALL_ONCE, Register_CALL_ONCE(),
                      ParseCallOnce);
  }

  TfLiteStatus AddCast() {
    return AddBuiltin(BuiltinOperator_CAST, Register_CAST(), ParseCast);
  }

  TfLiteStatus AddCeil() {
    return AddBuiltin(BuiltinOperator_CEIL, tflite::ops::micro::Register_CEIL(),
                      ParseCeil);
  }

  TfLiteStatus AddCircularBuffer() {
    return AddCustom("CIRCULAR_BUFFER", tflite::Register_CIRCULAR_BUFFER());
  }

  TfLiteStatus AddConcatenation() {
    return AddBuiltin(BuiltinOperator_CONCATENATION,
                      tflite::ops::micro::Register_CONCATENATION(),
                      ParseConcatenation);
  }

  TfLiteStatus AddConv2D(
      const TfLiteRegistration& registration = Register_CONV_2D()) {
    return AddBuiltin(BuiltinOperator_CONV_2D, registration, ParseConv2D);
  }

  TfLiteStatus AddCos() {
    return AddBuiltin(BuiltinOperator_COS, tflite::ops::micro::Register_COS(),
                      ParseCos);
  }

  TfLiteStatus AddCumSum() {
    return AddBuiltin(BuiltinOperator_CUMSUM, tflite::Register_CUMSUM(),
                      ParseCumsum);
  }

  TfLiteStatus AddDepthToSpace() {
    return AddBuiltin(BuiltinOperator_DEPTH_TO_SPACE,
                      tflite::Register_DEPTH_TO_SPACE(), ParseDepthToSpace);
  }

  TfLiteStatus AddDepthwiseConv2D() {
    return AddBuiltin(BuiltinOperator_DEPTHWISE_CONV_2D,
                      Register_DEPTHWISE_CONV_2D(), ParseDepthwiseConv2D);
  }

  TfLiteStatus AddDequantize() {
    return AddBuiltin(BuiltinOperator_DEQUANTIZE, tflite::Register_DEQUANTIZE(),
                      ParseDequantize);
  }

  TfLiteStatus AddDetectionPostprocess() {
    return AddCustom("TFLite_Detection_PostProcess",
                     tflite::Register_DETECTION_POSTPROCESS());
  }

  TfLiteStatus AddElu() {
    return AddBuiltin(BuiltinOperator_ELU, tflite::Register_ELU(), ParseElu);
  }

  TfLiteStatus AddEqual() {
    return AddBuiltin(BuiltinOperator_EQUAL,
                      tflite::ops::micro::Register_EQUAL(), ParseEqual);
  }

  TfLiteStatus AddEthosU() {
    TfLiteRegistration* registration = tflite::Register_ETHOSU();
    if (registration) {
      return AddCustom(tflite::GetString_ETHOSU(), registration);
    }
    return kTfLiteOk;
  }

  TfLiteStatus AddExp() {
    return AddBuiltin(BuiltinOperator_EXP, Register_EXP(), ParseExp);
  }

  TfLiteStatus AddExpandDims() {
    return AddBuiltin(BuiltinOperator_EXPAND_DIMS, Register_EXPAND_DIMS(),
                      ParseExpandDims);
  }

  TfLiteStatus AddFill() {
    return AddBuiltin(BuiltinOperator_FILL, tflite::Register_FILL(), ParseFill);
  }

  TfLiteStatus AddFloor() {
    return AddBuiltin(BuiltinOperator_FLOOR,
                      tflite::ops::micro::Register_FLOOR(), ParseFloor);
  }

  TfLiteStatus AddFloorDiv() {
    return AddBuiltin(BuiltinOperator_FLOOR_DIV, tflite::Register_FLOOR_DIV(),
                      ParseFloorDiv);
  }

  TfLiteStatus AddFloorMod() {
    return AddBuiltin(BuiltinOperator_FLOOR_MOD, tflite::Register_FLOOR_MOD(),
                      ParseFloorMod);
  }

  TfLiteStatus AddFullyConnected(
      const TfLiteRegistration& registration = Register_FULLY_CONNECTED()) {
    return AddBuiltin(BuiltinOperator_FULLY_CONNECTED, registration,
                      ParseFullyConnected);
  }

  TfLiteStatus AddGather() {
    return AddBuiltin(BuiltinOperator_GATHER, tflite::Register_GATHER(),
                      ParseGather);
  }

  TfLiteStatus AddGatherNd() {
    return AddBuiltin(BuiltinOperator_GATHER_ND, tflite::Register_GATHER_ND(),
                      ParseGatherNd);
  }

  TfLiteStatus AddGreater() {
    return AddBuiltin(BuiltinOperator_GREATER,
                      tflite::ops::micro::Register_GREATER(), ParseGreater);
  }

  TfLiteStatus AddGreaterEqual() {
    return AddBuiltin(BuiltinOperator_GREATER_EQUAL,
                      tflite::ops::micro::Register_GREATER_EQUAL(),
                      ParseGreaterEqual);
  }

  TfLiteStatus AddHardSwish() {
    return AddBuiltin(BuiltinOperator_HARD_SWISH, tflite::Register_HARD_SWISH(),
                      ParseHardSwish);
  }

  TfLiteStatus AddIf() {
    return AddBuiltin(BuiltinOperator_IF, tflite::Register_IF(), ParseIf);
  }

  TfLiteStatus AddL2Normalization() {
    return AddBuiltin(BuiltinOperator_L2_NORMALIZATION,
                      tflite::ops::micro::Register_L2_NORMALIZATION(),
                      ParseL2Normalization);
  }

  TfLiteStatus AddL2Pool2D() {
    return AddBuiltin(BuiltinOperator_L2_POOL_2D, tflite::Register_L2_POOL_2D(),
                      ParsePool);
  }

  TfLiteStatus AddLeakyRelu() {
    return AddBuiltin(BuiltinOperator_LEAKY_RELU, tflite::Register_LEAKY_RELU(),
                      ParseLeakyRelu);
  }

  TfLiteStatus AddLess() {
    return AddBuiltin(BuiltinOperator_LESS, tflite::ops::micro::Register_LESS(),
                      ParseLess);
  }

  TfLiteStatus AddLessEqual() {
    return AddBuiltin(BuiltinOperator_LESS_EQUAL,
                      tflite::ops::micro::Register_LESS_EQUAL(),
                      ParseLessEqual);
  }

  TfLiteStatus AddLog() {
    return AddBuiltin(BuiltinOperator_LOG, tflite::ops::micro::Register_LOG(),
                      ParseLog);
  }

  TfLiteStatus AddLogicalAnd() {
    return AddBuiltin(BuiltinOperator_LOGICAL_AND,
                      tflite::Register_LOGICAL_AND(), ParseLogicalAnd);
  }

  TfLiteStatus AddLogicalNot() {
    return AddBuiltin(BuiltinOperator_LOGICAL_NOT,
                      tflite::ops::micro::Register_LOGICAL_NOT(),
                      ParseLogicalNot);
  }

  TfLiteStatus AddLogicalOr() {
    return AddBuiltin(BuiltinOperator_LOGICAL_OR, tflite::Register_LOGICAL_OR(),
                      ParseLogicalOr);
  }

  TfLiteStatus AddLogistic() {
    return AddBuiltin(BuiltinOperator_LOGISTIC, tflite::Register_LOGISTIC(),
                      ParseLogistic);
  }

  TfLiteStatus AddMaximum() {
    return AddBuiltin(BuiltinOperator_MAXIMUM,
                      tflite::ops::micro::Register_MAXIMUM(), ParseMaximum);
  }

  TfLiteStatus AddMaxPool2D() {
    return AddBuiltin(BuiltinOperator_MAX_POOL_2D,
                      tflite::Register_MAX_POOL_2D(), ParsePool);
  }

  TfLiteStatus AddMirrorPad() {
    return AddBuiltin(BuiltinOperator_MIRROR_PAD, tflite::Register_MIRROR_PAD(),
                      ParseMirrorPad);
  }

  TfLiteStatus AddMean() {
    return AddBuiltin(BuiltinOperator_MEAN, tflite::ops::micro::Register_MEAN(),
                      ParseReducer);
  }

  TfLiteStatus AddMinimum() {
    return AddBuiltin(BuiltinOperator_MINIMUM,
                      tflite::ops::micro::Register_MINIMUM(), ParseMinimum);
  }

  TfLiteStatus AddMul() {
    return AddBuiltin(BuiltinOperator_MUL, tflite::Register_MUL(), ParseMul);
  }

  TfLiteStatus AddNeg() {
    return AddBuiltin(BuiltinOperator_NEG, tflite::ops::micro::Register_NEG(),
                      ParseNeg);
  }

  TfLiteStatus AddNotEqual() {
    return AddBuiltin(BuiltinOperator_NOT_EQUAL,
                      tflite::ops::micro::Register_NOT_EQUAL(), ParseNotEqual);
  }

  TfLiteStatus AddPack() {
    return AddBuiltin(BuiltinOperator_PACK, tflite::ops::micro::Register_PACK(),
                      ParsePack);
  }

  TfLiteStatus AddPad() {
    return AddBuiltin(BuiltinOperator_PAD, tflite::ops::micro::Register_PAD(),
                      ParsePad);
  }

  TfLiteStatus AddPadV2() {
    return AddBuiltin(BuiltinOperator_PADV2,
                      tflite::ops::micro::Register_PADV2(), ParsePadV2);
  }

  TfLiteStatus AddPrelu() {
    return AddBuiltin(BuiltinOperator_PRELU, tflite::Register_PRELU(),
                      ParsePrelu);
  }

  TfLiteStatus AddQuantize() {
    return AddBuiltin(BuiltinOperator_QUANTIZE, Register_QUANTIZE(),
                      ParseQuantize);
  }

  TfLiteStatus AddReadVariable() {
    return AddBuiltin(BuiltinOperator_READ_VARIABLE,
                      tflite::Register_READ_VARIABLE(), ParseReadVariable);
  }

  TfLiteStatus AddReduceMax() {
    return AddBuiltin(BuiltinOperator_REDUCE_MAX,
                      tflite::ops::micro::Register_REDUCE_MAX(), ParseReducer);
  }

  TfLiteStatus AddRelu() {
    return AddBuiltin(BuiltinOperator_RELU, tflite::Register_RELU(), ParseRelu);
  }

  TfLiteStatus AddRelu6() {
    return AddBuiltin(BuiltinOperator_RELU6, tflite::Register_RELU6(),
                      ParseRelu6);
  }

  TfLiteStatus AddReshape() {
    return AddBuiltin(BuiltinOperator_RESHAPE,
                      tflite::ops::micro::Register_RESHAPE(), ParseReshape);
  }

  TfLiteStatus AddResizeBilinear() {
    return AddBuiltin(BuiltinOperator_RESIZE_BILINEAR,
                      Register_RESIZE_BILINEAR(), ParseResizeBilinear);
  }

  TfLiteStatus AddResizeNearestNeighbor() {
    return AddBuiltin(BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
                      tflite::ops::micro::Register_RESIZE_NEAREST_NEIGHBOR(),
                      ParseResizeNearestNeighbor);
  }

  TfLiteStatus AddRound() {
    return AddBuiltin(BuiltinOperator_ROUND,
                      tflite::ops::micro::Register_ROUND(), ParseRound);
  }

  TfLiteStatus AddRsqrt() {
    return AddBuiltin(BuiltinOperator_RSQRT,
                      tflite::ops::micro::Register_RSQRT(), ParseRsqrt);
  }

  TfLiteStatus AddShape() {
    return AddBuiltin(BuiltinOperator_SHAPE, Register_SHAPE(), ParseShape);
  }

  TfLiteStatus AddSin() {
    return AddBuiltin(BuiltinOperator_SIN, tflite::ops::micro::Register_SIN(),
                      ParseSin);
  }

  TfLiteStatus AddSlice() {
    return AddBuiltin(BuiltinOperator_SLICE, Register_SLICE(), ParseSlice);
  }

  TfLiteStatus AddSoftmax(
      const TfLiteRegistration& registration = Register_SOFTMAX()) {
    return AddBuiltin(BuiltinOperator_SOFTMAX, registration, ParseSoftmax);
  }

  TfLiteStatus AddSpaceToBatchNd() {
    return AddBuiltin(BuiltinOperator_SPACE_TO_BATCH_ND,
                      Register_SPACE_TO_BATCH_ND(), ParseSpaceToBatchNd);
  }

  TfLiteStatus AddSpaceToDepth() {
    return AddBuiltin(BuiltinOperator_SPACE_TO_DEPTH, Register_SPACE_TO_DEPTH(),
                      ParseSpaceToDepth);
  }

  TfLiteStatus AddSplit() {
    return AddBuiltin(BuiltinOperator_SPLIT,
                      tflite::ops::micro::Register_SPLIT(), ParseSplit);
  }

  TfLiteStatus AddSplitV() {
    return AddBuiltin(BuiltinOperator_SPLIT_V,
                      tflite::ops::micro::Register_SPLIT_V(), ParseSplitV);
  }

  TfLiteStatus AddSqueeze() {
    return AddBuiltin(BuiltinOperator_SQUEEZE, Register_SQUEEZE(),
                      ParseSqueeze);
  }

  TfLiteStatus AddSqrt() {
    return AddBuiltin(BuiltinOperator_SQRT, tflite::ops::micro::Register_SQRT(),
                      ParseSqrt);
  }

  TfLiteStatus AddSquare() {
    return AddBuiltin(BuiltinOperator_SQUARE,
                      tflite::ops::micro::Register_SQUARE(), ParseSquare);
  }

  TfLiteStatus AddStridedSlice() {
    return AddBuiltin(BuiltinOperator_STRIDED_SLICE,
                      tflite::ops::micro::Register_STRIDED_SLICE(),
                      ParseStridedSlice);
  }

  TfLiteStatus AddSub() {
    return AddBuiltin(BuiltinOperator_SUB, tflite::Register_SUB(), ParseSub);
  }

  TfLiteStatus AddSvdf(
      const TfLiteRegistration& registration = Register_SVDF()) {
    return AddBuiltin(BuiltinOperator_SVDF, registration, ParseSvdf);
  }

  TfLiteStatus AddTanh() {
    return AddBuiltin(BuiltinOperator_TANH, tflite::ops::micro::Register_TANH(),
                      ParseTanh);
  }

  TfLiteStatus AddTransposeConv() {
    return AddBuiltin(BuiltinOperator_TRANSPOSE_CONV,
                      tflite::Register_TRANSPOSE_CONV(), ParseTransposeConv);
  }

  TfLiteStatus AddTranspose() {
    return AddBuiltin(BuiltinOperator_TRANSPOSE, Register_TRANSPOSE(),
                      ParseTranspose);
  }

  TfLiteStatus AddUnpack() {
    return AddBuiltin(BuiltinOperator_UNPACK,
                      tflite::ops::micro::Register_UNPACK(), ParseUnpack);
  }

  TfLiteStatus AddUnidirectionalSequenceLSTM() {
    return AddBuiltin(
        BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
        tflite::ops::micro::Register_UNIDIRECTIONAL_SEQUENCE_LSTM(),
        ParseUnidirectionalSequenceLSTM);
  }

  TfLiteStatus AddVarHandle() {
    return AddBuiltin(BuiltinOperator_VAR_HANDLE, Register_VAR_HANDLE(),
                      ParseVarHandle);
  }

  TfLiteStatus AddZerosLike() {
    return AddBuiltin(BuiltinOperator_ZEROS_LIKE, Register_ZEROS_LIKE(),
                      ParseZerosLike);
  }

  unsigned int GetRegistrationLength() { return registrations_len_; }

 private:
  TfLiteStatus AddBuiltin(tflite::BuiltinOperator op,
                          const TfLiteRegistration& registration,
                          MicroOpResolver::BuiltinParseFunction parser) {
    if (op == BuiltinOperator_CUSTOM) {
      if (error_reporter_ != nullptr) {
        do { static_cast<tflite::ErrorReporter*>(error_reporter_)->Report("Invalid parameter BuiltinOperator_CUSTOM to the " "AddBuiltin function."); } while (false);


      }
      return kTfLiteError;
    }

    if (FindOp(op) != nullptr) {
      if (error_reporter_ != nullptr) {
        do { static_cast<tflite::ErrorReporter*>(error_reporter_)->Report("Calling AddBuiltin with the same op more than " "once is not supported (Op: #%d).", op); } while (false);



      }
      return kTfLiteError;
    }

    if (registrations_len_ >= tOpCount) {
      if (error_reporter_) {
        do { static_cast<tflite::ErrorReporter*>(error_reporter_)->Report("Couldn't register builtin op #%d, resolver size " "is too small (%d).", op, tOpCount); } while (false);



      }
      return kTfLiteError;
    }

    registrations_[registrations_len_] = registration;


    registrations_[registrations_len_].builtin_code = op;
    registrations_len_++;

    builtin_codes_[num_buitin_ops_] = op;
    builtin_parsers_[num_buitin_ops_] = parser;
    num_buitin_ops_++;

    return kTfLiteOk;
  }

  TfLiteRegistration registrations_[tOpCount];
  unsigned int registrations_len_ = 0;



  BuiltinOperator builtin_codes_[tOpCount];
  MicroOpResolver::BuiltinParseFunction builtin_parsers_[tOpCount];
  unsigned int num_buitin_ops_ = 0;

  ErrorReporter* error_reporter_;
};

};
# 32 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 1
# 25 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/tensor_ctypes.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/kernels/internal/tensor_ctypes.h"
namespace tflite {

template <typename T>
inline T* GetTensorData(TfLiteTensor* tensor) {
  return tensor != nullptr ? reinterpret_cast<T*>(tensor->data.raw) : nullptr;
}

template <typename T>
inline const T* GetTensorData(const TfLiteTensor* tensor) {
  return tensor != nullptr ? reinterpret_cast<const T*>(tensor->data.raw)
                           : nullptr;
}

inline RuntimeShape GetTensorShape(const TfLiteTensor* tensor) {
  if (tensor == nullptr) {
    return RuntimeShape();
  }

  TfLiteIntArray* dims = tensor->dims;
  const int dims_size = dims->size;
  const int32_t* dims_data = reinterpret_cast<const int32_t*>(dims->data);
  return RuntimeShape(dims_size, dims_data);
}

}
# 26 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h" 1
# 25 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/flatbuffer_utils.h" 1
# 20 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/flatbuffer_utils.h"
# 1 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h" 1
# 20 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 1 3
# 493 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3


namespace std { inline namespace __2 {

template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : _Compare() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _Compare(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Compare& key_comp() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      using std::__2::swap;
      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
    }
# 542 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : comp() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : comp(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const _Compare& key_comp() const noexcept {return comp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
        using std::__2::swap;
        swap(comp, __y.comp);
    }
# 590 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,
     __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;

private:
    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__2::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__2::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp>
struct __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_type& __get_value()
    {



        return __cc;

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const value_type& __get_value() const
    {



        return __cc;

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__2::move(const_cast<key_type&>(__v.first)),
            std::__2::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_type& operator=(const __value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_type& operator=(__value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__2::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __value_type() = delete;
    ~__value_type() = delete;
    __value_type(const __value_type& __v) = delete;
    __value_type(__value_type&& __v) = delete;
};
# 767 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator(__map_iterator<
        typename _TreeIterator::__non_const_iterator> __i) noexcept
        : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef typename __identity<_Compare>::type key_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__2::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;






    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit map(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }
# 1005 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map& operator=(const map& __m)
        {

            __tree_ = __m.__tree_;
# 1025 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map(map&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__2::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map& operator=(map&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__2::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit map(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~map() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool> emplace(_Args&& ...__args) {
        return __tree_.__emplace_unique(std::__2::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_unique(__p.__i_, std::__2::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        pair<iterator, bool> insert(_Pp&& __p)
            {return __tree_.__insert_unique(std::__2::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_unique(__pos.__i_, std::__2::forward<_Pp>(__p));}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator, bool>
    insert(value_type&& __v) {return __tree_.__insert_unique(std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
    {return __tree_.__insert_unique(__p.__i_, std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }
# 1300 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}
# 1374 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(map& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 1394 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}
# 1409 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}
# 1427 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}
# 1444 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}
# 1461 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;




};
# 1504 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::__2::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__2::piecewise_construct,
        std::__2::forward_as_tuple(__k),
        std::__2::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__2::piecewise_construct,
        std::__2::forward_as_tuple(std::__2::move(__k)),
        std::__2::forward_as_tuple()).first->__get_value().second;
}
# 1570 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __parent_pointer __parent;
    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__2::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__2::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1668 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef typename __identity<_Compare>::type key_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__2::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__2::reverse_iterator<iterator> reverse_iterator;
    typedef std::__2::reverse_iterator<const_iterator> const_reverse_iterator;





    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multimap(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }
# 1775 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap& operator=(const multimap& __m)
        {

            __tree_ = __m.__tree_;
# 1796 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap(multimap&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__2::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap& operator=(multimap&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__2::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit multimap(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~multimap() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
          reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}



    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator emplace(_Args&& ...__args) {
        return __tree_.__emplace_multi(std::__2::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_multi(__p.__i_, std::__2::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator insert(_Pp&& __p)
            {return __tree_.__insert_multi(std::__2::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_multi(__pos.__i_, std::__2::forward<_Pp>(__p));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__2::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p.__i_, std::__2::move(__v));}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
# 2037 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(multimap& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 2060 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}
# 2075 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}
# 2093 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}
# 2110 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}
# 2127 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};
# 2164 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::__2::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    std::__2::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
    }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__2::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__2::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2253 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\map" 3
} }
# 21 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h" 2



# 1 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h" 1
# 20 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\errno.h" 1 3
# 29 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\errno.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\errno.h" 1 3
# 24 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\errno.h" 3
        namespace std {

        extern "C" {





extern __attribute__((__nothrow__)) __attribute__((__const__)) volatile int *__aeabi_errno_addr(void);



         }
      }





      using ::std::__aeabi_errno_addr;
# 32 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\errno.h" 2 3
# 44 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\errno.h" 3
static const int __elast1 = 104;
static const int __elast2 = 105;
# 21 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h" 2





# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 1 3
# 184 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 1 3
# 138 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 1 3
# 216 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 1 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 1 3
# 190 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 1 3
# 14 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 1 3
# 828 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctime" 1 3
# 49 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctime" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 1 3
# 39 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
      namespace std {

          extern "C" {
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
    typedef unsigned int size_t;
# 82 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
typedef unsigned int clock_t;
typedef unsigned int time_t;






struct tm {
    int tm_sec;

    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    union {
        struct {
            int __extra_1, __extra_2;
        };
        struct {
            long __extra_1_long, __extra_2_long;
        };
        struct {
            char *__extra_1_cptr, *__extra_2_cptr;
        };
        struct {
            void *__extra_1_vptr, *__extra_2_vptr;
        };
    };
};
# 127 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
extern __attribute__((__nothrow__)) clock_t clock(void);







extern __attribute__((__nothrow__)) double difftime(time_t , time_t );




extern __attribute__((__nothrow__)) time_t mktime(struct tm * ) __attribute__((__nonnull__(1)));
# 156 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
extern __attribute__((__nothrow__)) time_t time(time_t * );
# 166 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
extern __attribute__((__nothrow__)) char *asctime(const struct tm * ) __attribute__((__nonnull__(1)));
extern __attribute__((__nothrow__)) char *_asctime_r(const struct tm * ,
                                char * __restrict ) __attribute__((__nonnull__(1,2)));
# 178 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
extern __attribute__((__nothrow__)) char *ctime(const time_t * ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) struct tm *gmtime(const time_t * ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) struct tm *localtime(const time_t * ) __attribute__((__nonnull__(1)));
extern __attribute__((__nothrow__)) struct tm *_localtime_r(const time_t * __restrict ,
                                       struct tm * __restrict ) __attribute__((__nonnull__(1,2)));
# 203 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
extern __attribute__((__nothrow__)) size_t strftime(char * __restrict , size_t ,
                       const char * __restrict ,
                       const struct tm * __restrict ) __attribute__((__nonnull__(1,3,4)));
# 253 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
         }
      }
# 264 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\time.h" 3
      using ::std::clock_t;
      using ::std::time_t;
      using ::std::tm;
      using ::std::tm;
      using ::std::clock;
      using ::std::difftime;
      using ::std::mktime;
      using ::std::time;
      using ::std::asctime;
      using ::std::_asctime_r;



      using ::std::ctime;
      using ::std::gmtime;
      using ::std::localtime;
      using ::std::_localtime_r;



      using ::std::strftime;
      using ::std::size_t;
# 50 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctime" 2 3
# 53 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctime" 3
# 69 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ctime" 3
namespace std { inline namespace __2 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;



using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;




} }
# 829 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 1 3
# 87 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 91 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 2 3


namespace std { inline namespace __2 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 317 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 344 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 379 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 416 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool,((_R1::num == _R2::num && _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool,((!ratio_equal<_R1, _R2>::value))> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool,((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool,((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool,((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool,((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};
# 528 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ratio" 3
} }
# 831 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 2 3
# 836 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 840 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 2 3


namespace std { inline namespace __2 { namespace __fs { namespace filesystem {
struct _FilesystemClock;
} } } }


namespace std { inline namespace __2 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};







template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr _Rep zero() noexcept {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr _Rep max() noexcept {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr _Rep min() noexcept {return numeric_limits<_Rep>::lowest();}
};
# 1021 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr

        duration() = default;




    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = nullptr)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = nullptr)
                : __rep_(std::__2::chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr rep count() const {return __rep_;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr duration zero() noexcept {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr duration min() noexcept {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr duration max() noexcept {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;
# 1138 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = nullptr)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) duration time_since_epoch() const {return __d_;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr time_point min() noexcept {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) static constexpr time_point max() noexcept {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__2::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
# 1468 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__ ((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};


class __attribute__ ((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static const bool is_steady = true;

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;
# 2835 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
}
# 2928 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\chrono" 3
} }


namespace std { inline namespace __2 { namespace __fs { namespace filesystem {
struct _FilesystemClock {




  typedef long long rep;
  typedef nano period;


  typedef chrono::duration<rep, period> duration;
  typedef chrono::time_point<_FilesystemClock> time_point;

  __attribute__((__visibility__("default")))
  static const bool is_steady = false;

                                  __attribute__ ((__visibility__("default"))) static time_point now() noexcept;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static time_t to_time_t(const time_point& __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_t(
          chrono::duration_cast<__secs>(__t.time_since_epoch()).count());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  static time_point from_time_t(time_t __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_point(__secs(__t));
  }
};
} } } }
# 15 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\system_error" 1 3
# 145 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\system_error" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__errc" 1 3
# 104 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__errc" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cerrno" 1 3
# 30 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\cerrno" 3
# 105 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__errc" 2 3
# 108 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__errc" 3


namespace std { inline namespace __2 {





enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 9901,
    address_in_use = 9902,
    address_not_available = 9903,
    already_connected = 9904,
    argument_list_too_long = 9946,
    argument_out_of_domain = 1,
    bad_address = 9948,
    bad_file_descriptor = 9949,
    bad_message = 9905,
    broken_pipe = 9950,
    connection_aborted = 9906,
    connection_already_in_progress = 9907,
    connection_refused = 9908,
    connection_reset = 9909,
    cross_device_link = 9951,
    destination_address_required = 9910,
    device_or_resource_busy = 9952,
    directory_not_empty = 9953,
    executable_format_error = 9954,
    file_exists = 9955,
    file_too_large = 9956,
    filename_too_long = 9957,
    function_not_supported = 9942,
    host_unreachable = 9911,
    identifier_removed = 9912,
    illegal_byte_sequence = 4,
    inappropriate_io_control_operation = 9958,
    interrupted = 9959,
    invalid_argument = 5,
    invalid_seek = 9960,
    io_error = 9961,
    is_a_directory = 9962,
    message_size = 9913,
    network_down = 9914,
    network_reset = 9915,
    network_unreachable = 9916,
    no_buffer_space = 9917,
    no_child_process = 9963,
    no_link = 9918,
    no_lock_available = 9964,

    no_message_available = 9919,



    no_message = 9920,
    no_protocol_option = 9921,
    no_space_on_device = 9965,

    no_stream_resources = 9922,



    no_such_device_or_address = 9966,
    no_such_device = 9967,
    no_such_file_or_directory = 9968,
    no_such_process = 9969,
    not_a_directory = 9970,
    not_a_socket = 9923,

    not_a_stream = 9924,



    not_connected = 9925,
    not_enough_memory = 6,
    not_supported = 9926,
    operation_canceled = 9927,
    operation_in_progress = 9928,
    operation_not_permitted = 9972,
    operation_not_supported = 9929,
    operation_would_block = 9930,
    owner_dead = __elast1,
    permission_denied = 9973,
    protocol_error = 9932,
    protocol_not_supported = 9933,
    read_only_file_system = 9974,
    resource_deadlock_would_occur = 9975,
    resource_unavailable_try_again = 9976,
    result_out_of_range = 2,
    state_not_recoverable = __elast2,

    stream_timeout = 9935,



    text_file_busy = 9936,
    timed_out = 9938,
    too_many_files_open_in_system = 9977,
    too_many_files_open = 9978,
    too_many_links = 9979,
    too_many_symbolic_link_levels = 9939,
    value_too_large = 9940,
    wrong_protocol_type = 9941
};


} }
# 146 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\system_error" 2 3
# 153 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\system_error" 3


namespace std { inline namespace __2 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};
# 170 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\system_error" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};






template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };







class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__visibility__("default"))) error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
                                  error_category() noexcept = default;

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__ ((__visibility__("default"))) const error_category& system_category() noexcept;

class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    system_error(const system_error&) noexcept = default;
    ~system_error() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);

} }
# 16 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__threading_support" 1 3
# 25 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__threading_support" 3
# 62 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__threading_support" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 63 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__threading_support" 2 3

namespace std { inline namespace __2 {
# 808 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__threading_support" 3
} }
# 17 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 2 3
# 22 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 26 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 2 3


namespace std { inline namespace __2 {
# 339 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 3
template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    _Rep __result_float = __d.count() * __ratio::num / __ratio::den;

    _Rep __result_max = numeric_limits<__ns_rep>::max();
    if (__result_float >= __result_max) {
        return nanoseconds::max();
    }

    _Rep __result_min = numeric_limits<__ns_rep>::min();
    if (__result_float <= __result_min) {
        return nanoseconds::min();
    }

    return nanoseconds(static_cast<__ns_rep>(__result_float));
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    !is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    if (__d.count() == 0) {
        return nanoseconds(0);
    }

    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    __ns_rep __result_max = numeric_limits<__ns_rep>::max();
    if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
        return nanoseconds::max();
    }

    __ns_rep __result_min = numeric_limits<__ns_rep>::min();
    if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
        return nanoseconds::min();
    }

    __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
    if (__result == 0) {
        return nanoseconds(1);
    }

    return nanoseconds(__result);
}
# 525 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__mutex_base" 3
} }
# 191 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 2 3
# 202 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 206 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 2 3


namespace std { inline namespace __2 {
# 553 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag;



template<class _Callable, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void call_once(once_flag&, _Callable&&, _Args&&...);
# 573 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr
        once_flag() noexcept : __state_(0) {}




   typedef unsigned long _State_type;



private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    _State_type __state_;


    template<class _Callable, class... _Args>
    friend
    void call_once(once_flag&, _Callable&&, _Args&&...);
# 605 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
};



template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __call_once_param(_Fp& __f) : __f_(__f) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator()()
    {
        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
        __execute(_Index());
    }

private:
    template <size_t ..._Indices>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __execute(__tuple_indices<_Indices...>)
    {
        std::__2::__invoke(std::__2::get<0>(std::__2::move(__f_)), std::__2::get<_Indices>(std::__2::move(__f_))...);
    }
};
# 652 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
template <class _Fp>
void __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*,
                                  void (*)(void*));



template<class _Callable, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
{
    if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0))
    {
        typedef tuple<_Callable&&, _Args&&...> _Gp;
        _Gp __f(std::__2::forward<_Callable>(__func), std::__2::forward<_Args>(__args)...);
        __call_once_param<_Gp> __p(__f);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
    }
}
# 707 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\mutex" 3
} }
# 20 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 2 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale.h" 1 3
# 44 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale.h" 3


# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 1 3
# 24 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
      namespace std {

          extern "C" {
# 65 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
extern __attribute__((__nothrow__)) char *setlocale(int , const char * );
# 97 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
extern __attribute__((__nothrow__)) char *_setlocale_r(char * , int , const char * );
# 114 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
struct lconv {
  char *decimal_point;

  char *thousands_sep;


  char *grouping;


  char *int_curr_symbol;







  char *currency_symbol;

  char *mon_decimal_point;

  char *mon_thousands_sep;


  char *mon_grouping;


  char *positive_sign;


  char *negative_sign;


  char int_frac_digits;



  char frac_digits;


  char p_cs_precedes;


  char p_sep_by_space;



  char n_cs_precedes;


  char n_sep_by_space;



  char p_sign_posn;


  char n_sign_posn;
# 203 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
    union {
        char __int_p_cs_precedes;

        char int_p_cs_precedes;

    };
    union {
        char __int_n_cs_precedes;

        char int_n_cs_precedes;

    };
    union {
        char __int_p_sep_by_space;

        char int_p_sep_by_space;

    };
    union {
        char __int_n_sep_by_space;

        char int_n_sep_by_space;

    };
    union {
        char __int_p_sign_posn;

        char int_p_sign_posn;

    };
    union {
        char __int_n_sign_posn;

        char int_n_sign_posn;

    };
};




extern __attribute__((__nothrow__)) struct lconv *localeconv(void);
# 264 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
extern __attribute__((__nothrow__)) void _get_lconv(struct lconv * ) __attribute__((__nonnull__(1)));
# 278 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
struct __aeabi_lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;


    union {
        char __int_p_cs_precedes;

        char int_p_cs_precedes;

    };
    union {
        char __int_n_cs_precedes;

        char int_n_cs_precedes;

    };
    union {
        char __int_p_sep_by_space;

        char int_p_sep_by_space;

    };
    union {
        char __int_n_sep_by_space;

        char int_n_sep_by_space;

    };
    union {
        char __int_p_sign_posn;

        char int_p_sign_posn;

    };
    union {
        char __int_n_sign_posn;

        char int_n_sign_posn;

    };
};




extern __attribute__((__nothrow__)) struct __aeabi_lconv *__aeabi_localeconv(void);
extern __attribute__((__nothrow__)) void _get_aeabi_lconv(struct __aeabi_lconv * ) __attribute__((__nonnull__(1)));





         }
      }
# 358 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\locale.h" 3
      using ::std::setlocale;
      using ::std::_setlocale_r;
      using ::std::lconv;
      using ::std::localeconv;
      using ::std::_get_lconv;
      using ::std::__aeabi_lconv;
      using ::std::__aeabi_localeconv;
      using ::std::_get_aeabi_lconv;
# 47 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale.h" 2 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 2 3
# 43 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 1 3
# 10 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\clocale" 1 3
# 42 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\clocale" 3


namespace std { inline namespace __2 {

using ::lconv;

using ::setlocale;

using ::localeconv;

} }
# 11 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 2 3

typedef void* locale_t;


typedef void *locale_t;
static inline locale_t duplocale(locale_t) {
  return 0;
}

static inline void freelocale(locale_t) {
}

static inline locale_t newlocale(int, const char *, locale_t) {
  return 0;
}

static inline locale_t uselocale(locale_t) {
  return 0;
}
# 49 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/xlocale/__posix_l_fallback.h" 1 3
# 19 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/xlocale/__posix_l_fallback.h" 3
extern "C" {


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isalnum_l(int c, locale_t) {
  return ::isalnum(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isalpha_l(int c, locale_t) {
  return ::isalpha(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isblank_l(int c, locale_t) {
  return ::isblank(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iscntrl_l(int c, locale_t) {
  return ::iscntrl(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isdigit_l(int c, locale_t) {
  return ::isdigit(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isgraph_l(int c, locale_t) {
  return ::isgraph(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int islower_l(int c, locale_t) {
  return ::islower(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isprint_l(int c, locale_t) {
  return ::isprint(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int ispunct_l(int c, locale_t) {
  return ::ispunct(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isspace_l(int c, locale_t) {
  return ::isspace(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isupper_l(int c, locale_t) {
  return ::isupper(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int isxdigit_l(int c, locale_t) {
  return ::isxdigit(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswalnum_l(wint_t c, locale_t) {
  return ::iswalnum(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswalpha_l(wint_t c, locale_t) {
  return ::iswalpha(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswblank_l(wint_t c, locale_t) {
  return ::iswblank(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswcntrl_l(wint_t c, locale_t) {
  return ::iswcntrl(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswdigit_l(wint_t c, locale_t) {
  return ::iswdigit(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswgraph_l(wint_t c, locale_t) {
  return ::iswgraph(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswlower_l(wint_t c, locale_t) {
  return ::iswlower(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswprint_l(wint_t c, locale_t) {
  return ::iswprint(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswpunct_l(wint_t c, locale_t) {
  return ::iswpunct(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswspace_l(wint_t c, locale_t) {
  return ::iswspace(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswupper_l(wint_t c, locale_t) {
  return ::iswupper(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int iswxdigit_l(wint_t c, locale_t) {
  return ::iswxdigit(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int toupper_l(int c, locale_t) {
  return ::toupper(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int tolower_l(int c, locale_t) {
  return ::tolower(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) wint_t towupper_l(wint_t c, locale_t) {
  return ::towupper(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) wint_t towlower_l(wint_t c, locale_t) {
  return ::towlower(c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int strcoll_l(const char *s1, const char *s2,
                                               locale_t) {
  return ::strcoll(s1, s2);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_t strxfrm_l(char *dest, const char *src,
                                                  size_t n, locale_t) {
  return ::strxfrm(dest, src, n);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_t strftime_l(char *s, size_t max,
                                                   const char *format,
                                                   const struct tm *tm, locale_t) {
  return ::strftime(s, max, format, tm);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int wcscoll_l(const wchar_t *ws1,
                                               const wchar_t *ws2, locale_t) {
  return ::wcscoll(ws1, ws2);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_t wcsxfrm_l(wchar_t *dest, const wchar_t *src,
                                                  size_t n, locale_t) {
  return ::wcsxfrm(dest, src, n);
}


}
# 50 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/xlocale/__strtonum_fallback.h" 1 3
# 20 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/xlocale/__strtonum_fallback.h" 3
extern "C" {


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__((pcs("aapcs"))) float strtof_l(const char *nptr,
                                            char **endptr, locale_t) {
  return ::strtof(nptr, endptr);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__((pcs("aapcs"))) double strtod_l(const char *nptr,
                                                   char **endptr, locale_t) {
  return ::strtod(nptr, endptr);
}


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __attribute__((pcs("aapcs"))) long double strtold_l(const char *nptr,
                                                   char **endptr, locale_t) {
  return ::strtold(nptr, endptr);
}


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) long long
strtoll_l(const char *nptr, char **endptr, int base, locale_t) {
  return ::strtoll(nptr, endptr, base);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long long
strtoull_l(const char *nptr, char **endptr, int base, locale_t) {
  return ::strtoull(nptr, endptr, base);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) long long
wcstoll_l(const wchar_t *nptr, wchar_t **endptr, int base, locale_t) {
  return ::wcstoll(nptr, endptr, base);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long long
wcstoull_l(const wchar_t *nptr, wchar_t **endptr, int base, locale_t) {
  return ::wcstoull(nptr, endptr, base);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) long double wcstold_l(const wchar_t *nptr,
                                                       wchar_t **endptr, locale_t) {
  return ::wcstold(nptr, endptr);
}


}
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\support/arm/locale_arm.h" 2 3
# 44 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 2 3
# 55 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3


namespace std { inline namespace __2 {


struct __libcpp_locale_guard {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
  ~__libcpp_locale_guard() {
    if (__old_loc_)
      uselocale(__old_loc_);
  }

  locale_t __old_loc_;
private:
  __libcpp_locale_guard(__libcpp_locale_guard const&);
  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);
};
# 116 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
class __attribute__ ((__visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__visibility__("default"))) locale
{
public:

    class __attribute__ ((__visibility__("default"))) facet;
    class __attribute__ ((__visibility__("default"))) id;

    typedef int category;

    static const category
        none = 0,
        collate = (1),
        ctype = (2),
        monetary = (4),
        numeric = (8),
        time = (16),

        messages = 0,



        all = collate | ctype | monetary | numeric | time | messages;


    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>
      inline __attribute__ ((__visibility__("hidden")))
      locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      inline __attribute__ ((__visibility__("hidden")))
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() noexcept;
};

class __attribute__ ((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::__2::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__2::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __attribute__ ((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__visibility__("default"))) collate<char>;
extern template class __attribute__ ((__visibility__("default"))) collate<wchar_t>;



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__2::use_facet<std::__2::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__ ((__visibility__("default"))) ctype_base
{
public:

    typedef unsigned long mask;
    static const mask space = 1<<0;
    static const mask print = 1<<1;
    static const mask cntrl = 1<<2;
    static const mask upper = 1<<3;
    static const mask lower = 1<<4;
    static const mask alpha = 1<<5;
    static const mask digit = 1<<6;
    static const mask punct = 1<<7;
    static const mask xdigit = 1<<8;
    static const mask blank = 1<<9;





    static const mask __regex_word = 1<<10;
# 520 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = nullptr, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return (__c == (__c & 0x7f)) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = (*__low == (*__low & 0x7f)) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if ((*__low == (*__low & 0x7f)) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!((*__low == (*__low & 0x7f)) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;




    static const size_t table_size = 256;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;
# 739 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__ ((__visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class __attribute__ ((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1263 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
template <>
class __attribute__ ((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1439 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

#pragma GCC diagnostic push
# 1454 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}
#pragma GCC diagnostic pop

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;





template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1492 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1528 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1586 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1622 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 2 3
# 225 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 3


namespace std { inline namespace __2 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};


    typedef iostate io_state;
    typedef openmode open_mode;
    typedef seekdir seek_dir;

    typedef std::__2::streamoff streamoff;
    typedef std::__2::streampos streampos;


    class __attribute__ ((__visibility__("default"))) Init;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool good() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __setstate_nothrow(iostate __state)
    {
        if (__rdbuf_)
            __rdstate_ |= __state;
        else
            __rdstate_ |= __state | ios_base::badbit;
    }

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;





    static int __xindex_;

    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


enum class __attribute__ ((__type_visibility__("default"))) io_errc
{
    stream = 1
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };






__attribute__ ((__visibility__("default")))
const error_category& iostream_category() noexcept;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    failure(const failure&) noexcept = default;
    virtual ~failure() noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void __throw_failure(char const* __msg) {



    ((void)__msg);
    std::__2::abort();

}

class __attribute__ ((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};





static ios_base::Init __start_std_streams;




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}
# 609 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
# 634 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ios" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit operator bool() const {return !fail();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ios() {
                }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void move(basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void move(basic_ios&& __rhs) {move(__rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
    mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = nullptr;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = nullptr;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::__2::swap(__tie_, __rhs.__tie_);
    std::__2::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

} }
# 139 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\streambuf" 1 3
# 116 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\streambuf" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 120 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\streambuf" 2 3

namespace std { inline namespace __2 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    virtual ~basic_streambuf();


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    locale getloc() const { return __loc_; }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int pubsync() { return sync(); }



    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* egptr() const {return __einp_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type* epptr() const {return __eout_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void pbump(int __n) { __nout_ += __n; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void __pbump(streamsize __n) { __nout_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(nullptr),
      __ninp_(nullptr),
      __einp_(nullptr),
      __bout_(nullptr),
      __nout_(nullptr),
      __eout_(nullptr)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__2::swap(__loc_, __sb.__loc_);
    std::__2::swap(__binp_, __sb.__binp_);
    std::__2::swap(__ninp_, __sb.__ninp_);
    std::__2::swap(__einp_, __sb.__einp_);
    std::__2::swap(__bout_, __sb.__bout_);
    std::__2::swap(__nout_, __sb.__nout_);
    std::__2::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::__2::min(static_cast<streamsize>(0x7fffffff),
                                std::__2::min(__einp_ - __ninp_, __n - __i));
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__2::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>;

} }
# 140 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 1 3
# 219 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bsd_locale_fallbacks.h" 1 3
# 17 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bsd_locale_fallbacks.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdlib.h" 1 3
# 18 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bsd_locale_fallbacks.h" 2 3
# 23 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__bsd_locale_fallbacks.h" 3


namespace std { inline namespace __2 {

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
decltype(( __aeabi_MB_CUR_MAX() )) __libcpp_mb_cur_max_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return ( __aeabi_MB_CUR_MAX() );
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
wint_t __libcpp_btowc_l(int __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return btowc(__c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __libcpp_wctob_l(wint_t __c, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wctob(__c);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,
                         size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);

    return _wcsnrtombs(__dest, __src, __nwc, __len, __ps);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return wcrtomb(__s, __wc, __ps);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,
                      size_t __len, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);

    return _mbsnrtowcs(__dest, __src, __nms, __len, __ps);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,
                   mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrtowc(__pwc, __s, __n, __ps);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
int __libcpp_mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbtowc(__pwc, __pmb, __max);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbrlen(__s, __n, __ps);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
lconv *__libcpp_localeconv_l(locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return localeconv();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
size_t __libcpp_mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,
                     mbstate_t *__ps, locale_t __l)
{
    __libcpp_locale_guard __current(__l);
    return mbsrtowcs(__dest, __src, __len, __ps);
}

inline
int __libcpp_snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);

    int __res = __ARM_vsnprintf(__s, __n, __format, __va);



    __builtin_va_end(__va);
    return __res;
}

inline
int __libcpp_asprintf_l(char **__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);

    int __res = __ARM_vasprintf(__s, __format, __va);



    __builtin_va_end(__va);
    return __res;
}

inline
int __libcpp_sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {
    va_list __va;
    __builtin_va_start(__va, __format);
    __libcpp_locale_guard __current(__l);

    int __res = __ARM_vsscanf(__s, __format, __va);



    __builtin_va_end(__va);
    return __res;
}

} }
# 220 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 2 3
# 224 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 228 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 2 3


namespace std { inline namespace __2 {
# 239 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
   __attribute__ ((__visibility__("default"))) locale_t __cloc();
# 261 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__2::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(nullptr, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == nullptr)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);







    static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep)
    {
        locale __loc = __iob.getloc();
        const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
        __thousands_sep = __np.thousands_sep();
        return __np.grouping();
    }

    const _CharT* __do_widen(ios_base& __iob, _CharT* __atoms) const
    {
      return __do_widen_p(__iob, __atoms);
    }


    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms);
private:
    template<typename T>
    const T* __do_widen_p(ios_base& __iob, T* __atoms) const
    {
      locale __loc = __iob.getloc();
      use_facet<ctype<T> >(__loc).widen(__src, __src + 26, __atoms);
      return __atoms;
    }

    const char* __do_widen_p(ios_base& __iob, char* __atoms) const
    {
      (void)__iob;
      (void)__atoms;
      return __src;
    }

};
# 450 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int





__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)


{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= (char) 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~num_get() {}

    template <class _Fp>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __save_errno = (*std:: __aeabi_errno_addr());
        (*std:: __aeabi_errno_addr()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, __cloc());
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __current_errno = (*std:: __aeabi_errno_addr());
        if (__current_errno == 0)
            (*std:: __aeabi_errno_addr()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 2 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        const bool __negate = *__a == '-';
        if (__negate && ++__a == __a_end) {
          __err = ios_base::failbit;
          return 0;
        }
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __save_errno = (*std:: __aeabi_errno_addr());
        (*std:: __aeabi_errno_addr()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, __cloc());
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __current_errno = (*std:: __aeabi_errno_addr());
        if (__current_errno == 0)
            (*std:: __aeabi_errno_addr()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 2 || numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        _Tp __res = static_cast<_Tp>(__ll);
        if (__negate) __res = -__res;
        return __res;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__attribute__((pcs("aapcs")))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, __cloc());
}

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, __cloc());
}


template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, __cloc());
}


template <class _Tp>
__attribute__ ((__visibility__("hidden")))
__attribute__((pcs("aapcs")))
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __save_errno = (*std:: __aeabi_errno_addr());
        (*std:: __aeabi_errno_addr()) = 0;
        char *__p2;
        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
        typename remove_reference<decltype((*std:: __aeabi_errno_addr()))>::type __current_errno = (*std:: __aeabi_errno_addr());
        if (__current_errno == 0)
            (*std:: __aeabi_errno_addr()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 2)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = std::__2::__scan_keyword(__b, __e, __names, __names+2,
                                                   __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;

    char_type __atoms1[__atoms_size];
    const char_type *__atoms = this->__do_widen(__iob, __atoms1);
    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);




    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;

    char_type __atoms1[__atoms_size];
    const char_type *__atoms = this->__do_widen(__iob, __atoms1);
    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);




    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __buf.resize(__a_end - __a);
    if (__libcpp_sscanf_l(__buf.c_str(), __cloc(), "%p", &__v) != 1)
        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, __cloc()))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, __cloc()))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __attribute__((pcs("aapcs")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __attribute__((pcs("aapcs")))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    __attribute__((pcs("aapcs")))
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;

    __attribute__((pcs("aapcs")))
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}

template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                                   (int)__iob.precision(), __v);
    else
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
        else
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}


template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                                   (int)__iob.precision(), __v);
    else
        __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
        else
            __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}


template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~__time_get_c_storage() {}
};

template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;

template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = std::__2::__scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = std::__2::__scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = std::__2::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = std::__2::__scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};
# 2448 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __time_put() : __loc_(__cloc()) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__2::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>;



class __attribute__ ((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>;



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>;



template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            [[clang::fallthrough]];
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(nullptr, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == nullptr)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__2::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) money_get<wchar_t>;



template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__2::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__2::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;

    int __n = __ARM_snprintf(__bb, __bs, "%.0Lf", __units);



    unique_ptr<char, void(*)(void*)> __hn(nullptr, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (static_cast<size_t>(__n) > __bs-1)
    {
        __n = __libcpp_asprintf_l(&__bb, __cloc(), "%.0Lf", __units);
        if (__n == -1)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = __n > __fd ?
                   (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) money_put<wchar_t>;



class __attribute__ ((__visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{






    ((void)(__nm));
    return -1;

}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{
# 3622 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\locale" 3
    ((void)(__c));
    ((void)(__set));
    ((void)(__msgid));
    return __dflt;

}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{






    ((void)(__c));

}

extern template class __attribute__ ((__visibility__("default"))) messages<char>;
extern template class __attribute__ ((__visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wstring_convert() : wstring_convert(new _Codecvt) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit wstring_convert(_Codecvt* __pcvt);






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
                                 wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wstring_convert(wstring_convert&& __wc);

    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::__2::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::__2::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);

public:

    wbuffer_convert() : wbuffer_convert(nullptr) {}
    explicit wbuffer_convert(streambuf* __bytebuf,
                             _Codecvt* __pcvt = new _Codecvt,
                             state_type __state = state_type());







    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        std::__2::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                std::__2::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__2::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = nullptr;
    if (__cv_ != nullptr && __bufptr_ != nullptr)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = nullptr;
    }
    return __rt;
}

} }
# 141 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 2 3

# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bitset" 1 3
# 126 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bitset" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 130 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bitset" 2 3


namespace std { inline namespace __2 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 263 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept




    : __first_{static_cast<__storage_type>(__v),
                _Size >= 2 * __bits_per_word ? static_cast<__storage_type>(__v >> __bits_per_word)
                : static_cast<__storage_type>((__v >> __bits_per_word) & (__storage_type(1) << (_Size - __bits_per_word)) - 1)}




{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__2::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__2::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void flip() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long long to_ullong() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool any() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(
        _Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                 : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)
    )
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference __make_ref(size_t) noexcept
        {return reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) iterator __make_iter(size_t) noexcept
        {return iterator(nullptr, 0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(nullptr, 0);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) void flip() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool all() const noexcept {return true;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool any() const noexcept {return false;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr bitset() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value> >
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset operator~() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t count() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__)) bool none() const noexcept {return !any();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT, class>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__2::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__2::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__2::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__2::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__2::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__2::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__2::min(__pos, _Size);
    std::__2::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__2::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__2::min(__pos, _Size);
    std::__2::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__2::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__2::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__2::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__2::__count_bool_true(base::__make_iter(0), _Size));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__2::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 143 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 2 3
# 147 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\ostream" 3


namespace std { inline namespace __2 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
    { this->init(__sb); }
    virtual ~basic_ostream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream(basic_ostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& operator=(basic_ostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_ostream& __rhs)
    { basic_ios<char_type, traits_type>::swap(__rhs); }


    basic_ostream (const basic_ostream& __rhs) = delete;
    basic_ostream& operator=(const basic_ostream& __rhs) = delete;




public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    __attribute__((pcs("aapcs")))
    basic_ostream& operator<<(float __f);
    __attribute__((pcs("aapcs")))
    basic_ostream& operator<<(double __f);
    __attribute__((pcs("aapcs")))
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& operator<<(nullptr_t)
    { return *this << "nullptr"; }


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    pos_type tellp();
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& seekp(pos_type __pos);
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {




            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);






    }
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
{
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{




        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {




                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);







            }
            else
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{




        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{




        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{




        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }







    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__2::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__2::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__2::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__2::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__2::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }







    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__2::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__2::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__2::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{




        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{




        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }







    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{




        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }







    return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}



template <class _Stream, class _Tp, class = void>
struct __is_ostreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_ostreamable<_Stream, _Tp, decltype(
    std::__2::declval<_Stream>() << std::__2::declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_ostreamable<_Stream&, const _Tp&>>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Stream&& operator<<(_Stream&& __os, const _Tp& __x)
{
    __os << __x;
    return std::__2::move(__os);
}



template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__2::__put_character_sequence(__os, __str.data(), __str.size());
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __sv)
{
    return std::__2::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template<class _CharT, class _Traits, class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
typename enable_if
<
    is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits>&>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
    basic_ostream<_CharT, _Traits>&
>::type
operator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}

extern template class __attribute__ ((__visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostream<wchar_t>;

} }
# 185 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 2 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 1 3
# 168 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 172 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 2 3


namespace std { inline namespace __2 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
    { this->init(__sb); }
    virtual ~basic_istream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream(basic_istream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& operator=(basic_istream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_istream& __rhs) {
      std::__2::swap(__gc_, __rhs.__gc_);
      basic_ios<char_type, traits_type>::swap(__rhs);
    }


    basic_istream (const basic_istream& __rhs) = delete;
    basic_istream& operator=(const basic_istream& __rhs) = delete;

public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    __attribute__((pcs("aapcs")))
    basic_istream& operator>>(float& __f);
    __attribute__((pcs("aapcs")))
    basic_istream& operator>>(double& __f);
    __attribute__((pcs("aapcs")))
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& get(char_type& __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
    { return get(__sb, this->widen('\n')); }

    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
    : __gc_(__rhs.__gc_)
{
    __rhs.__gc_ = 0;
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
__input_arithmetic(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {




            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);
# 392 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{
    return std::__2::__input_arithmetic<unsigned short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{
    return std::__2::__input_arithmetic<unsigned int>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{
    return std::__2::__input_arithmetic<long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{
    return std::__2::__input_arithmetic<unsigned long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{
    return std::__2::__input_arithmetic<long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{
    return std::__2::__input_arithmetic<unsigned long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{
    return std::__2::__input_arithmetic<float>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{
    return std::__2::__input_arithmetic<double>(*this, __n);
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{
    return std::__2::__input_arithmetic<long double>(*this, __n);
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{
    return std::__2::__input_arithmetic<bool>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{
    return std::__2::__input_arithmetic<void*>(*this, __n);
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {




            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            long __temp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
            if (__temp < numeric_limits<_Tp>::min())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::min();
            }
            else if (__temp > numeric_limits<_Tp>::max())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::max();
            }
            else
            {
                __n = static_cast<_Tp>(__temp);
            }
# 518 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{
    return std::__2::__input_arithmetic_with_numeric_limits<short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{
    return std::__2::__input_arithmetic_with_numeric_limits<int>(*this, __n);
}

template<class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
__input_c_string(basic_istream<_CharT, _Traits>& __is, _CharT* __p, size_t __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {




            _CharT* __s = __p;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__s != __p + (__n-1))
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__s == __p)
               __state |= ios_base::failbit;
# 582 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}
# 618 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{
    streamsize __n = __is.width();
    if (__n <= 0)
        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
    return std::__2::__input_c_string(__is, __s, size_t(__n));
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}



template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {




            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __state |= ios_base::eofbit | ios_base::failbit;
            else
                __c = _Traits::to_char_type(__i);
# 676 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __s(*this, true);
    if (__s)
    {
        if (__sb)
        {




                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, _Traits::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    if (traits_type::eq_int_type(
                            __sb->sputc(traits_type::to_char_type(__i)),
                            traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;
# 744 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __s(*this, true);
    if (__s)
    {




            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               __state |= ios_base::failbit | ios_base::eofbit;
            else
                __gc_ = 1;
# 784 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {
        if (__n > 0)
        {




                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;
# 835 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        }
        else
        {
            __state |= ios_base::failbit;
        }

        if (__n > 0)
            *__s = char_type();
        this->setstate(__state);
    }
    if (__n > 0)
        *__s = char_type();
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                    break;
                if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                    break;
                ++__gc_;
                this->rdbuf()->sbumpc();
            }
# 888 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        if (__gc_ == 0)
           __state |= ios_base::failbit;
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __state |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
# 948 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
    }
    if (__n > 0)
        *__s = char_type();
    if (__gc_ == 0)
        __state |= ios_base::failbit;
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
# 1012 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __sen(*this, true);
    if (__sen)
    {




            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                __state |= ios_base::eofbit;
# 1046 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                __state |= ios_base::failbit | ios_base::eofbit;
# 1079 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            streamsize __c = this->rdbuf()->in_avail();
            switch (__c)
            {
            case -1:
                __state |= ios_base::eofbit;
                break;
            case 0:
                break;
            default:
                __n = std::__2::min(__c, __n);
                __gc_ = this->rdbuf()->sgetn(__s, __n);
                if (__gc_ != __n)
                    __state |= ios_base::failbit | ios_base::eofbit;
                break;
            }
# 1128 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {




            if (this->rdbuf() == nullptr || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                __state |= ios_base::badbit;
# 1165 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {




            if (this->rdbuf() == nullptr || this->rdbuf()->sungetc() == traits_type::eof())
                __state |= ios_base::badbit;
# 1202 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    ios_base::iostate __state = ios_base::goodbit;
    int __r = 0;
    sentry __sen(*this, true);
    if (__sen)
    {




            if (this->rdbuf() == nullptr)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                __state |= ios_base::badbit;
                return -1;
            }
# 1243 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    ios_base::iostate __state = ios_base::goodbit;
    pos_type __r(-1);
    sentry __sen(*this, true);
    if (__sen)
    {




        __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
# 1274 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {




            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;
# 1306 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {




            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;
# 1338 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        this->setstate(__state);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {




            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
# 1380 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}



template <class _Stream, class _Tp, class = void>
struct __is_istreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_istreamable<_Stream, _Tp, decltype(
    std::__2::declval<_Stream>() >> std::__2::declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_istreamable<_Stream&, _Tp&&>>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
_Stream&& operator>>(_Stream&& __is, _Tp&& __x)
{
    __is >> std::__2::forward<_Tp>(__x);
    return std::__2::move(__is);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb)
    {}

    virtual ~basic_iostream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_iostream(basic_iostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_iostream& operator=(basic_iostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_iostream& __rhs)
    { basic_istream<char_type, traits_type>::swap(__rhs); }
};



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__2::move(__rhs))
{
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>&
basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {




            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __state |= ios_base::failbit;
# 1516 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {




            __str.clear();
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __state |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __state |= ios_base::failbit;
# 1569 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    return getline(__is, __str, __dlm);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {




            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            size_t __c = 0;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (_Size > 0 && __c == 0)
               __state |= ios_base::failbit;
# 1652 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\istream" 3
        __is.setstate(__state);
    }
    return __is;
}

extern template class __attribute__ ((__visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__visibility__("default"))) basic_iostream<char>;

} }
# 186 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 2 3
# 190 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 3



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__undef_macros" 1 3
# 194 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\sstream" 2 3


namespace std { inline namespace __2 {



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringbuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:

    string_type __str_;
    mutable char_type* __hm_;
    ios_base::openmode __mode_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringbuf() : basic_stringbuf(ios_base::in | ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_stringbuf(ios_base::openmode __wch)
        : __hm_(nullptr), __mode_(__wch) {}







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_stringbuf(const string_type& __s,
                             ios_base::openmode __wch = ios_base::in | ios_base::out)
        : __str_(__s.get_allocator()), __hm_(nullptr), __mode_(__wch)
    {
        str(__s);
    }

    basic_stringbuf(basic_stringbuf&& __rhs);


    basic_stringbuf& operator=(basic_stringbuf&& __rhs);
    void swap(basic_stringbuf& __rhs);


    string_type str() const;
    void str(const string_type& __s);

protected:

    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out) {
        return seekoff(__sp, ios_base::beg, __wch);
    }
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)
    : __mode_(__rhs.__mode_)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__2::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>&
basic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__2::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    else
        this->setp(nullptr, nullptr);

    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __mode_ = __rhs.__mode_;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __rbinp = -1;
    ptrdiff_t __rninp = -1;
    ptrdiff_t __reinp = -1;
    if (__rhs.eback() != nullptr)
    {
        __rbinp = __rhs.eback() - __p;
        __rninp = __rhs.gptr() - __p;
        __reinp = __rhs.egptr() - __p;
    }
    ptrdiff_t __rbout = -1;
    ptrdiff_t __rnout = -1;
    ptrdiff_t __reout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __rbout = __rhs.pbase() - __p;
        __rnout = __rhs.pptr() - __p;
        __reout = __rhs.epptr() - __p;
    }
    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __p = const_cast<char_type*>(__str_.data());
    ptrdiff_t __lbinp = -1;
    ptrdiff_t __lninp = -1;
    ptrdiff_t __leinp = -1;
    if (this->eback() != nullptr)
    {
        __lbinp = this->eback() - __p;
        __lninp = this->gptr() - __p;
        __leinp = this->egptr() - __p;
    }
    ptrdiff_t __lbout = -1;
    ptrdiff_t __lnout = -1;
    ptrdiff_t __leout = -1;
    if (this->pbase() != nullptr)
    {
        __lbout = this->pbase() - __p;
        __lnout = this->pptr() - __p;
        __leout = this->epptr() - __p;
    }
    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;
    std::__2::swap(__mode_, __rhs.__mode_);
    __str_.swap(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__rbinp != -1)
        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__rbout != -1)
    {
        this->setp(__p + __rbout, __p + __reout);
        this->__pbump(__rnout);
    }
    else
        this->setp(nullptr, nullptr);
    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    if (__lbinp != -1)
        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
    else
        __rhs.setg(nullptr, nullptr, nullptr);
    if (__lbout != -1)
    {
        __rhs.setp(__p + __lbout, __p + __leout);
        __rhs.__pbump(__lnout);
    }
    else
        __rhs.setp(nullptr, nullptr);
    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;
    locale __tl = __rhs.getloc();
    __rhs.pubimbue(this->getloc());
    this->pubimbue(__tl);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::str() const
{
    if (__mode_ & ios_base::out)
    {
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        return string_type(this->pbase(), __hm_, __str_.get_allocator());
    }
    else if (__mode_ & ios_base::in)
        return string_type(this->eback(), this->egptr(), __str_.get_allocator());
    return string_type(__str_.get_allocator());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __str_ = __s;
    __hm_ = nullptr;
    if (__mode_ & ios_base::in)
    {
        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();
        this->setg(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()),
                   __hm_);
    }
    if (__mode_ & ios_base::out)
    {
        typename string_type::size_type __sz = __str_.size();
        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;
        __str_.resize(__str_.capacity());
        this->setp(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()) + __str_.size());
        if (__mode_ & (ios_base::app | ios_base::ate))
        {
            while (__sz > 0x7fffffff)
            {
                this->pbump(0x7fffffff);
                __sz -= 0x7fffffff;
            }
            if (__sz > 0)
                this->pbump(__sz);
        }
    }
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::underflow()
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (__mode_ & ios_base::in)
    {
        if (this->egptr() < __hm_)
            this->setg(this->eback(), this->gptr(), __hm_);
        if (this->gptr() < this->egptr())
            return traits_type::to_int_type(*this->gptr());
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            return traits_type::not_eof(__c);
        }
        if ((__mode_ & ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)
{
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        ptrdiff_t __ninp = this->gptr() - this->eback();
        if (this->pptr() == this->epptr())
        {
            if (!(__mode_ & ios_base::out))
                return traits_type::eof();




                ptrdiff_t __nout = this->pptr() - this->pbase();
                ptrdiff_t __hm = __hm_ - this->pbase();
                __str_.push_back(char_type());
                __str_.resize(__str_.capacity());
                char_type* __p = const_cast<char_type*>(__str_.data());
                this->setp(__p, __p + __str_.size());
                this->__pbump(__nout);
                __hm_ = this->pbase() + __hm;







        }
        __hm_ = std::__2::max(this->pptr() + 1, __hm_);
        if (__mode_ & ios_base::in)
        {
            char_type* __p = const_cast<char_type*>(__str_.data());
            this->setg(__p, __p + __ninp, __hm_);
        }
        return this->sputc(traits_type::to_char_type(__c));
    }
    return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,
                                                      ios_base::seekdir __way,
                                                      ios_base::openmode __wch)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if ((__wch & (ios_base::in | ios_base::out)) == 0)
        return pos_type(-1);
    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)
        && __way == ios_base::cur)
        return pos_type(-1);
    const ptrdiff_t __hm = __hm_ == nullptr ? 0 : __hm_ - __str_.data();
    off_type __noff;
    switch (__way)
    {
    case ios_base::beg:
        __noff = 0;
        break;
    case ios_base::cur:
        if (__wch & ios_base::in)
            __noff = this->gptr() - this->eback();
        else
            __noff = this->pptr() - this->pbase();
        break;
    case ios_base::end:
        __noff = __hm;
        break;
    default:
        return pos_type(-1);
    }
    __noff += __off;
    if (__noff < 0 || __hm < __noff)
        return pos_type(-1);
    if (__noff != 0)
    {
        if ((__wch & ios_base::in) && this->gptr() == nullptr)
            return pos_type(-1);
        if ((__wch & ios_base::out) && this->pptr() == nullptr)
            return pos_type(-1);
    }
    if (__wch & ios_base::in)
        this->setg(this->eback(), this->eback() + __noff, __hm_);
    if (__wch & ios_base::out)
    {
        this->setp(this->pbase(), this->epptr());
        this->pbump(__noff);
    }
    return pos_type(__noff);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_istringstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istringstream() : basic_istringstream(ios_base::in) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_istringstream(ios_base::openmode __wch)
        : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::in) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_istringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::in)
        : basic_istream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch | ios_base::in)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istringstream(basic_istringstream&& __rhs)
        : basic_istream<_CharT, _Traits>(std::__2::move(__rhs))
        , __sb_(std::__2::move(__rhs.__sb_))
    {
        basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_istringstream& operator=(basic_istringstream&& __rhs) {
        basic_istream<char_type, traits_type>::operator=(std::__2::move(__rhs));
        __sb_ = std::__2::move(__rhs.__sb_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_istringstream& __rhs) {
        basic_istream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
     basic_istringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_ostringstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostringstream() : basic_ostringstream(ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_ostringstream(ios_base::openmode __wch)
        : basic_ostream<_CharT, _Traits>(&__sb_),
          __sb_(__wch | ios_base::out) {}







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_ostringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::out)
        : basic_ostream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch | ios_base::out)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostringstream(basic_ostringstream&& __rhs)
        : basic_ostream<_CharT, _Traits>(std::__2::move(__rhs))
        , __sb_(std::__2::move(__rhs.__sb_))
    {
        basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_ostringstream& operator=(basic_ostringstream&& __rhs) {
        basic_ostream<char_type, traits_type>::operator=(std::__2::move(__rhs));
        __sb_ = std::__2::move(__rhs.__sb_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_ostringstream& __rhs) {
        basic_ostream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringstream() : basic_stringstream(ios_base::in | ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_stringstream(ios_base::openmode __wch)
        : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__wch) {}







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit basic_stringstream(const string_type& __s,
                                ios_base::openmode __wch = ios_base::in | ios_base::out)
        : basic_iostream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringstream(basic_stringstream&& __rhs)
        : basic_iostream<_CharT, _Traits>(std::__2::move(__rhs))
        , __sb_(std::__2::move(__rhs.__sb_))
    {
        basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_stringstream& operator=(basic_stringstream&& __rhs) {
        basic_iostream<char_type, traits_type>::operator=(std::__2::move(__rhs));
        __sb_ = std::__2::move(__rhs.__sb_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void swap(basic_stringstream& __rhs) {
        basic_iostream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
void
swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
     basic_stringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}


extern template class __attribute__ ((__visibility__("default"))) basic_stringbuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_stringstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostringstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istringstream<char>;


} }
# 27 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h" 2





# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iomanip" 1 3
# 52 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iomanip" 3


namespace std { inline namespace __2 {



class __iom_t1
{
    ios_base::fmtflags __mask_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)
    {
        __is.unsetf(__x.__mask_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)
    {
        __os.unsetf(__x.__mask_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t1
resetiosflags(ios_base::fmtflags __mask)
{
    return __iom_t1(__mask);
}



class __iom_t2
{
    ios_base::fmtflags __mask_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)
    {
        __is.setf(__x.__mask_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)
    {
        __os.setf(__x.__mask_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t2
setiosflags(ios_base::fmtflags __mask)
{
    return __iom_t2(__mask);
}



class __iom_t3
{
    int __base_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t3(int __b) : __base_(__b) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)
    {
        __is.setf(__x.__base_ == 8 ? ios_base::oct :
                  __x.__base_ == 10 ? ios_base::dec :
                  __x.__base_ == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)
    {
        __os.setf(__x.__base_ == 8 ? ios_base::oct :
                  __x.__base_ == 10 ? ios_base::dec :
                  __x.__base_ == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t3
setbase(int __base)
{
    return __iom_t3(__base);
}



template<class _CharT>
class __iom_t4
{
    _CharT __fill_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t4(_CharT __c) : __fill_(__c) {}

    template <class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)
    {
        __os.fill(__x.__fill_);
        return __os;
    }
};

template<class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t4<_CharT>
setfill(_CharT __c)
{
    return __iom_t4<_CharT>(__c);
}



class __iom_t5
{
    int __n_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t5(int __n) : __n_(__n) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)
    {
        __is.precision(__x.__n_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)
    {
        __os.precision(__x.__n_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t5
setprecision(int __n)
{
    return __iom_t5(__n);
}



class __iom_t6
{
    int __n_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    explicit __iom_t6(int __n) : __n_(__n) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)
    {
        __is.width(__x.__n_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)
    {
        __os.width(__x.__n_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t6
setw(int __n)
{
    return __iom_t6(__n);
}



template <class _MoneyT> class __iom_t7;

template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);

template <class _MoneyT>
class __iom_t7
{
    _MoneyT& __mon_;
    bool __intl_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iom_t7(_MoneyT& __mon, bool __intl)
        : __mon_(__mon), __intl_(__intl) {}

    template <class _CharT, class _Traits, class _Mp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);
};

template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)
{




        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef money_get<_CharT, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            const _Fp& __mf = use_facet<_Fp>(__is.getloc());
            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);
            __is.setstate(__err);
        }







    return __is;
}

template <class _MoneyT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t7<_MoneyT>
get_money(_MoneyT& __mon, bool __intl = false)
{
    return __iom_t7<_MoneyT>(__mon, __intl);
}



template <class _MoneyT> class __iom_t8;

template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);

template <class _MoneyT>
class __iom_t8
{
    const _MoneyT& __mon_;
    bool __intl_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iom_t8(const _MoneyT& __mon, bool __intl)
        : __mon_(__mon), __intl_(__intl) {}

    template <class _CharT, class _Traits, class _Mp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);
};

template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            typedef money_put<_CharT, _Op> _Fp;
            const _Fp& __mf = use_facet<_Fp>(__os.getloc());
            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())
                __os.setstate(ios_base::badbit);
        }







    return __os;
}

template <class _MoneyT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t8<_MoneyT>
put_money(const _MoneyT& __mon, bool __intl = false)
{
    return __iom_t8<_MoneyT>(__mon, __intl);
}



template <class _CharT> class __iom_t9;

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);

template <class _CharT>
class __iom_t9
{
    tm* __tm_;
    const _CharT* __fmt_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iom_t9(tm* __tm, const _CharT* __fmt)
        : __tm_(__tm), __fmt_(__fmt) {}

    template <class _Cp, class _Traits>
    friend
    basic_istream<_Cp, _Traits>&
    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)
{




        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef time_get<_CharT, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            const _Fp& __tf = use_facet<_Fp>(__is.getloc());
            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,
                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));
            __is.setstate(__err);
        }







    return __is;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t9<_CharT>
get_time(tm* __tm, const _CharT* __fmt)
{
    return __iom_t9<_CharT>(__tm, __fmt);
}



template <class _CharT> class __iom_t10;

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);

template <class _CharT>
class __iom_t10
{
    const tm* __tm_;
    const _CharT* __fmt_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
    __iom_t10(const tm* __tm, const _CharT* __fmt)
        : __tm_(__tm), __fmt_(__fmt) {}

    template <class _Cp, class _Traits>
    friend
    basic_ostream<_Cp, _Traits>&
    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)
{




        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            typedef time_put<_CharT, _Op> _Fp;
            const _Fp& __tf = use_facet<_Fp>(__os.getloc());
            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,
                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())
                __os.setstate(ios_base::badbit);
        }







    return __os;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__iom_t10<_CharT>
put_time(const tm* __tm, const _CharT* __fmt)
{
    return __iom_t10<_CharT>(__tm, __fmt);
}

template <class _CharT, class _Traits, class _ForwardIterator>
basic_ostream<_CharT, _Traits> &
__quoted_output ( basic_ostream<_CharT, _Traits> &__os,
        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )
{
    std::__2::basic_string<_CharT, _Traits> __str;
    __str.push_back(__delim);
    for ( ; __first != __last; ++ __first )
    {
        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))
            __str.push_back(__escape);
        __str.push_back(*__first);
    }
    __str.push_back(__delim);
    return std::__2::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _String>
basic_istream<_CharT, _Traits> &
__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )
{
    __string.clear ();
    _CharT __c;
    __is >> __c;
    if ( __is.fail ())
        return __is;

    if (!_Traits::eq (__c, __delim))
    {
        __is.unget ();
        __is >> __string;
        return __is;
    }

    __save_flags<_CharT, _Traits> sf(__is);
    noskipws (__is);
    while (true)
        {
        __is >> __c;
        if ( __is.fail ())
            break;
        if (_Traits::eq (__c, __escape))
        {
            __is >> __c;
            if ( __is.fail ())
                break;
        }
        else if (_Traits::eq (__c, __delim))
            break;
        __string.push_back ( __c );
        }
    return __is;
}


template <class _CharT, class _Traits, class _Iter>
basic_ostream<_CharT, _Traits>& operator<<(
         basic_ostream<_CharT, _Traits>& __os,
         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)
{
    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);
}

template <class _CharT, class _Traits, class _Allocator>
struct __quoted_proxy
{
    basic_string<_CharT, _Traits, _Allocator> &__string;
    _CharT __delim;
    _CharT __escape;

    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)
    : __string(__s), __delim(__d), __escape(__e) {}
};

template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_ostream<_CharT, _Traits>& operator<<(
        basic_ostream<_CharT, _Traits>& __os,
        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
{
    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);
}


template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
basic_istream<_CharT, _Traits>& operator>>(
        basic_istream<_CharT, _Traits>& __is,
        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
{
    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );
}


template <class _CharT>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__quoted_output_proxy<_CharT, const _CharT *>
quoted ( const _CharT *__s, _CharT __delim = _CharT('"'), _CharT __escape =_CharT('\\'))
{
    const _CharT *__end = __s;
    while ( *__end ) ++__end;
    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );
}


template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
__quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted_output_proxy<_CharT,
            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
                    ( __s.cbegin(), __s.cend (), __delim, __escape );
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__always_inline__))
__quoted_proxy<_CharT, _Traits, _Allocator>
__quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );
}
# 668 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\iomanip" 3
} }
# 33 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h" 2


namespace flatbuffers {





inline bool check_ascii_range(char x, char a, char b) {
  ((a <= b) ? (void)0 : std:: __aeabi_assert("a <= b", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 42),
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((a <= b)?1:0)
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 42 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);


  return static_cast<unsigned int>(x - a) <= static_cast<unsigned int>(b - a);
}


inline bool is_alpha(char c) {

  return check_ascii_range(c & 0xDF, 'a' & 0xDF, 'z' & 0xDF);
}


inline bool is_alpha_char(char c, char alpha) {
  ((is_alpha(alpha)) ? (void)0 : std:: __aeabi_assert("is_alpha(alpha)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 56),
# 56 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 56 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 56 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((is_alpha(alpha))?1:0)
# 56 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 56 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);

  return ((c & 0xDF) == (alpha & 0xDF));
}






inline bool is_digit(char c) { return check_ascii_range(c, '0', '9'); }

inline bool is_xdigit(char c) {

  return is_digit(c) || check_ascii_range(c & 0xDF, 'a' & 0xDF, 'f' & 0xDF);
}


inline bool is_alnum(char c) { return is_alpha(c) || is_digit(c); }

inline char CharToUpper(char c) {
  return static_cast<char>(::toupper(static_cast<unsigned char>(c)));
}

inline char CharToLower(char c) {
  return static_cast<char>(::tolower(static_cast<unsigned char>(c)));
}
# 122 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
template<typename T> std::string NumToString(T t) {



    std::stringstream ss;
    ss << t;
    return ss.str();





}

template<> inline std::string NumToString<signed char>(signed char t) {
  return NumToString(static_cast<int>(t));
}
template<> inline std::string NumToString<unsigned char>(unsigned char t) {
  return NumToString(static_cast<int>(t));
}
template<> inline std::string NumToString<char>(char t) {
  return NumToString(static_cast<int>(t));
}
# 161 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
template<typename T> std::string FloatToString(T t, int precision) {





    std::stringstream ss;

    ss << std::fixed;

    ss << std::setprecision(precision);
    ss << t;
    auto s = ss.str();






  auto p = s.find_last_not_of('0');
  if (p != std::string::npos) {

    s.resize(p + (s[p] == '.' ? 2 : 1));
  }
  return s;
}

template<> inline std::string NumToString<double>(double t) {
  return FloatToString(t, 12);
}
template<> inline std::string NumToString<float>(float t) {
  return FloatToString(t, 6);
}




inline std::string IntToStringHex(int i, int xdigits) {
  ((i >= 0) ? (void)0 : std:: __aeabi_assert("i >= 0", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 199),
# 199 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 199 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 199 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((i >= 0)?1:0)
# 199 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 199 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);



    std::stringstream ss;
    ss << std::setw(xdigits) << std::setfill('0') << std::hex << std::uppercase
       << i;
    return ss.str();




}
# 253 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
inline void strtoval_impl(int64_t *val, const char *str, char **endptr,
                                 int base) {
    *val = strtoll(str, endptr, base);
}

inline void strtoval_impl(uint64_t *val, const char *str, char **endptr,
                                 int base) {
  *val = strtoull(str, endptr, base);
}

inline void strtoval_impl(double *val, const char *str, char **endptr) {
  *val = strtod(str, endptr);
}


__attribute__((no_sanitize("float-cast-overflow")))
inline void strtoval_impl(float *val, const char *str, char **endptr) {
  *val = static_cast<float>(strtod(str, endptr));
}
# 290 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
template<typename T>
inline bool StringToIntegerImpl(T *val, const char *const str,
                                const int base = 0,
                                const bool check_errno = true) {

  ((str) ? (void)0 : std:: __aeabi_assert("str", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 295),
# 295 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 295 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 295 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((str)?1:0)
# 295 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 295 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);
  if (base <= 0) {
    auto s = str;
    while (*s && !is_digit(*s)) s++;
    if (s[0] == '0' && is_alpha_char(s[1], 'X'))
      return StringToIntegerImpl(val, str, 16, check_errno);

    return StringToIntegerImpl(val, str, 10, check_errno);
  } else {
    if (check_errno) (*std:: __aeabi_errno_addr()) = 0;
    auto endptr = str;
    strtoval_impl(val, str, const_cast<char **>(&endptr), base);
    if ((*endptr != '\0') || (endptr == str)) {
      *val = 0;
      return false;
    }

    if (check_errno && (*std:: __aeabi_errno_addr())) return false;
    return true;
  }
}

template<typename T>
inline bool StringToFloatImpl(T *val, const char *const str) {

  ((str && val) ? (void)0 : std:: __aeabi_assert("str && val", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 320),
# 320 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 320 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 320 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((str && val)?1:0)
# 320 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 320 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);
  auto end = str;
  strtoval_impl(val, str, const_cast<char **>(&end));
  auto done = (end != str) && (*end == '\0');
  if (!done) *val = 0;
  return done;
}







template<typename T> inline bool StringToNumber(const char *s, T *val) {
  ((s && val) ? (void)0 : std:: __aeabi_assert("s && val", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 335),
# 335 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 335 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 335 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((s && val)?1:0)
# 335 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 335 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);
  int64_t i64;

  if (StringToIntegerImpl(&i64, s, 0, false)) {
    const int64_t max = (flatbuffers::numeric_limits<T>::max)();
    const int64_t min = flatbuffers::numeric_limits<T>::lowest();
    if (i64 > max) {
      *val = static_cast<T>(max);
      return false;
    }
    if (i64 < min) {


      *val = static_cast<T>(flatbuffers::is_unsigned<T>::value ? max : min);
      return false;
    }
    *val = static_cast<T>(i64);
    return true;
  }
  *val = 0;
  return false;
}

template<> inline bool StringToNumber<int64_t>(const char *str, int64_t *val) {
  return StringToIntegerImpl(val, str);
}

template<>
inline bool StringToNumber<uint64_t>(const char *str, uint64_t *val) {
  if (!StringToIntegerImpl(val, str)) return false;





  if (*val) {
    auto s = str;
    while (*s && !is_digit(*s)) s++;
    s = (s > str) ? (s - 1) : s;
    if (*s == '-') {


      *val = (flatbuffers::numeric_limits<uint64_t>::max)();
      return false;
    }
  }
  return true;
}

template<> inline bool StringToNumber(const char *s, float *val) {
  return StringToFloatImpl(val, s);
}

template<> inline bool StringToNumber(const char *s, double *val) {
  return StringToFloatImpl(val, s);
}

inline int64_t StringToInt(const char *s, int base = 10) {
  int64_t val;
  return StringToIntegerImpl(&val, s, base) ? val : 0;
}

inline uint64_t StringToUInt(const char *s, int base = 10) {
  uint64_t val;
  return StringToIntegerImpl(&val, s, base) ? val : 0;
}

typedef bool (*LoadFileFunction)(const char *filename, bool binary,
                                 std::string *dest);
typedef bool (*FileExistsFunction)(const char *filename);

LoadFileFunction SetLoadFileFunction(LoadFileFunction load_file_function);

FileExistsFunction SetFileExistsFunction(
    FileExistsFunction file_exists_function);


bool FileExists(const char *name);


bool DirExists(const char *name);





bool LoadFile(const char *name, bool binary, std::string *buf);






bool SaveFile(const char *name, const char *buf, size_t len, bool binary);





inline bool SaveFile(const char *name, const std::string &buf, bool binary) {
  return SaveFile(name, buf.c_str(), buf.size(), binary);
}







constexpr char kPathSeparator = '/';


std::string StripExtension(const std::string &filepath);


std::string GetExtension(const std::string &filepath);


std::string StripPath(const std::string &filepath);


std::string StripFileName(const std::string &filepath);



std::string ConCatPathFileName(const std::string &path,
                               const std::string &filename);


std::string PosixPath(const char *path);



void EnsureDirExists(const std::string &filepath);



std::string AbsolutePath(const std::string &filepath);





inline int ToUTF8(uint32_t ucc, std::string *out) {
  ((!(ucc & 0x80000000)) ? (void)0 : std:: __aeabi_assert("!(ucc & 0x80000000)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 479),
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((!(ucc & 0x80000000))?1:0)
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 479 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);

  for (int i = 0; i < 6; i++) {

    uint32_t max_bits = 6 + i * 5 + static_cast<int>(!i);
    if (ucc < (1u << max_bits)) {

      uint32_t remain_bits = i * 6;

      (*out) += static_cast<char>((0xFE << (max_bits - remain_bits)) |
                                  (ucc >> remain_bits));

      for (int j = i - 1; j >= 0; j--) {
        (*out) += static_cast<char>(((ucc >> (j * 6)) & 0x3F) | 0x80);
      }
      return i + 1;
    }
  }
  ((0) ? (void)0 : std:: __aeabi_assert("0", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h", 497),
# 497 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic push
# 497 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic ignored "-Wassume"
# 497 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
 (__builtin_assume)((0)?1:0)
# 497 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
#pragma clang diagnostic pop
# 497 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
);
  return -1;
}






inline int FromUTF8(const char **in) {
  int len = 0;

  for (int mask = 0x80; mask >= 0x04; mask >>= 1) {
    if (**in & mask) {
      len++;
    } else {
      break;
    }
  }
  if ((static_cast<unsigned char>(**in) << len) & 0x80)
    return -1;
  if (!len) return *(*in)++;

  if (len < 2 || len > 4) { return -1; }

  int ucc = *(*in)++ & ((1 << (7 - len)) - 1);
  for (int i = 0; i < len - 1; i++) {
    if ((**in & 0xC0) != 0x80) return -1;
    ucc <<= 6;
    ucc |= *(*in)++ & 0x3F;
  }


  if (ucc >= 0xD800 && ucc <= 0xDFFF) { return -1; }

  switch (len) {
    case 2:

      if (ucc < 0x0080 || ucc > 0x07FF) { return -1; }
      break;
    case 3:

      if (ucc < 0x0800 || ucc > 0xFFFF) { return -1; }
      break;
    case 4:

      if (ucc < 0x10000 || ucc > 0x10FFFF) { return -1; }
      break;
  }
  return ucc;
}






inline std::string WordWrap(const std::string in, size_t max_length,
                            const std::string wrapped_line_prefix,
                            const std::string wrapped_line_suffix) {
  std::istringstream in_stream(in);
  std::string wrapped, line, word;

  in_stream >> word;
  line = word;

  while (in_stream >> word) {
    if ((line.length() + 1 + word.length() + wrapped_line_suffix.length()) <
        max_length) {
      line += " " + word;
    } else {
      wrapped += line + wrapped_line_suffix + "\n";
      line = wrapped_line_prefix + word;
    }
  }
  wrapped += line;

  return wrapped;
}


inline bool EscapeString(const char *s, size_t length, std::string *_text,
                         bool allow_non_utf8, bool natural_utf8) {
  std::string &text = *_text;
  text += "\"";
  for (uoffset_t i = 0; i < length; i++) {
    char c = s[i];
    switch (c) {
      case '\n': text += "\\n"; break;
      case '\t': text += "\\t"; break;
      case '\r': text += "\\r"; break;
      case '\b': text += "\\b"; break;
      case '\f': text += "\\f"; break;
      case '\"': text += "\\\""; break;
      case '\\': text += "\\\\"; break;
      default:
        if (c >= ' ' && c <= '~') {
          text += c;
        } else {

          const char *utf8 = s + i;
          int ucc = FromUTF8(&utf8);
          if (ucc < 0) {
            if (allow_non_utf8) {
              text += "\\x";
              text += IntToStringHex(static_cast<uint8_t>(c), 2);
            } else {
# 616 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/util.h"
              return false;
            }
          } else {
            if (natural_utf8) {

              text.append(s + i, static_cast<size_t>(utf8 - s - i));
            } else if (ucc <= 0xFFFF) {

              text += "\\u";
              text += IntToStringHex(ucc, 4);
            } else if (ucc <= 0x10FFFF) {


              uint32_t base = ucc - 0x10000;
              auto high_surrogate = (base >> 10) + 0xD800;
              auto low_surrogate = (base & 0x03FF) + 0xDC00;
              text += "\\u";
              text += IntToStringHex(high_surrogate, 4);
              text += "\\u";
              text += IntToStringHex(low_surrogate, 4);
            }

            i = static_cast<uoffset_t>(utf8 - s - 1);
          }
        }
        break;
    }
  }
  text += "\"";
  return true;
}

inline std::string BufferToHexText(const void *buffer, size_t buffer_size,
                                   size_t max_length,
                                   const std::string &wrapped_line_prefix,
                                   const std::string &wrapped_line_suffix) {
  std::string text = wrapped_line_prefix;
  size_t start_offset = 0;
  const char *s = reinterpret_cast<const char *>(buffer);
  for (size_t i = 0; s && i < buffer_size; i++) {

    bool have_more = i + 1 < buffer_size;
    text += "0x";
    text += IntToStringHex(static_cast<uint8_t>(s[i]), 2);
    if (have_more) { text += ','; }

    if (have_more &&
        text.size() + wrapped_line_suffix.size() >= start_offset + max_length) {
      text += wrapped_line_suffix;
      text += '\n';
      start_offset = text.size();
      text += wrapped_line_prefix;
    }
  }
  text += wrapped_line_suffix;
  return text;
}


std::string RemoveStringQuotes(const std::string &s);




bool SetGlobalTestLocale(const char *locale_name,
                         std::string *_value = nullptr);


bool ReadEnvironmentVariable(const char *var_name,
                             std::string *_value = nullptr);


void SetupDefaultCRTReportMode();

}
# 25 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h" 2
# 35 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
namespace flexbuffers {

class Reference;
class Map;



enum BitWidth {
  BIT_WIDTH_8 = 0,
  BIT_WIDTH_16 = 1,
  BIT_WIDTH_32 = 2,
  BIT_WIDTH_64 = 3,
};



enum Type {
  FBT_NULL = 0,
  FBT_INT = 1,
  FBT_UINT = 2,
  FBT_FLOAT = 3,

  FBT_KEY = 4,
  FBT_STRING = 5,
  FBT_INDIRECT_INT = 6,
  FBT_INDIRECT_UINT = 7,
  FBT_INDIRECT_FLOAT = 8,
  FBT_MAP = 9,
  FBT_VECTOR = 10,
  FBT_VECTOR_INT = 11,
  FBT_VECTOR_UINT = 12,
  FBT_VECTOR_FLOAT = 13,
  FBT_VECTOR_KEY = 14,


  FBT_VECTOR_STRING_DEPRECATED = 15,
  FBT_VECTOR_INT2 = 16,
  FBT_VECTOR_UINT2 = 17,
  FBT_VECTOR_FLOAT2 = 18,
  FBT_VECTOR_INT3 = 19,
  FBT_VECTOR_UINT3 = 20,
  FBT_VECTOR_FLOAT3 = 21,
  FBT_VECTOR_INT4 = 22,
  FBT_VECTOR_UINT4 = 23,
  FBT_VECTOR_FLOAT4 = 24,
  FBT_BLOB = 25,
  FBT_BOOL = 26,
  FBT_VECTOR_BOOL =
      36,
};

inline bool IsInline(Type t) { return t <= FBT_FLOAT || t == FBT_BOOL; }

inline bool IsTypedVectorElementType(Type t) {
  return (t >= FBT_INT && t <= FBT_STRING) || t == FBT_BOOL;
}

inline bool IsTypedVector(Type t) {
  return (t >= FBT_VECTOR_INT && t <= FBT_VECTOR_STRING_DEPRECATED) ||
         t == FBT_VECTOR_BOOL;
}

inline bool IsFixedTypedVector(Type t) {
  return t >= FBT_VECTOR_INT2 && t <= FBT_VECTOR_FLOAT4;
}

inline Type ToTypedVector(Type t, size_t fixed_len = 0) {
  ((IsTypedVectorElementType(t)) ? (void)0 : std:: __aeabi_assert("IsTypedVectorElementType(t)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 102),
# 102 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 102 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 102 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((IsTypedVectorElementType(t))?1:0)
# 102 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 102 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
  switch (fixed_len) {
    case 0: return static_cast<Type>(t - FBT_INT + FBT_VECTOR_INT);
    case 2: return static_cast<Type>(t - FBT_INT + FBT_VECTOR_INT2);
    case 3: return static_cast<Type>(t - FBT_INT + FBT_VECTOR_INT3);
    case 4: return static_cast<Type>(t - FBT_INT + FBT_VECTOR_INT4);
    default: ((0) ? (void)0 : std:: __aeabi_assert("0", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 108),
# 108 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 108 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 108 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((0)?1:0)
# 108 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 108 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
); return FBT_NULL;
  }
}

inline Type ToTypedVectorElementType(Type t) {
  ((IsTypedVector(t)) ? (void)0 : std:: __aeabi_assert("IsTypedVector(t)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 113),
# 113 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 113 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 113 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((IsTypedVector(t))?1:0)
# 113 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 113 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
  return static_cast<Type>(t - FBT_VECTOR_INT + FBT_INT);
}

inline Type ToFixedTypedVectorElementType(Type t, uint8_t *len) {
  ((IsFixedTypedVector(t)) ? (void)0 : std:: __aeabi_assert("IsFixedTypedVector(t)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 118),
# 118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((IsFixedTypedVector(t))?1:0)
# 118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
  auto fixed_type = t - FBT_VECTOR_INT2;
  *len = static_cast<uint8_t>(fixed_type / 3 +
                              2);
  return static_cast<Type>(fixed_type % 3 + FBT_INT);
}



typedef int16_t half;
typedef int8_t quarter;






template<typename R, typename T1, typename T2, typename T4, typename T8>
R ReadSizedScalar(const uint8_t *data, uint8_t byte_width) {
  return byte_width < 4
             ? (byte_width < 2
                    ? static_cast<R>(flatbuffers::ReadScalar<T1>(data))
                    : static_cast<R>(flatbuffers::ReadScalar<T2>(data)))
             : (byte_width < 8
                    ? static_cast<R>(flatbuffers::ReadScalar<T4>(data))
                    : static_cast<R>(flatbuffers::ReadScalar<T8>(data)));
}

inline int64_t ReadInt64(const uint8_t *data, uint8_t byte_width) {
  return ReadSizedScalar<int64_t, int8_t, int16_t, int32_t, int64_t>(
      data, byte_width);
}

inline uint64_t ReadUInt64(const uint8_t *data, uint8_t byte_width) {
# 164 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
    return ReadSizedScalar<uint64_t, uint8_t, uint16_t, uint32_t, uint64_t>(
             data, byte_width);


}

inline double ReadDouble(const uint8_t *data, uint8_t byte_width) {
  return ReadSizedScalar<double, quarter, half, float, double>(data,
                                                               byte_width);
}

inline const uint8_t *Indirect(const uint8_t *offset, uint8_t byte_width) {
  return offset - ReadUInt64(offset, byte_width);
}

template<typename T> const uint8_t *Indirect(const uint8_t *offset) {
  return offset - flatbuffers::ReadScalar<T>(offset);
}

inline BitWidth WidthU(uint64_t u) {




  { if (!((u) & ~((1ULL << (8)) - 1ULL))) return BIT_WIDTH_8; };
  { if (!((u) & ~((1ULL << (16)) - 1ULL))) return BIT_WIDTH_16; };
  { if (!((u) & ~((1ULL << (32)) - 1ULL))) return BIT_WIDTH_32; };

  return BIT_WIDTH_64;
}

inline BitWidth WidthI(int64_t i) {
  auto u = static_cast<uint64_t>(i) << 1;
  return WidthU(i >= 0 ? u : ~u);
}

inline BitWidth WidthF(double f) {
  return static_cast<double>(static_cast<float>(f)) == f ? BIT_WIDTH_32
                                                         : BIT_WIDTH_64;
}



class Object {
 public:
  Object(const uint8_t *data, uint8_t byte_width)
      : data_(data), byte_width_(byte_width) {}

 protected:
  const uint8_t *data_;
  uint8_t byte_width_;
};


class Sized : public Object {
 public:

  Sized(const uint8_t *data, uint8_t byte_width)
      : Object(data, byte_width), size_(read_size()) {}

  Sized(const uint8_t *data, uint8_t byte_width, size_t sz)
      : Object(data, byte_width), size_(sz) {}
  size_t size() const { return size_; }

  size_t read_size() const {
    return static_cast<size_t>(ReadUInt64(data_ - byte_width_, byte_width_));
  }

 protected:
  size_t size_;
};

class String : public Sized {
 public:

  String(const uint8_t *data, uint8_t byte_width) : Sized(data, byte_width) {}

  String(const uint8_t *data, uint8_t byte_width, size_t sz)
      : Sized(data, byte_width, sz) {}

  size_t length() const { return size(); }
  const char *c_str() const { return reinterpret_cast<const char *>(data_); }
  std::string str() const { return std::string(c_str(), size()); }

  static String EmptyString() {
    static const char *empty_string = "";
    return String(reinterpret_cast<const uint8_t *>(empty_string), 1, 0);
  }
  bool IsTheEmptyString() const { return data_ == EmptyString().data_; }
};

class Blob : public Sized {
 public:
  Blob(const uint8_t *data_buf, uint8_t byte_width)
      : Sized(data_buf, byte_width) {}

  static Blob EmptyBlob() {
    static const uint8_t empty_blob[] = { 0 };
    return Blob(empty_blob + 1, 1);
  }
  bool IsTheEmptyBlob() const { return data_ == EmptyBlob().data_; }
  const uint8_t *data() const { return data_; }
};

class Vector : public Sized {
 public:
  Vector(const uint8_t *data, uint8_t byte_width) : Sized(data, byte_width) {}

  Reference operator[](size_t i) const;

  static Vector EmptyVector() {
    static const uint8_t empty_vector[] = { 0 };
    return Vector(empty_vector + 1, 1);
  }
  bool IsTheEmptyVector() const { return data_ == EmptyVector().data_; }
};

class TypedVector : public Sized {
 public:
  TypedVector(const uint8_t *data, uint8_t byte_width, Type element_type)
      : Sized(data, byte_width), type_(element_type) {}

  Reference operator[](size_t i) const;

  static TypedVector EmptyTypedVector() {
    static const uint8_t empty_typed_vector[] = { 0 };
    return TypedVector(empty_typed_vector + 1, 1, FBT_INT);
  }
  bool IsTheEmptyVector() const {
    return data_ == TypedVector::EmptyTypedVector().data_;
  }

  Type ElementType() { return type_; }

  friend Reference;

 private:
  Type type_;

  friend Map;
};

class FixedTypedVector : public Object {
 public:
  FixedTypedVector(const uint8_t *data, uint8_t byte_width, Type element_type,
                   uint8_t len)
      : Object(data, byte_width), type_(element_type), len_(len) {}

  Reference operator[](size_t i) const;

  static FixedTypedVector EmptyFixedTypedVector() {
    static const uint8_t fixed_empty_vector[] = { 0 };
    return FixedTypedVector(fixed_empty_vector, 1, FBT_INT, 0);
  }
  bool IsTheEmptyFixedTypedVector() const {
    return data_ == FixedTypedVector::EmptyFixedTypedVector().data_;
  }

  Type ElementType() { return type_; }
  uint8_t size() { return len_; }

 private:
  Type type_;
  uint8_t len_;
};

class Map : public Vector {
 public:
  Map(const uint8_t *data, uint8_t byte_width) : Vector(data, byte_width) {}

  Reference operator[](const char *key) const;
  Reference operator[](const std::string &key) const;

  Vector Values() const { return Vector(data_, byte_width_); }

  TypedVector Keys() const {
    const size_t num_prefixed_fields = 3;
    auto keys_offset = data_ - byte_width_ * num_prefixed_fields;
    return TypedVector(Indirect(keys_offset, byte_width_),
                       static_cast<uint8_t>(
                           ReadUInt64(keys_offset + byte_width_, byte_width_)),
                       FBT_KEY);
  }

  static Map EmptyMap() {
    static const uint8_t empty_map[] = {
      0 , 0 , 1 , 0
    };
    return Map(empty_map + 4, 1);
  }

  bool IsTheEmptyMap() const { return data_ == EmptyMap().data_; }
};

template<typename T>
void AppendToString(std::string &s, T &&v, bool keys_quoted) {
  s += "[ ";
  for (size_t i = 0; i < v.size(); i++) {
    if (i) s += ", ";
    v[i].ToString(true, keys_quoted, s);
  }
  s += " ]";
}

class Reference {
 public:
  Reference()
      : data_(nullptr),
        parent_width_(0),
        byte_width_(BIT_WIDTH_8),
        type_(FBT_NULL) {}

  Reference(const uint8_t *data, uint8_t parent_width, uint8_t byte_width,
            Type type)
      : data_(data),
        parent_width_(parent_width),
        byte_width_(byte_width),
        type_(type) {}

  Reference(const uint8_t *data, uint8_t parent_width, uint8_t packed_type)
      : data_(data), parent_width_(parent_width) {
    byte_width_ = 1U << static_cast<BitWidth>(packed_type & 3);
    type_ = static_cast<Type>(packed_type >> 2);
  }

  Type GetType() const { return type_; }

  bool IsNull() const { return type_ == FBT_NULL; }
  bool IsBool() const { return type_ == FBT_BOOL; }
  bool IsInt() const { return type_ == FBT_INT || type_ == FBT_INDIRECT_INT; }
  bool IsUInt() const {
    return type_ == FBT_UINT || type_ == FBT_INDIRECT_UINT;
  }
  bool IsIntOrUint() const { return IsInt() || IsUInt(); }
  bool IsFloat() const {
    return type_ == FBT_FLOAT || type_ == FBT_INDIRECT_FLOAT;
  }
  bool IsNumeric() const { return IsIntOrUint() || IsFloat(); }
  bool IsString() const { return type_ == FBT_STRING; }
  bool IsKey() const { return type_ == FBT_KEY; }
  bool IsVector() const { return type_ == FBT_VECTOR || type_ == FBT_MAP; }
  bool IsUntypedVector() const { return type_ == FBT_VECTOR; }
  bool IsTypedVector() const { return flexbuffers::IsTypedVector(type_); }
  bool IsFixedTypedVector() const {
    return flexbuffers::IsFixedTypedVector(type_);
  }
  bool IsAnyVector() const {
    return (IsTypedVector() || IsFixedTypedVector() || IsVector());
  }
  bool IsMap() const { return type_ == FBT_MAP; }
  bool IsBlob() const { return type_ == FBT_BLOB; }
  bool AsBool() const {
    return (type_ == FBT_BOOL ? ReadUInt64(data_, parent_width_)
                              : AsUInt64()) != 0;
  }




  int64_t AsInt64() const {
    if (type_ == FBT_INT) {

      return ReadInt64(data_, parent_width_);
    } else
      switch (type_) {
        case FBT_INDIRECT_INT: return ReadInt64(Indirect(), byte_width_);
        case FBT_UINT: return ReadUInt64(data_, parent_width_);
        case FBT_INDIRECT_UINT: return ReadUInt64(Indirect(), byte_width_);
        case FBT_FLOAT:
          return static_cast<int64_t>(ReadDouble(data_, parent_width_));
        case FBT_INDIRECT_FLOAT:
          return static_cast<int64_t>(ReadDouble(Indirect(), byte_width_));
        case FBT_NULL: return 0;
        case FBT_STRING: return flatbuffers::StringToInt(AsString().c_str());
        case FBT_VECTOR: return static_cast<int64_t>(AsVector().size());
        case FBT_BOOL: return ReadInt64(data_, parent_width_);
        default:

          return 0;
      }
  }



  int32_t AsInt32() const { return static_cast<int32_t>(AsInt64()); }
  int16_t AsInt16() const { return static_cast<int16_t>(AsInt64()); }
  int8_t AsInt8() const { return static_cast<int8_t>(AsInt64()); }

  uint64_t AsUInt64() const {
    if (type_ == FBT_UINT) {

      return ReadUInt64(data_, parent_width_);
    } else
      switch (type_) {
        case FBT_INDIRECT_UINT: return ReadUInt64(Indirect(), byte_width_);
        case FBT_INT: return ReadInt64(data_, parent_width_);
        case FBT_INDIRECT_INT: return ReadInt64(Indirect(), byte_width_);
        case FBT_FLOAT:
          return static_cast<uint64_t>(ReadDouble(data_, parent_width_));
        case FBT_INDIRECT_FLOAT:
          return static_cast<uint64_t>(ReadDouble(Indirect(), byte_width_));
        case FBT_NULL: return 0;
        case FBT_STRING: return flatbuffers::StringToUInt(AsString().c_str());
        case FBT_VECTOR: return static_cast<uint64_t>(AsVector().size());
        case FBT_BOOL: return ReadUInt64(data_, parent_width_);
        default:

          return 0;
      }
  }

  uint32_t AsUInt32() const { return static_cast<uint32_t>(AsUInt64()); }
  uint16_t AsUInt16() const { return static_cast<uint16_t>(AsUInt64()); }
  uint8_t AsUInt8() const { return static_cast<uint8_t>(AsUInt64()); }

  double AsDouble() const {
    if (type_ == FBT_FLOAT) {

      return ReadDouble(data_, parent_width_);
    } else
      switch (type_) {
        case FBT_INDIRECT_FLOAT: return ReadDouble(Indirect(), byte_width_);
        case FBT_INT:
          return static_cast<double>(ReadInt64(data_, parent_width_));
        case FBT_UINT:
          return static_cast<double>(ReadUInt64(data_, parent_width_));
        case FBT_INDIRECT_INT:
          return static_cast<double>(ReadInt64(Indirect(), byte_width_));
        case FBT_INDIRECT_UINT:
          return static_cast<double>(ReadUInt64(Indirect(), byte_width_));
        case FBT_NULL: return 0.0;
        case FBT_STRING: {
          double d;
          flatbuffers::StringToNumber(AsString().c_str(), &d);
          return d;
        }
        case FBT_VECTOR: return static_cast<double>(AsVector().size());
        case FBT_BOOL:
          return static_cast<double>(ReadUInt64(data_, parent_width_));
        default:

          return 0;
      }
  }

  float AsFloat() const { return static_cast<float>(AsDouble()); }

  const char *AsKey() const {
    if (type_ == FBT_KEY || type_ == FBT_STRING) {
      return reinterpret_cast<const char *>(Indirect());
    } else {
      return "";
    }
  }



  String AsString() const {
    if (type_ == FBT_STRING) {
      return String(Indirect(), byte_width_);
    } else if (type_ == FBT_KEY) {
      auto key = Indirect();
      return String(key, byte_width_,
                    strlen(reinterpret_cast<const char *>(key)));
    } else {
      return String::EmptyString();
    }
  }


  std::string ToString() const {
    std::string s;
    ToString(false, false, s);
    return s;
  }





  void ToString(bool strings_quoted, bool keys_quoted, std::string &s) const {
    if (type_ == FBT_STRING) {
      String str(Indirect(), byte_width_);
      if (strings_quoted) {
        flatbuffers::EscapeString(str.c_str(), str.length(), &s, true, false);
      } else {
        s.append(str.c_str(), str.length());
      }
    } else if (IsKey()) {
      auto str = AsKey();
      if (keys_quoted) {
        flatbuffers::EscapeString(str, strlen(str), &s, true, false);
      } else {
        s += str;
      }
    } else if (IsInt()) {
      s += flatbuffers::NumToString(AsInt64());
    } else if (IsUInt()) {
      s += flatbuffers::NumToString(AsUInt64());
    } else if (IsFloat()) {
      s += flatbuffers::NumToString(AsDouble());
    } else if (IsNull()) {
      s += "null";
    } else if (IsBool()) {
      s += AsBool() ? "true" : "false";
    } else if (IsMap()) {
      s += "{ ";
      auto m = AsMap();
      auto keys = m.Keys();
      auto vals = m.Values();
      for (size_t i = 0; i < keys.size(); i++) {
        keys[i].ToString(true, keys_quoted, s);
        s += ": ";
        vals[i].ToString(true, keys_quoted, s);
        if (i < keys.size() - 1) s += ", ";
      }
      s += " }";
    } else if (IsVector()) {
      AppendToString<Vector>(s, AsVector(), keys_quoted);
    } else if (IsTypedVector()) {
      AppendToString<TypedVector>(s, AsTypedVector(), keys_quoted);
    } else if (IsFixedTypedVector()) {
      AppendToString<FixedTypedVector>(s, AsFixedTypedVector(), keys_quoted);
    } else if (IsBlob()) {
      auto blob = AsBlob();
      flatbuffers::EscapeString(reinterpret_cast<const char *>(blob.data()),
                                blob.size(), &s, true, false);
    } else {
      s += "(?)";
    }
  }



  Blob AsBlob() const {
    if (type_ == FBT_BLOB || type_ == FBT_STRING) {
      return Blob(Indirect(), byte_width_);
    } else {
      return Blob::EmptyBlob();
    }
  }



  Vector AsVector() const {
    if (type_ == FBT_VECTOR || type_ == FBT_MAP) {
      return Vector(Indirect(), byte_width_);
    } else {
      return Vector::EmptyVector();
    }
  }

  TypedVector AsTypedVector() const {
    if (IsTypedVector()) {
      auto tv =
          TypedVector(Indirect(), byte_width_, ToTypedVectorElementType(type_));
      if (tv.type_ == FBT_STRING) {






        tv.type_ = FBT_KEY;
      }
      return tv;
    } else {
      return TypedVector::EmptyTypedVector();
    }
  }

  FixedTypedVector AsFixedTypedVector() const {
    if (IsFixedTypedVector()) {
      uint8_t len = 0;
      auto vtype = ToFixedTypedVectorElementType(type_, &len);
      return FixedTypedVector(Indirect(), byte_width_, vtype, len);
    } else {
      return FixedTypedVector::EmptyFixedTypedVector();
    }
  }

  Map AsMap() const {
    if (type_ == FBT_MAP) {
      return Map(Indirect(), byte_width_);
    } else {
      return Map::EmptyMap();
    }
  }

  template<typename T> T As() const;







  bool MutateInt(int64_t i) {
    if (type_ == FBT_INT) {
      return Mutate(data_, i, parent_width_, WidthI(i));
    } else if (type_ == FBT_INDIRECT_INT) {
      return Mutate(Indirect(), i, byte_width_, WidthI(i));
    } else if (type_ == FBT_UINT) {
      auto u = static_cast<uint64_t>(i);
      return Mutate(data_, u, parent_width_, WidthU(u));
    } else if (type_ == FBT_INDIRECT_UINT) {
      auto u = static_cast<uint64_t>(i);
      return Mutate(Indirect(), u, byte_width_, WidthU(u));
    } else {
      return false;
    }
  }

  bool MutateBool(bool b) {
    return type_ == FBT_BOOL && Mutate(data_, b, parent_width_, BIT_WIDTH_8);
  }

  bool MutateUInt(uint64_t u) {
    if (type_ == FBT_UINT) {
      return Mutate(data_, u, parent_width_, WidthU(u));
    } else if (type_ == FBT_INDIRECT_UINT) {
      return Mutate(Indirect(), u, byte_width_, WidthU(u));
    } else if (type_ == FBT_INT) {
      auto i = static_cast<int64_t>(u);
      return Mutate(data_, i, parent_width_, WidthI(i));
    } else if (type_ == FBT_INDIRECT_INT) {
      auto i = static_cast<int64_t>(u);
      return Mutate(Indirect(), i, byte_width_, WidthI(i));
    } else {
      return false;
    }
  }

  bool MutateFloat(float f) {
    if (type_ == FBT_FLOAT) {
      return MutateF(data_, f, parent_width_, BIT_WIDTH_32);
    } else if (type_ == FBT_INDIRECT_FLOAT) {
      return MutateF(Indirect(), f, byte_width_, BIT_WIDTH_32);
    } else {
      return false;
    }
  }

  bool MutateFloat(double d) {
    if (type_ == FBT_FLOAT) {
      return MutateF(data_, d, parent_width_, WidthF(d));
    } else if (type_ == FBT_INDIRECT_FLOAT) {
      return MutateF(Indirect(), d, byte_width_, WidthF(d));
    } else {
      return false;
    }
  }

  bool MutateString(const char *str, size_t len) {
    auto s = AsString();
    if (s.IsTheEmptyString()) return false;


    if (s.length() != len) return false;
    memcpy(const_cast<char *>(s.c_str()), str, len);
    return true;
  }
  bool MutateString(const char *str) { return MutateString(str, strlen(str)); }
  bool MutateString(const std::string &str) {
    return MutateString(str.data(), str.length());
  }

 private:
  const uint8_t *Indirect() const {
    return flexbuffers::Indirect(data_, parent_width_);
  }

  template<typename T>
  bool Mutate(const uint8_t *dest, T t, size_t byte_width,
              BitWidth value_width) {
    auto fits = static_cast<size_t>(static_cast<size_t>(1U) << value_width) <=
                byte_width;
    if (fits) {
      t = flatbuffers::EndianScalar(t);
      memcpy(const_cast<uint8_t *>(dest), &t, byte_width);
    }
    return fits;
  }

  template<typename T>
  bool MutateF(const uint8_t *dest, T t, size_t byte_width,
               BitWidth value_width) {
    if (byte_width == sizeof(double))
      return Mutate(dest, static_cast<double>(t), byte_width, value_width);
    if (byte_width == sizeof(float))
      return Mutate(dest, static_cast<float>(t), byte_width, value_width);
    ((false) ? (void)0 : std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 755),
# 755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((false)?1:0)
# 755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 755 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    return false;
  }

  const uint8_t *data_;
  uint8_t parent_width_;
  uint8_t byte_width_;
  Type type_;
};


template<> inline bool Reference::As<bool>() const { return AsBool(); }

template<> inline int8_t Reference::As<int8_t>() const { return AsInt8(); }
template<> inline int16_t Reference::As<int16_t>() const { return AsInt16(); }
template<> inline int32_t Reference::As<int32_t>() const { return AsInt32(); }
template<> inline int64_t Reference::As<int64_t>() const { return AsInt64(); }

template<> inline uint8_t Reference::As<uint8_t>() const { return AsUInt8(); }
template<> inline uint16_t Reference::As<uint16_t>() const {
  return AsUInt16();
}
template<> inline uint32_t Reference::As<uint32_t>() const {
  return AsUInt32();
}
template<> inline uint64_t Reference::As<uint64_t>() const {
  return AsUInt64();
}

template<> inline double Reference::As<double>() const { return AsDouble(); }
template<> inline float Reference::As<float>() const { return AsFloat(); }

template<> inline String Reference::As<String>() const { return AsString(); }
template<> inline std::string Reference::As<std::string>() const {
  return AsString().str();
}

template<> inline Blob Reference::As<Blob>() const { return AsBlob(); }
template<> inline Vector Reference::As<Vector>() const { return AsVector(); }
template<> inline TypedVector Reference::As<TypedVector>() const {
  return AsTypedVector();
}
template<> inline FixedTypedVector Reference::As<FixedTypedVector>() const {
  return AsFixedTypedVector();
}
template<> inline Map Reference::As<Map>() const { return AsMap(); }

inline uint8_t PackedType(BitWidth bit_width, Type type) {
  return static_cast<uint8_t>(bit_width | (type << 2));
}

inline uint8_t NullPackedType() { return PackedType(BIT_WIDTH_8, FBT_NULL); }
# 815 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
inline Reference Vector::operator[](size_t i) const {
  auto len = size();
  if (i >= len) return Reference(nullptr, 1, NullPackedType());
  auto packed_type = (data_ + len * byte_width_)[i];
  auto elem = data_ + i * byte_width_;
  return Reference(elem, byte_width_, packed_type);
}

inline Reference TypedVector::operator[](size_t i) const {
  auto len = size();
  if (i >= len) return Reference(nullptr, 1, NullPackedType());
  auto elem = data_ + i * byte_width_;
  return Reference(elem, byte_width_, 1, type_);
}

inline Reference FixedTypedVector::operator[](size_t i) const {
  if (i >= len_) return Reference(nullptr, 1, NullPackedType());
  auto elem = data_ + i * byte_width_;
  return Reference(elem, byte_width_, 1, type_);
}

template<typename T> int KeyCompare(const void *key, const void *elem) {
  auto str_elem = reinterpret_cast<const char *>(
      Indirect<T>(reinterpret_cast<const uint8_t *>(elem)));
  auto skey = reinterpret_cast<const char *>(key);
  return strcmp(skey, str_elem);
}

inline Reference Map::operator[](const char *key) const {
  auto keys = Keys();


  int (*comp)(const void *, const void *) = nullptr;
  switch (keys.byte_width_) {
    case 1: comp = KeyCompare<uint8_t>; break;
    case 2: comp = KeyCompare<uint16_t>; break;
    case 4: comp = KeyCompare<uint32_t>; break;
    case 8: comp = KeyCompare<uint64_t>; break;
  }
  auto res = std::bsearch(key, keys.data_, keys.size(), keys.byte_width_, comp);
  if (!res) return Reference(nullptr, 1, NullPackedType());
  auto i = (reinterpret_cast<uint8_t *>(res) - keys.data_) / keys.byte_width_;
  return (*static_cast<const Vector *>(this))[i];
}

inline Reference Map::operator[](const std::string &key) const {
  return (*this)[key.c_str()];
}

inline Reference GetRoot(const uint8_t *buffer, size_t size) {


  auto end = buffer + size;
  auto byte_width = *--end;
  auto packed_type = *--end;
  end -= byte_width;
  return Reference(end, byte_width, packed_type);
}

inline Reference GetRoot(const std::vector<uint8_t> &buffer) {
  return GetRoot(flatbuffers::vector_data(buffer), buffer.size());
}
# 888 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
enum BuilderFlag {
  BUILDER_FLAG_NONE = 0,
  BUILDER_FLAG_SHARE_KEYS = 1,
  BUILDER_FLAG_SHARE_STRINGS = 2,
  BUILDER_FLAG_SHARE_KEYS_AND_STRINGS = 3,
  BUILDER_FLAG_SHARE_KEY_VECTORS = 4,
  BUILDER_FLAG_SHARE_ALL = 7,
};

class Builder final {
 public:
  Builder(size_t initial_size = 256,
          BuilderFlag flags = BUILDER_FLAG_SHARE_KEYS)
      : buf_(initial_size),
        finished_(false),
        flags_(flags),
        force_min_bit_width_(BIT_WIDTH_8),
        key_pool(KeyOffsetCompare(buf_)),
        string_pool(StringOffsetCompare(buf_)) {
    buf_.clear();
  }



  const std::vector<uint8_t> &GetBuffer() const {
    Finished();
    return buf_;
  }


  size_t GetSize() const { return buf_.size(); }


  void Clear() {
    buf_.clear();
    stack_.clear();
    finished_ = false;

    force_min_bit_width_ = BIT_WIDTH_8;
    key_pool.clear();
    string_pool.clear();
  }





  void Null() { stack_.push_back(Value()); }
  void Null(const char *key) {
    Key(key);
    Null();
  }

  void Int(int64_t i) { stack_.push_back(Value(i, FBT_INT, WidthI(i))); }
  void Int(const char *key, int64_t i) {
    Key(key);
    Int(i);
  }

  void UInt(uint64_t u) { stack_.push_back(Value(u, FBT_UINT, WidthU(u))); }
  void UInt(const char *key, uint64_t u) {
    Key(key);
    UInt(u);
  }

  void Float(float f) { stack_.push_back(Value(f)); }
  void Float(const char *key, float f) {
    Key(key);
    Float(f);
  }

  void Double(double f) { stack_.push_back(Value(f)); }
  void Double(const char *key, double d) {
    Key(key);
    Double(d);
  }

  void Bool(bool b) { stack_.push_back(Value(b)); }
  void Bool(const char *key, bool b) {
    Key(key);
    Bool(b);
  }

  void IndirectInt(int64_t i) { PushIndirect(i, FBT_INDIRECT_INT, WidthI(i)); }
  void IndirectInt(const char *key, int64_t i) {
    Key(key);
    IndirectInt(i);
  }

  void IndirectUInt(uint64_t u) {
    PushIndirect(u, FBT_INDIRECT_UINT, WidthU(u));
  }
  void IndirectUInt(const char *key, uint64_t u) {
    Key(key);
    IndirectUInt(u);
  }

  void IndirectFloat(float f) {
    PushIndirect(f, FBT_INDIRECT_FLOAT, BIT_WIDTH_32);
  }
  void IndirectFloat(const char *key, float f) {
    Key(key);
    IndirectFloat(f);
  }

  void IndirectDouble(double f) {
    PushIndirect(f, FBT_INDIRECT_FLOAT, WidthF(f));
  }
  void IndirectDouble(const char *key, double d) {
    Key(key);
    IndirectDouble(d);
  }

  size_t Key(const char *str, size_t len) {
    auto sloc = buf_.size();
    WriteBytes(str, len + 1);
    if (flags_ & BUILDER_FLAG_SHARE_KEYS) {
      auto it = key_pool.find(sloc);
      if (it != key_pool.end()) {


        buf_.resize(sloc);
        sloc = *it;
      } else {
        key_pool.insert(sloc);
      }
    }
    stack_.push_back(Value(static_cast<uint64_t>(sloc), FBT_KEY, BIT_WIDTH_8));
    return sloc;
  }

  size_t Key(const char *str) { return Key(str, strlen(str)); }
  size_t Key(const std::string &str) { return Key(str.c_str(), str.size()); }

  size_t String(const char *str, size_t len) {
    auto reset_to = buf_.size();
    auto sloc = CreateBlob(str, len, 1, FBT_STRING);
    if (flags_ & BUILDER_FLAG_SHARE_STRINGS) {
      StringOffset so(sloc, len);
      auto it = string_pool.find(so);
      if (it != string_pool.end()) {


        buf_.resize(reset_to);
        sloc = it->first;
        stack_.back().u_ = sloc;
      } else {
        string_pool.insert(so);
      }
    }
    return sloc;
  }
  size_t String(const char *str) { return String(str, strlen(str)); }
  size_t String(const std::string &str) {
    return String(str.c_str(), str.size());
  }
  void String(const flexbuffers::String &str) {
    String(str.c_str(), str.length());
  }

  void String(const char *key, const char *str) {
    Key(key);
    String(str);
  }
  void String(const char *key, const std::string &str) {
    Key(key);
    String(str);
  }
  void String(const char *key, const flexbuffers::String &str) {
    Key(key);
    String(str);
  }

  size_t Blob(const void *data, size_t len) {
    return CreateBlob(data, len, 0, FBT_BLOB);
  }
  size_t Blob(const std::vector<uint8_t> &v) {
    return CreateBlob(flatbuffers::vector_data(v), v.size(), 0, FBT_BLOB);
  }





  size_t StartVector() { return stack_.size(); }
  size_t StartVector(const char *key) {
    Key(key);
    return stack_.size();
  }
  size_t StartMap() { return stack_.size(); }
  size_t StartMap(const char *key) {
    Key(key);
    return stack_.size();
  }



  size_t EndVector(size_t start, bool typed, bool fixed) {
    auto vec = CreateVector(start, stack_.size() - start, 1, typed, fixed);

    stack_.resize(start);
    stack_.push_back(vec);
    return static_cast<size_t>(vec.u_);
  }

  size_t EndMap(size_t start) {


    auto len = stack_.size() - start;
    ((!(len & 1)) ? (void)0 : std:: __aeabi_assert("!(len & 1)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1097),
# 1097 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1097 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1097 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((!(len & 1))?1:0)
# 1097 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1097 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    len /= 2;

    for (auto key = start; key < stack_.size(); key += 2) {
      ((stack_[key].type_ == FBT_KEY) ? (void)0 : std:: __aeabi_assert("stack_[key].type_ == FBT_KEY", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1101),
# 1101 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1101 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1101 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((stack_[key].type_ == FBT_KEY)?1:0)
# 1101 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1101 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    }


    struct TwoValue {
      Value key;
      Value val;
    };
# 1118 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
    auto dict =
        reinterpret_cast<TwoValue *>(flatbuffers::vector_data(stack_) + start);
    std::sort(dict, dict + len,
              [&](const TwoValue &a, const TwoValue &b) -> bool {
                auto as = reinterpret_cast<const char *>(
                    flatbuffers::vector_data(buf_) + a.key.u_);
                auto bs = reinterpret_cast<const char *>(
                    flatbuffers::vector_data(buf_) + b.key.u_);
                auto comp = strcmp(as, bs);





                ((comp || &a == &b) ? (void)0 : std:: __aeabi_assert("comp || &a == &b", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1132),
# 1132 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1132 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1132 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((comp || &a == &b)?1:0)
# 1132 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1132 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
                return comp < 0;
              });



    auto keys = CreateVector(start, len, 2, true, false);
    auto vec = CreateVector(start + 1, len, 2, false, false, &keys);

    stack_.resize(start);
    stack_.push_back(vec);
    return static_cast<size_t>(vec.u_);
  }

  template<typename F> size_t Vector(F f) {
    auto start = StartVector();
    f();
    return EndVector(start, false, false);
  }
  template<typename F, typename T> size_t Vector(F f, T &state) {
    auto start = StartVector();
    f(state);
    return EndVector(start, false, false);
  }
  template<typename F> size_t Vector(const char *key, F f) {
    auto start = StartVector(key);
    f();
    return EndVector(start, false, false);
  }
  template<typename F, typename T>
  size_t Vector(const char *key, F f, T &state) {
    auto start = StartVector(key);
    f(state);
    return EndVector(start, false, false);
  }

  template<typename T> void Vector(const T *elems, size_t len) {
    if (flatbuffers::is_scalar<T>::value) {

      ScalarVector(elems, len, false);
    } else {
      auto start = StartVector();
      for (size_t i = 0; i < len; i++) Add(elems[i]);
      EndVector(start, false, false);
    }
  }
  template<typename T>
  void Vector(const char *key, const T *elems, size_t len) {
    Key(key);
    Vector(elems, len);
  }
  template<typename T> void Vector(const std::vector<T> &vec) {
    Vector(flatbuffers::vector_data(vec), vec.size());
  }

  template<typename F> size_t TypedVector(F f) {
    auto start = StartVector();
    f();
    return EndVector(start, true, false);
  }
  template<typename F, typename T> size_t TypedVector(F f, T &state) {
    auto start = StartVector();
    f(state);
    return EndVector(start, true, false);
  }
  template<typename F> size_t TypedVector(const char *key, F f) {
    auto start = StartVector(key);
    f();
    return EndVector(start, true, false);
  }
  template<typename F, typename T>
  size_t TypedVector(const char *key, F f, T &state) {
    auto start = StartVector(key);
    f(state);
    return EndVector(start, true, false);
  }

  template<typename T> size_t FixedTypedVector(const T *elems, size_t len) {


    ((len >= 2 && len <= 4) ? (void)0 : std:: __aeabi_assert("len >= 2 && len <= 4", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1212),
# 1212 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1212 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1212 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((len >= 2 && len <= 4)?1:0)
# 1212 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1212 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);

    static_assert(flatbuffers::is_scalar<T>::value, "Unrelated types");
    return ScalarVector(elems, len, true);
  }

  template<typename T>
  size_t FixedTypedVector(const char *key, const T *elems, size_t len) {
    Key(key);
    return FixedTypedVector(elems, len);
  }

  template<typename F> size_t Map(F f) {
    auto start = StartMap();
    f();
    return EndMap(start);
  }
  template<typename F, typename T> size_t Map(F f, T &state) {
    auto start = StartMap();
    f(state);
    return EndMap(start);
  }
  template<typename F> size_t Map(const char *key, F f) {
    auto start = StartMap(key);
    f();
    return EndMap(start);
  }
  template<typename F, typename T> size_t Map(const char *key, F f, T &state) {
    auto start = StartMap(key);
    f(state);
    return EndMap(start);
  }
  template<typename T> void Map(const std::map<std::string, T> &map) {
    auto start = StartMap();
    for (auto it = map.begin(); it != map.end(); ++it)
      Add(it->first.c_str(), it->second);
    EndMap(start);
  }
# 1261 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
  struct Value;
  Value LastValue() { return stack_.back(); }
  void ReuseValue(Value v) { stack_.push_back(v); }
  void ReuseValue(const char *key, Value v) {
    Key(key);
    ReuseValue(v);
  }


  void Add(int8_t i) { Int(i); }
  void Add(int16_t i) { Int(i); }
  void Add(int32_t i) { Int(i); }
  void Add(int64_t i) { Int(i); }
  void Add(uint8_t u) { UInt(u); }
  void Add(uint16_t u) { UInt(u); }
  void Add(uint32_t u) { UInt(u); }
  void Add(uint64_t u) { UInt(u); }
  void Add(float f) { Float(f); }
  void Add(double d) { Double(d); }
  void Add(bool b) { Bool(b); }
  void Add(const char *str) { String(str); }
  void Add(const std::string &str) { String(str); }
  void Add(const flexbuffers::String &str) { String(str); }

  template<typename T> void Add(const std::vector<T> &vec) { Vector(vec); }

  template<typename T> void Add(const char *key, const T &t) {
    Key(key);
    Add(t);
  }

  template<typename T> void Add(const std::map<std::string, T> &map) {
    Map(map);
  }

  template<typename T> void operator+=(const T &t) { Add(t); }





  void ForceMinimumBitWidth(BitWidth bw = BIT_WIDTH_8) {
    force_min_bit_width_ = bw;
  }

  void Finish() {




    ((stack_.size() == 1) ? (void)0 : std:: __aeabi_assert("stack_.size() == 1", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1311),
# 1311 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1311 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1311 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((stack_.size() == 1)?1:0)
# 1311 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1311 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);


    auto byte_width = Align(stack_[0].ElemWidth(buf_.size(), 0));
    WriteAny(stack_[0], byte_width);

    Write(stack_[0].StoredPackedType(), 1);

    Write(byte_width, 1);

    finished_ = true;
  }

 private:
  void Finished() const {



    ((finished_) ? (void)0 : std:: __aeabi_assert("finished_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1329),
# 1329 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1329 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1329 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((finished_)?1:0)
# 1329 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1329 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
  }


  uint8_t Align(BitWidth alignment) {
    auto byte_width = 1U << alignment;
    buf_.insert(buf_.end(), flatbuffers::PaddingBytes(buf_.size(), byte_width),
                0);
    return static_cast<uint8_t>(byte_width);
  }

  void WriteBytes(const void *val, size_t size) {
    buf_.insert(buf_.end(), reinterpret_cast<const uint8_t *>(val),
                reinterpret_cast<const uint8_t *>(val) + size);
  }

  template<typename T> void Write(T val, size_t byte_width) {
    ((sizeof(T) >= byte_width) ? (void)0 : std:: __aeabi_assert("sizeof(T) >= byte_width", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1346),
# 1346 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1346 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1346 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((sizeof(T) >= byte_width)?1:0)
# 1346 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1346 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    val = flatbuffers::EndianScalar(val);
    WriteBytes(&val, byte_width);
  }

  void WriteDouble(double f, uint8_t byte_width) {
    switch (byte_width) {
      case 8: Write(f, byte_width); break;
      case 4: Write(static_cast<float>(f), byte_width); break;


      default: ((0) ? (void)0 : std:: __aeabi_assert("0", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1357),
# 1357 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1357 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1357 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((0)?1:0)
# 1357 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1357 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    }
  }

  void WriteOffset(uint64_t o, uint8_t byte_width) {
    auto reloff = buf_.size() - o;
    ((byte_width == 8 || reloff < 1ULL << (byte_width * 8)) ? (void)0 : std:: __aeabi_assert("byte_width == 8 || reloff < 1ULL << (byte_width * 8)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1363),
# 1363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((byte_width == 8 || reloff < 1ULL << (byte_width * 8))?1:0)
# 1363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1363 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    Write(reloff, byte_width);
  }

  template<typename T> void PushIndirect(T val, Type type, BitWidth bit_width) {
    auto byte_width = Align(bit_width);
    auto iloc = buf_.size();
    Write(val, byte_width);
    stack_.push_back(Value(static_cast<uint64_t>(iloc), type, bit_width));
  }

  static BitWidth WidthB(size_t byte_width) {
    switch (byte_width) {
      case 1: return BIT_WIDTH_8;
      case 2: return BIT_WIDTH_16;
      case 4: return BIT_WIDTH_32;
      case 8: return BIT_WIDTH_64;
      default: ((false) ? (void)0 : std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1380),
# 1380 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1380 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1380 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((false)?1:0)
# 1380 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1380 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
); return BIT_WIDTH_64;
    }
  }

  template<typename T> static Type GetScalarType() {
    static_assert(flatbuffers::is_scalar<T>::value, "Unrelated types");
    return flatbuffers::is_floating_point<T>::value
               ? FBT_FLOAT
               : flatbuffers::is_same<T, bool>::value
                     ? FBT_BOOL
                     : (flatbuffers::is_unsigned<T>::value ? FBT_UINT
                                                           : FBT_INT);
  }

 public:

  struct Value {
    union {
      int64_t i_;
      uint64_t u_;
      double f_;
    };

    Type type_;


    BitWidth min_bit_width_;

    Value() : i_(0), type_(FBT_NULL), min_bit_width_(BIT_WIDTH_8) {}

    Value(bool b)
        : u_(static_cast<uint64_t>(b)),
          type_(FBT_BOOL),
          min_bit_width_(BIT_WIDTH_8) {}

    Value(int64_t i, Type t, BitWidth bw)
        : i_(i), type_(t), min_bit_width_(bw) {}
    Value(uint64_t u, Type t, BitWidth bw)
        : u_(u), type_(t), min_bit_width_(bw) {}

    Value(float f)
        : f_(static_cast<double>(f)),
          type_(FBT_FLOAT),
          min_bit_width_(BIT_WIDTH_32) {}
    Value(double f) : f_(f), type_(FBT_FLOAT), min_bit_width_(WidthF(f)) {}

    uint8_t StoredPackedType(BitWidth parent_bit_width_ = BIT_WIDTH_8) const {
      return PackedType(StoredWidth(parent_bit_width_), type_);
    }

    BitWidth ElemWidth(size_t buf_size, size_t elem_index) const {
      if (IsInline(type_)) {
        return min_bit_width_;
      } else {





        for (size_t byte_width = 1;
             byte_width <= sizeof(flatbuffers::largest_scalar_t);
             byte_width *= 2) {

          auto offset_loc = buf_size +
                            flatbuffers::PaddingBytes(buf_size, byte_width) +
                            elem_index * byte_width;

          auto offset = offset_loc - u_;

          auto bit_width = WidthU(offset);
          if (static_cast<size_t>(static_cast<size_t>(1U) << bit_width) ==
              byte_width)
            return bit_width;
        }
        ((false) ? (void)0 : std:: __aeabi_assert("false", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1454),
# 1454 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1454 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1454 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((false)?1:0)
# 1454 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1454 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
        return BIT_WIDTH_64;
      }
    }

    BitWidth StoredWidth(BitWidth parent_bit_width_ = BIT_WIDTH_8) const {
      if (IsInline(type_)) {
        return (std::max)(min_bit_width_, parent_bit_width_);
      } else {
        return min_bit_width_;
      }
    }
  };

 private:
  void WriteAny(const Value &val, uint8_t byte_width) {
    switch (val.type_) {
      case FBT_NULL:
      case FBT_INT: Write(val.i_, byte_width); break;
      case FBT_BOOL:
      case FBT_UINT: Write(val.u_, byte_width); break;
      case FBT_FLOAT: WriteDouble(val.f_, byte_width); break;
      default: WriteOffset(val.u_, byte_width); break;
    }
  }

  size_t CreateBlob(const void *data, size_t len, size_t trailing, Type type) {
    auto bit_width = WidthU(len);
    auto byte_width = Align(bit_width);
    Write<uint64_t>(len, byte_width);
    auto sloc = buf_.size();
    WriteBytes(data, len + trailing);
    stack_.push_back(Value(static_cast<uint64_t>(sloc), type, bit_width));
    return sloc;
  }

  template<typename T>
  size_t ScalarVector(const T *elems, size_t len, bool fixed) {
    auto vector_type = GetScalarType<T>();
    auto byte_width = sizeof(T);
    auto bit_width = WidthB(byte_width);





    ((WidthU(len) <= bit_width) ? (void)0 : std:: __aeabi_assert("WidthU(len) <= bit_width", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1500),
# 1500 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1500 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1500 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((WidthU(len) <= bit_width)?1:0)
# 1500 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1500 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    Align(bit_width);
    if (!fixed) Write<uint64_t>(len, byte_width);
    auto vloc = buf_.size();
    for (size_t i = 0; i < len; i++) Write(elems[i], byte_width);
    stack_.push_back(Value(static_cast<uint64_t>(vloc),
                           ToTypedVector(vector_type, fixed ? len : 0),
                           bit_width));
    return vloc;
  }

  Value CreateVector(size_t start, size_t vec_len, size_t step, bool typed,
                     bool fixed, const Value *keys = nullptr) {
    ((!fixed || typed) ? (void)0 : std:: __aeabi_assert("!fixed || typed", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1515),
# 1513 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1513 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1513 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((!fixed || typed)?1:0)
# 1513 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1513 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);



    auto bit_width = (std::max)(force_min_bit_width_, WidthU(vec_len));
    auto prefix_elems = 1;
    if (keys) {


      bit_width = (std::max)(bit_width, keys->ElemWidth(buf_.size(), 0));
      prefix_elems += 2;
    }
    Type vector_type = FBT_KEY;

    for (size_t i = start; i < stack_.size(); i += step) {
      auto elem_width =
          stack_[i].ElemWidth(buf_.size(), i - start + prefix_elems);
      bit_width = (std::max)(bit_width, elem_width);
      if (typed) {
        if (i == start) {
          vector_type = stack_[i].type_;
        } else {


          ((vector_type == stack_[i].type_) ? (void)0 : std:: __aeabi_assert("vector_type == stack_[i].type_", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1537),
# 1537 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1537 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1537 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((vector_type == stack_[i].type_)?1:0)
# 1537 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1537 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
        }
      }
    }


    ((!fixed || IsTypedVectorElementType(vector_type)) ? (void)0 : std:: __aeabi_assert("!fixed || IsTypedVectorElementType(vector_type)", "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h", 1543),
# 1543 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic push
# 1543 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic ignored "-Wassume"
# 1543 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
 (__builtin_assume)((!fixed || IsTypedVectorElementType(vector_type))?1:0)
# 1543 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
#pragma clang diagnostic pop
# 1543 "../../../../ThirdParty/tflite_micro/_deps/tensorflow-flatbuffers-src/include\\flatbuffers/flexbuffers.h"
);
    auto byte_width = Align(bit_width);

    if (keys) {
      WriteOffset(keys->u_, byte_width);
      Write<uint64_t>(1ULL << keys->min_bit_width_, byte_width);
    }
    if (!fixed) Write<uint64_t>(vec_len, byte_width);

    auto vloc = buf_.size();
    for (size_t i = start; i < stack_.size(); i += step) {
      WriteAny(stack_[i], byte_width);
    }

    if (!typed) {
      for (size_t i = start; i < stack_.size(); i += step) {
        buf_.push_back(stack_[i].StoredPackedType(bit_width));
      }
    }
    return Value(static_cast<uint64_t>(vloc),
                 keys ? FBT_MAP
                      : (typed ? ToTypedVector(vector_type, fixed ? vec_len : 0)
                               : FBT_VECTOR),
                 bit_width);
  }


  Builder(const Builder &);
  Builder &operator=(const Builder &);

  std::vector<uint8_t> buf_;
  std::vector<Value> stack_;

  bool finished_;

  BuilderFlag flags_;

  BitWidth force_min_bit_width_;

  struct KeyOffsetCompare {
    explicit KeyOffsetCompare(const std::vector<uint8_t> &buf) : buf_(&buf) {}
    bool operator()(size_t a, size_t b) const {
      auto stra =
          reinterpret_cast<const char *>(flatbuffers::vector_data(*buf_) + a);
      auto strb =
          reinterpret_cast<const char *>(flatbuffers::vector_data(*buf_) + b);
      return strcmp(stra, strb) < 0;
    }
    const std::vector<uint8_t> *buf_;
  };

  typedef std::pair<size_t, size_t> StringOffset;
  struct StringOffsetCompare {
    explicit StringOffsetCompare(const std::vector<uint8_t> &buf)
        : buf_(&buf) {}
    bool operator()(const StringOffset &a, const StringOffset &b) const {
      auto stra = reinterpret_cast<const char *>(
          flatbuffers::vector_data(*buf_) + a.first);
      auto strb = reinterpret_cast<const char *>(
          flatbuffers::vector_data(*buf_) + b.first);
      return strncmp(stra, strb, (std::min)(a.second, b.second) + 1) < 0;
    }
    const std::vector<uint8_t> *buf_;
  };

  typedef std::set<size_t, KeyOffsetCompare> KeyOffsetMap;
  typedef std::set<StringOffset, StringOffsetCompare> StringOffsetMap;

  KeyOffsetMap key_pool;
  StringOffsetMap string_pool;
};

}
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/flatbuffer_utils.h" 2



namespace tflite {
# 39 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/flatbuffer_utils.h"
class FlexbufferWrapper : public flexbuffers::Vector {
 public:

  explicit FlexbufferWrapper(const uint8_t* buffer, size_t size);
  int64_t ElementAsInt64(size_t i) const;
  uint64_t ElementAsUInt64(size_t i) const;
  int32_t ElementAsInt32(size_t i) const;
  bool ElementAsBool(size_t i) const;
  double ElementAsDouble(size_t i) const;
  float ElementAsFloat(size_t i) const;
};


uint32_t NumSubgraphOperators(const SubGraph* subgraph);
uint32_t NumSubgraphOperators(const Model* model, int subgraph_idx);




TfLiteIntArray* FlatBufferVectorToTfLiteTypeArray(
    const flatbuffers::Vector<int32_t>* flatbuffer_array);
TfLiteFloatArray* FlatBufferVectorToTfLiteTypeArray(
    const flatbuffers::Vector<float>* flatbuffer_array);

}
# 26 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/memory_planner/micro_memory_planner.h" 1
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/memory_planner/micro_memory_planner.h"
namespace tflite {
# 46 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/memory_planner/micro_memory_planner.h"
class MicroMemoryPlanner {
 public:
  MicroMemoryPlanner() {}
  virtual ~MicroMemoryPlanner() {}






  virtual TfLiteStatus AddBuffer(tflite::ErrorReporter* error_reporter,
                                 int size, int first_time_used,
                                 int last_time_used) = 0;





  virtual TfLiteStatus AddBuffer(ErrorReporter* error_reporter, int size,
                                 int first_time_used, int last_time_used,
                                 int offline_offset) {
    return kTfLiteError;
  }


  virtual size_t GetMaximumMemorySize() = 0;

  virtual int GetBufferCount() = 0;

  virtual TfLiteStatus GetOffsetForBuffer(tflite::ErrorReporter* error_reporter,
                                          int buffer_index, int* offset) = 0;






  virtual TfLiteStatus Init(unsigned char* scratch_buffer,
                            int scratch_buffer_size) {
    return kTfLiteOk;
  }

  virtual void PrintMemoryPlan() {

  }
};

}
# 27 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/simple_memory_allocator.h" 1
# 26 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/simple_memory_allocator.h"
namespace tflite {




class SimpleMemoryAllocator {
 public:


  SimpleMemoryAllocator(ErrorReporter* error_reporter, uint8_t* buffer_head,
                        uint8_t* buffer_tail);
  SimpleMemoryAllocator(ErrorReporter* error_reporter, uint8_t* buffer,
                        size_t buffer_size);
  virtual ~SimpleMemoryAllocator();


  static SimpleMemoryAllocator* Create(ErrorReporter* error_reporter,
                                       uint8_t* buffer_head,
                                       size_t buffer_size);







  virtual TfLiteStatus SetHeadBufferSize(size_t size, size_t alignment);



  virtual uint8_t* AllocateFromTail(size_t size, size_t alignment);
# 66 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/simple_memory_allocator.h"
  virtual uint8_t* AllocateTemp(size_t size, size_t alignment);





  virtual void DeallocateTemp(uint8_t* buf);


  virtual bool IsAllTempDeallocated();



  virtual void ResetTempAllocations();



  uint8_t* GetHeadBuffer() const;


  size_t GetHeadUsedBytes() const;


  size_t GetTailUsedBytes() const;



  size_t GetAvailableMemory(size_t alignment) const;



  size_t GetUsedBytes() const;

  void operator delete(void* p) {}

 protected:

  uint8_t* head() const;


  uint8_t* tail() const;

 private:
  size_t GetBufferSize() const;

  ErrorReporter* error_reporter_;
  uint8_t* buffer_head_;
  uint8_t* buffer_tail_;
  uint8_t* head_;
  uint8_t* tail_;
  uint8_t* temp_;
# 125 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/simple_memory_allocator.h"
  intptr_t temp_buffer_ptr_check_sum_ = 0;

  int temp_buffer_count_ = 0;
};

}
# 28 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h" 2


namespace tflite {



namespace internal {





TfLiteStatus InitializeTfLiteTensorFromFlatbuffer(
    SimpleMemoryAllocator* allocator, bool allocate_temp,
    const tflite::Tensor& flatbuffer_tensor,
    const flatbuffers::Vector<flatbuffers::Offset<Buffer>>* buffers,
    ErrorReporter* error_reporter, TfLiteTensor* result);
# 56 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
typedef struct {


  size_t bytes;



  int node_idx;
} ScratchBufferRequest;

}

typedef struct {
  TfLiteNode node;
  const TfLiteRegistration* registration;
} NodeAndRegistration;




typedef struct {

  uint8_t* data;
} ScratchBufferHandle;



typedef struct {
  NodeAndRegistration* node_and_registrations;
  TfLiteEvalTensor* tensors;
} SubgraphAllocations;
# 111 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
class MicroAllocator {
 public:






  static MicroAllocator* Create(uint8_t* tensor_arena, size_t arena_size,
                                ErrorReporter* error_reporter);





  static MicroAllocator* Create(uint8_t* tensor_arena, size_t arena_size,
                                MicroMemoryPlanner* memory_planner,
                                ErrorReporter* error_reporter);




  static MicroAllocator* Create(SimpleMemoryAllocator* memory_allocator,
                                MicroMemoryPlanner* memory_planner,
                                ErrorReporter* error_reporter);


  static size_t GetDefaultTailUsage(bool is_memory_planner_given);
# 149 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
  SubgraphAllocations* StartModelAllocation(const Model* model);
# 163 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
  TfLiteStatus FinishModelAllocation(
      const Model* model, SubgraphAllocations* subgraph_allocations,
      ScratchBufferHandle** scratch_buffer_handles);







  virtual TfLiteTensor* AllocatePersistentTfLiteTensor(
      const Model* model, const SubgraphAllocations* subgraph_allocations,
      int tensor_index, int subgraph_index);
# 184 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_allocator.h"
  virtual TfLiteTensor* AllocateTempTfLiteTensor(
      const Model* model, const SubgraphAllocations* subgraph_allocations,
      int tensor_index, int subgraph_index);

  virtual void DeallocateTempTfLiteTensor(TfLiteTensor*);




  virtual void ResetTempAllocations();



  virtual bool IsAllTempDeallocated();




  virtual void* AllocatePersistentBuffer(size_t bytes);





  TfLiteStatus RequestScratchBufferInArena(size_t bytes, int subgraph_idx,
                                           int* buffer_idx);





  TfLiteStatus FinishPrepareNodeAllocations(int node_id);



  size_t used_bytes() const;

  BuiltinDataAllocator* GetBuiltinDataAllocator();

 protected:
  MicroAllocator(SimpleMemoryAllocator* memory_allocator,
                 MicroMemoryPlanner* memory_planner,
                 ErrorReporter* error_reporter);
  virtual ~MicroAllocator();




  virtual TfLiteStatus AllocateNodeAndRegistrations(
      const Model* model, SubgraphAllocations* subgraph_allocations);




  virtual TfLiteStatus AllocateTfLiteEvalTensors(
      const Model* model, SubgraphAllocations* subgraph_allocations);

  virtual TfLiteStatus AllocateVariables(const SubGraph* subgraph,
                                         TfLiteEvalTensor* eval_tensors);




  virtual TfLiteTensor* AllocatePersistentTfLiteTensorInternal();




  virtual TfLiteStatus PopulateTfLiteTensorFromFlatbuffer(const Model* model,
                                                          TfLiteTensor* tensor,
                                                          int tensor_index,
                                                          int subgraph_idx,
                                                          bool allocate_temp);

  ErrorReporter* error_reporter() const;

 private:







  virtual TfLiteStatus CommitStaticMemoryPlan(
      const Model* model, TfLiteEvalTensor* eval_tensors,
      ScratchBufferHandle* scratch_buffer_handles, int subgraph_idx);



  virtual TfLiteStatus AllocateScratchBufferHandles(
      ScratchBufferHandle** scratch_buffer_handles, size_t handle_count);




  TfLiteStatus InitScratchBufferData();



  internal::ScratchBufferRequest* GetScratchBufferRequests();


  SimpleMemoryAllocator* memory_allocator_;


  BuiltinDataAllocator* builtin_data_allocator_;


  MicroMemoryPlanner* memory_planner_;

  ErrorReporter* error_reporter_;
  bool model_is_allocating_;



  size_t scratch_buffer_request_count_ = 0;



  size_t max_head_buffer_usage_ = 0;

  void operator delete(void* p) {}
};

}
# 27 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_context.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_context.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_graph.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_graph.h"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_resource_variable.h" 1
# 24 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_resource_variable.h"
namespace tflite {

class MicroResourceVariables {
 public:

  static MicroResourceVariables* Create(MicroAllocator* allocator,
                                        int num_variables);






  int CreateIdIfNoneFound(const char* container, const char* shared_name);



  TfLiteStatus Read(int id, const TfLiteEvalTensor* tensor);




  TfLiteStatus Allocate(int id, TfLiteContext* context,
                        const TfLiteTensor* tensor);




  TfLiteStatus Assign(int id, const TfLiteEvalTensor* tensor);

 private:
  int FindId(const char* container, const char* shared_name);






  struct MicroResourceVariable {
    const char* container;
    const char* shared_name;
    void* resource_buffer;


    size_t bytes;
  };

  MicroResourceVariables(MicroResourceVariable* variables,
                         int max_variable_count)
      : resource_variables_(variables),
        max_variable_count_(max_variable_count),
        num_resource_variables_(0) {}

  MicroResourceVariable* resource_variables_;
  int max_variable_count_;
  int num_resource_variables_;
};

}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_graph.h" 2


namespace tflite {





class MicroGraph {
 public:




  MicroGraph(TfLiteContext* context, const Model* model,
             MicroAllocator* allocator,
             MicroResourceVariables* resource_variables);
  virtual ~MicroGraph();



  virtual TfLiteStatus InitSubgraphs();



  virtual TfLiteStatus PrepareSubgraphs();



  virtual TfLiteStatus FreeSubgraphs();



  virtual TfLiteStatus InvokeSubgraph(int subgraph_idx);


  virtual TfLiteStatus ResetVariableTensors();


  virtual size_t NumSubgraphInputs(int subgraph_idx);


  virtual TfLiteEvalTensor* GetSubgraphInput(int subgraph_idx, int input_idx);


  virtual size_t NumSubgraphOutputs(int subgraph_idx);


  virtual TfLiteEvalTensor* GetSubgraphOutput(int subgraph_idx, int output_idx);


  virtual int NumSubgraphs();



  void SetSubgraphAllocations(SubgraphAllocations* subgraph_allocations);



  int GetCurrentSubgraphIndex() { return current_subgraph_index_; }



  SubgraphAllocations* GetAllocations() { return subgraph_allocations_; }


  MicroResourceVariables* GetResourceVariables() { return resource_variables_; }

 private:
  TfLiteContext* context_;
  const Model* model_;
  MicroAllocator* allocator_;
  SubgraphAllocations* subgraph_allocations_ = nullptr;
  int current_subgraph_index_;
  MicroResourceVariables* resource_variables_;
  const flatbuffers::Vector<flatbuffers::Offset<SubGraph>>* subgraphs_;

  void operator delete(void* p) {}
};

}
# 22 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_context.h" 2

namespace tflite {






class MicroContext {
 public:


  explicit MicroContext(MicroAllocator* allocator, const Model* model,
                        MicroGraph* graph);
  virtual ~MicroContext();






  virtual void* AllocatePersistentBuffer(size_t bytes);






  virtual TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                                   int* buffer_idx);




  virtual void* GetScratchBuffer(int buffer_idx);



  virtual TfLiteTensor* AllocateTempTfLiteTensor(int tensor_idx);





  virtual TfLiteTensor* AllocateTempInputTensor(const TfLiteNode* node,
                                                int index);





  virtual TfLiteTensor* AllocateTempOutputTensor(const TfLiteNode* node,
                                                 int index);



  virtual void DeallocateTempTfLiteTensor(TfLiteTensor* tensor);



  virtual TfLiteEvalTensor* GetEvalTensor(int tensor_idx);




  TfLiteStatus set_external_context(void* external_context_payload);

  void* external_context() { return external_context_payload_; }

  MicroGraph& graph() { return graph_; }




  void SetScratchBufferHandles(ScratchBufferHandle* scratch_buffer_handles);

 private:


  int GetTensorIndex(int index, int max_size, const int* tensor_indices);

  MicroAllocator& allocator_;
  MicroGraph& graph_;
  const Model* model_;

  ScratchBufferHandle* scratch_buffer_handles_ = nullptr;
  void* external_context_payload_ = nullptr;

  void operator delete(void* p) {}
};

inline MicroContext* GetMicroContext(const struct TfLiteContext* context) {
  return reinterpret_cast<MicroContext*>(context->impl_);
}






inline void* MicroContextAllocatePersistentBuffer(TfLiteContext* ctx,
                                                  size_t bytes) {
  return GetMicroContext(ctx)->AllocatePersistentBuffer(bytes);
}
inline TfLiteStatus MicroContextRequestScratchBufferInArena(TfLiteContext* ctx,
                                                            size_t bytes,
                                                            int* buffer_idx) {
  return GetMicroContext(ctx)->RequestScratchBufferInArena(bytes, buffer_idx);
}
inline void* MicroContextGetScratchBuffer(TfLiteContext* ctx, int buffer_idx) {
  return GetMicroContext(ctx)->GetScratchBuffer(buffer_idx);
}
inline TfLiteTensor* MicroContextGetTensor(const struct TfLiteContext* context,
                                           int tensor_idx) {
  return GetMicroContext(context)->AllocateTempTfLiteTensor(tensor_idx);
}
inline TfLiteEvalTensor* MicroContextGetEvalTensor(
    const struct TfLiteContext* context, int tensor_idx) {
  return GetMicroContext(context)->GetEvalTensor(tensor_idx);
}
inline TfLiteExternalContext* MicroContextGetExternalContext(
    TfLiteContext* context, TfLiteExternalContextType unused) {
  return reinterpret_cast<TfLiteExternalContext*>(
      GetMicroContext(context)->external_context());
}


void MicroContextReportOpError(struct TfLiteContext* context,
                               const char* format, ...);

}
# 28 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 2


# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_profiler.h" 1
# 23 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_profiler.h"
namespace tflite {





class MicroProfiler {
 public:
  MicroProfiler() = default;
  virtual ~MicroProfiler() = default;




  virtual uint32_t BeginEvent(const char* tag);
# 46 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_profiler.h"
  virtual void EndEvent(uint32_t event_handle);


  void ClearEvents() { num_events_ = 0; }




  int32_t GetTotalTicks() const;



  void Log() const;



  void LogCsv() const;

 private:



  static constexpr int kMaxEvents = 1024;

  const char* tags_[kMaxEvents];
  int32_t start_ticks_[kMaxEvents];
  int32_t end_ticks_[kMaxEvents];
  int num_events_ = 0;

  void operator delete(void* p) {};
};
# 100 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_profiler.h"
class ScopedMicroProfiler {
 public:
  explicit ScopedMicroProfiler(const char* tag, MicroProfiler* profiler)
      : profiler_(profiler) {
    if (profiler_ != nullptr) {
      event_handle_ = profiler_->BeginEvent(tag);
    }
  }

  ~ScopedMicroProfiler() {
    if (profiler_ != nullptr) {
      profiler_->EndEvent(event_handle_);
    }
  }

 private:
  uint32_t event_handle_ = 0;
  MicroProfiler* profiler_ = nullptr;
};


}
# 31 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/portable_type_to_tflitetype.h" 1
# 32 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/portable_type_to_tflitetype.h"
namespace tflite {





template <typename T>
constexpr TfLiteType typeToTfLiteType() {
  return kTfLiteNoType;
}



template <TfLiteType TFLITE_TYPE_ENUM>
struct TfLiteTypeToType {};
# 61 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/portable_type_to_tflitetype.h"
template <> constexpr TfLiteType typeToTfLiteType<int32_t>() { return kTfLiteInt32; } template <> struct TfLiteTypeToType<kTfLiteInt32> { using Type = int32_t; };
template <> constexpr TfLiteType typeToTfLiteType<uint32_t>() { return kTfLiteUInt32; } template <> struct TfLiteTypeToType<kTfLiteUInt32> { using Type = uint32_t; };
template <> constexpr TfLiteType typeToTfLiteType<int16_t>() { return kTfLiteInt16; } template <> struct TfLiteTypeToType<kTfLiteInt16> { using Type = int16_t; };
template <> constexpr TfLiteType typeToTfLiteType<uint16_t>() { return kTfLiteUInt16; } template <> struct TfLiteTypeToType<kTfLiteUInt16> { using Type = uint16_t; };
template <> constexpr TfLiteType typeToTfLiteType<int64_t>() { return kTfLiteInt64; } template <> struct TfLiteTypeToType<kTfLiteInt64> { using Type = int64_t; };
template <> constexpr TfLiteType typeToTfLiteType<float>() { return kTfLiteFloat32; } template <> struct TfLiteTypeToType<kTfLiteFloat32> { using Type = float; };
template <> constexpr TfLiteType typeToTfLiteType<unsigned char>() { return kTfLiteUInt8; } template <> struct TfLiteTypeToType<kTfLiteUInt8> { using Type = unsigned char; };
template <> constexpr TfLiteType typeToTfLiteType<int8_t>() { return kTfLiteInt8; } template <> struct TfLiteTypeToType<kTfLiteInt8> { using Type = int8_t; };
template <> constexpr TfLiteType typeToTfLiteType<bool>() { return kTfLiteBool; } template <> struct TfLiteTypeToType<kTfLiteBool> { using Type = bool; };
template <> constexpr TfLiteType typeToTfLiteType<TfLiteFloat16>() { return kTfLiteFloat16; } template <> struct TfLiteTypeToType<kTfLiteFloat16> { using Type = TfLiteFloat16; };
template <> constexpr TfLiteType typeToTfLiteType<double>() { return kTfLiteFloat64; } template <> struct TfLiteTypeToType<kTfLiteFloat64> { using Type = double; };
template <> constexpr TfLiteType typeToTfLiteType<uint64_t>() { return kTfLiteUInt64; } template <> struct TfLiteTypeToType<kTfLiteUInt64> { using Type = uint64_t; };

}
# 32 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h" 2






namespace tflite {

class MicroInterpreter {
 public:
# 50 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_interpreter.h"
  MicroInterpreter(const Model* model, const MicroOpResolver& op_resolver,
                   uint8_t* tensor_arena, size_t tensor_arena_size,
                   ErrorReporter* error_reporter,
                   MicroResourceVariables* resource_variables = nullptr,
                   MicroProfiler* profiler = nullptr);






  MicroInterpreter(const Model* model, const MicroOpResolver& op_resolver,
                   MicroAllocator* allocator, ErrorReporter* error_reporter,
                   MicroResourceVariables* resource_variables = nullptr,
                   MicroProfiler* profiler = nullptr);

  ~MicroInterpreter();



  TfLiteStatus AllocateTensors();




  TfLiteStatus Invoke();





  TfLiteStatus SetMicroExternalContext(void* external_context_payload);

  TfLiteTensor* input(size_t index);
  size_t inputs_size() const {
    return model_->subgraphs()->Get(0)->inputs()->size();
  }
  const flatbuffers::Vector<int32_t>& inputs() const {
    return *model_->subgraphs()->Get(0)->inputs();
  }
  TfLiteTensor* input_tensor(size_t index) { return input(index); }
  template <class T>
  T* typed_input_tensor(int tensor_index) {
    if (TfLiteTensor* tensor_ptr = input_tensor(tensor_index)) {
      if (tensor_ptr->type == typeToTfLiteType<T>()) {
        return GetTensorData<T>(tensor_ptr);
      }
    }
    return nullptr;
  }

  TfLiteTensor* output(size_t index);
  size_t outputs_size() const {
    return model_->subgraphs()->Get(0)->outputs()->size();
  }
  const flatbuffers::Vector<int32_t>& outputs() const {
    return *model_->subgraphs()->Get(0)->outputs();
  }
  TfLiteTensor* output_tensor(size_t index) { return output(index); }
  template <class T>
  T* typed_output_tensor(int tensor_index) {
    if (TfLiteTensor* tensor_ptr = output_tensor(tensor_index)) {
      if (tensor_ptr->type == typeToTfLiteType<T>()) {
        return GetTensorData<T>(tensor_ptr);
      }
    }
    return nullptr;
  }


  TfLiteStatus ResetVariableTensors();

  TfLiteStatus initialization_status() const { return initialization_status_; }





  TfLiteStatus PrepareNodeAndRegistrationDataFromFlatbuffer();







  size_t arena_used_bytes() const { return allocator_.used_bytes(); }

 protected:
  const MicroAllocator& allocator() const { return allocator_; }
  const TfLiteContext& context() const { return context_; }

 private:


  void Init(MicroProfiler* profiler);


  int get_subgraph_index() { return graph_.GetCurrentSubgraphIndex(); }

  const Model* model_;
  const MicroOpResolver& op_resolver_;
  ErrorReporter* error_reporter_;
  TfLiteContext context_ = {};
  MicroAllocator& allocator_;
  MicroGraph graph_;
  bool tensors_allocated_;

  TfLiteStatus initialization_status_;

  ScratchBufferHandle* scratch_buffer_handles_ = nullptr;



  TfLiteTensor** input_tensors_;
  TfLiteTensor** output_tensors_;

  MicroContext micro_context_;
};

}
# 33 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_error_reporter.h" 1
# 26 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/micro_error_reporter.h"
void MicroPrintf(const char* format, ...);






namespace tflite {



template <typename... Args>
void Unused(Args&&... args) {
  (void)(sizeof...(args));
}


ErrorReporter* GetMicroErrorReporter();

class MicroErrorReporter : public ErrorReporter {
 public:
  ~MicroErrorReporter() override {}
  int Report(const char* format, va_list args) override;

 private:
  void operator delete(void* p) {}
};

}
# 34 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 2
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/all_ops_resolver.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/micro/all_ops_resolver.h"
namespace tflite {






class AllOpsResolver : public MicroMutableOpResolver<128> {
 public:
  AllOpsResolver();

 private:
  void operator delete(void* p) {}
};

}
# 35 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 2
#pragma clang diagnostic pop
# 54 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp"
# 1 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/schema/schema_utils.h" 1
# 21 "../../../../ThirdParty/tflite_micro\\tensorflow/lite/schema/schema_utils.h"
namespace tflite {





BuiltinOperator GetBuiltinCode(const OperatorCode *op_code);

BuiltinOperator GetBuiltinCode(const OperatorCodeT *op_code);

}
# 55 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include/TensorFlowLiteMicro.hpp" 2





namespace arm {
namespace app {


    struct QuantParams {
        float scale = 1.0;
        int offset = 0;
    };






    QuantParams GetTensorQuantParams(TfLiteTensor* tensor);

}
}




void PrintTensorFlowVersion();






extern "C" void DebugLog(const char* s) __attribute__((__weak__));
# 21 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include\\Model.hpp" 2



namespace arm {
namespace app {




    class Model {
    public:

        Model();


        ~Model();


        TfLiteTensor* GetInputTensor(size_t index) const;


        TfLiteTensor* GetOutputTensor(size_t index) const;


        TfLiteType GetType() const;


        TfLiteIntArray* GetInputShape(size_t index) const;


        TfLiteIntArray* GetOutputShape(size_t index) const;


        size_t GetNumInputs() const;


        size_t GetNumOutputs() const;


        void LogTensorInfo(TfLiteTensor* tensor);


        void LogInterpreterInfo();
# 75 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/application/api/common/include\\Model.hpp"
        bool Init(uint8_t* tensorArenaAddr,
                  uint32_t tensorArenaSize,
                  const uint8_t* nnModelAddr,
                  uint32_t nnModelSize,
                  tflite::MicroAllocator* allocator = nullptr);






        tflite::MicroAllocator* GetAllocator();


        bool IsInited() const;


        bool IsDataSigned() const;


        bool ContainsEthosUOperator() const;


        virtual bool RunInference();




        bool ShowModelInfoHandler();


        uint8_t* GetTensorArena();

    protected:



        const uint8_t* ModelPointer();




        uint32_t ModelSize();





        virtual const tflite::MicroOpResolver& GetOpResolver() = 0;






        virtual bool EnlistOperations() = 0;


        size_t GetActivationBufferSize();

    private:
        tflite::ErrorReporter* m_pErrorReporter{nullptr};
        const tflite::Model* m_pModel{nullptr};
        tflite::MicroInterpreter* m_pInterpreter{nullptr};
        tflite::MicroAllocator* m_pAllocator{nullptr};
        bool m_inited{false};
        const uint8_t* m_modelAddr{nullptr};
        uint32_t m_modelSize{0};

        std::vector<TfLiteTensor*> m_input{};
        std::vector<TfLiteTensor*> m_output{};
        TfLiteType m_type{kTfLiteNoType};
    };

}
}
# 21 "../Model/include\\YoloFastestModel.hpp" 2

extern const int originalImageSize;
extern const int channelsImageDisplayed;
extern const float anchor1[];
extern const float anchor2[];
extern const int numClasses;

namespace arm
{
namespace app
{

class YoloFastestModel : public Model
{

public:

    static constexpr uint32_t ms_inputRowsIdx = 1;
    static constexpr uint32_t ms_inputColsIdx = 2;
    static constexpr uint32_t ms_inputChannelsIdx = 3;

protected:

    const tflite::MicroOpResolver &GetOpResolver() override;


    bool EnlistOperations() override;

    const uint8_t *ModelPointer();

    size_t ModelSize();

private:

    static constexpr int ms_maxOpCnt = 8;


    tflite::MicroMutableOpResolver<ms_maxOpCnt> m_opResolver;
};

}
}
# 18 "../Model/YoloFastestModel.cpp" 2

# 1 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/log/include\\log_macros.h" 1
# 21 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/log/include\\log_macros.h"
extern "C" {



# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdio.h" 1 3
# 25 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/log/include\\log_macros.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 1 3
# 242 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 251 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 1 3
# 222 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
typedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;



extern "C" {


__attribute__((__nothrow__)) intmax_t strtoimax(const char * __restrict ,
                   char ** __restrict , int ) __attribute__((__nonnull__(1)));

__attribute__((__nothrow__)) uintmax_t strtoumax(const char * __restrict ,
                    char ** __restrict , int ) __attribute__((__nonnull__(1)));


__attribute__((__nothrow__)) intmax_t wcstoimax(const wchar_t * __restrict ,
                   wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));
__attribute__((__nothrow__)) uintmax_t wcstoumax(const wchar_t * __restrict ,
                    wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));

extern __attribute__((__nothrow__)) __attribute__((__const__)) intmax_t imaxabs(intmax_t );





extern __attribute__((__nothrow__)) __attribute__((__const__)) imaxdiv_t imaxdiv(intmax_t , intmax_t );
# 263 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
}
# 252 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 2 3
# 26 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/log/include\\log_macros.h" 2
# 70 "../../../../ThirdParty/ml-embedded-evaluation-kit/source/log/include\\log_macros.h"
}
# 20 "../Model/YoloFastestModel.cpp" 2

const tflite::MicroOpResolver &arm::app::YoloFastestModel::GetOpResolver()
{
    return this->m_opResolver;
}

bool arm::app::YoloFastestModel::EnlistOperations()
{
# 36 "../Model/YoloFastestModel.cpp"
   this->m_opResolver.AddTranspose();



    if (kTfLiteOk == this->m_opResolver.AddEthosU())
    {
        printf("INFO - "); printf("Added %s support to op resolver\n", tflite::GetString_ETHOSU());

    }
    else
    {
        printf("ERROR - "); printf("Failed to add Arm NPU support to op resolver.");
        return false;
    }


    return true;
}

namespace arm
{
namespace app
{
namespace yolofastest
{
extern const uint8_t *GetModelPointer();
extern size_t GetModelLen();
}
}
}

const uint8_t *arm::app::YoloFastestModel::ModelPointer()
{
    return arm::app::yolofastest::GetModelPointer();
}

size_t arm::app::YoloFastestModel::ModelSize()
{
    return arm::app::yolofastest::GetModelLen();
}
